
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Tomato&#39;s blog">
    <title>call、apply和bind - Tomato&#39;s blog</title>
    <meta name="author" content="TomatoMan">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TomatoMan","sameAs":["https://github.com/TomatoesMan/TomatoesMan.github.io"],"image":"author.jpg"},"articleBody":"call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。\n\n\n1、callW3school中对 call()方法的定义是：它可以用来调用所有者对象作为参数的方法。通过 call()，能够使用属于另一个对象的方法。我们举个例子：\n1234567var foo = &#123;  name: \"Jack\",&#125;;function bar() &#123;  console.log(this.name);&#125;bar.call(foo);\n\n由上可以看出 call()函数主要做了两件事，第一个是改变 this 的指向，将 bar 中的 this 指向了 foo，第二个是执行了 bar 方法。\n接下来我们来模拟 call 方法：\n第一步：实现简单的 call 方法：上面的例子可以改造为：\n1234567var foo = &#123;  name: \"Jack\",  bar: function () &#123;    console.log(this.name);  &#125;,&#125;;foo.bar();\n\n输出的结果和上述的一模一样，唯一的不同就是 foo 中多了一个 bar 的属性，那我们执行完后删除这个属性就可以了。\n123456789101112Function.prototype.myCall = function (Context) &#123;  Context.fn = this; // 此时的this指向的是Function，即调用者  Context.fn();  delete Context.fn;&#125;;var foo = &#123;  name: \"Jack\",&#125;;function bar() &#123;  console.log(this.name);&#125;bar.myCall(foo);\n\n结果和 call 一致。\n第二步：因为 call 可以带参数，所以我们接下来实现这个看一下原版的：\n123456789var foo = &#123;  name: \"Jack\",&#125;;function bar(age, goods) &#123;  console.log(this.name);  console.log(age); // 10  console.log(goods); // 自行车&#125;bar.call(foo, 10, \"自行车\");\n\n因为参数是不固定的，所以可以想到 arguments。怎么将 arguments 传入对象中，这就是个难题，高兴的是 ES6 给了我们方法：解构赋值\n123456789101112131415Function.prototype.myCall = function (Context) &#123;  Context.fn = this; // 此时的this指向的是Function，即调用者  var args = [...arguments].slice(1);  Context.fn(...args);  delete Context.fn;&#125;;var foo = &#123;  name: \"Jack\",&#125;;function bar(age, goods) &#123;  console.log(this.name);  console.log(age); // 10  console.log(goods); // 自行车&#125;bar.myCall(foo, 10, \"自行车\");\n\n是不是感觉特别简单，但是 call 是 ES3 的方法，解构赋值是 ES6 的方法，感觉有点欺负它，那我们就需要重新想一个。这个方法也是查看了资料后才找到的，自己能力还是有限啊！可以运用 eval()，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\n123456789101112131415161718Function.prototype.myCall = function(Context) &#123;  Context.fn = this; // 此时的this指向的是Function，即调用者  var args = [];  for (var i = 1; i &lt; arguments.length; i++&gt;) &#123;    args.push('arguments[+' i '+]');  &#125;  eval('Context.fn(+' args '+)');  delete Context.fn;&#125;var foo = &#123;  name: 'Jack'&#125;function bar(age, goods) &#123;  console.log(this.name);  console.log(age); // 10  console.log(goods); // 自行车&#125;bar.myCall(foo, 10, '自行车');\n\n感觉很完美了，但是依旧有两小点需要注意：\n\n当 this 为 null 时\n当函数有返回值时我们先来看第一点：\n\n12345var name = \"Jack\";function bar() &#123;  console.log(this.name); // Jack&#125;bar.call(null);\n\n当 this 为 null 时，默认走向 window第二点：\n12345678910var foo = &#123;  name: \"Jack\",&#125;;function bar() &#123;  return &#123;    age: 1,    goods: \"自行车\",  &#125;;&#125;bar.call(foo); // &#123;age: 1, goods: \"自行车\"&#125;\n\n当函数有返回值时，结果就是这个返回值。\n第三步：我们对自己模拟的方法进行最后的优化：1234567891011Function.prototype.myCall = function (Context) &#123;  var Context = Context ? Context : window;  Context.fn = this; // 此时的this指向的是Function，即调用者  var args = [];  for (var i = 1; i &lt; arguments.length; i++) &#123;    args.push(\"arguments[\" + i + \"]\");  &#125;  var result = eval(\"Context.fn(\" + args + \")\");  delete Context.fn;  return result;&#125;;\n\n2、applycall() 和 apply() 之间的区别，不同之处是：\n\ncall() 方法分别接受参数。\napply() 方法接受数组形式的参数。\n\n所以 call 和 apply 只是接受参数的不同，思路还是和 call 一样，这次就不重复了直接贴代码：运用解构赋值：\n12345678Function.prototype.myApply = function (Context) &#123;  var Context = Context ? Context : window;  Context.fn = this; // 此时的this指向的是Function，即调用者  var args = arguments[1] ? arguments[1] : [];  var result = Context.fn(...args);  delete Context.fn;  return result;&#125;;\n\n运用 eval：\n12345678910111213141516171819Function.prototype.myApply = function (Context) &#123;  var Context = Context ? Context : window;  Context.fn = this; // 此时的this指向的是Function，即调用者  var args = [];  var arguments = arguments[1] ? arguments[1] : [];  for (var i = 0; i &lt; arguments.length; i++) &#123;    args.push(\"arguments[\" + i + \"]\");  &#125;  var result = eval(\"Context.fn(\" + args + \")\");  delete Context.fn;  return result;&#125;;var foo = &#123;  name: \"Jack\",&#125;;function bar() &#123;  console.log(this.name);&#125;bar.myApply(foo);\n\n3、bindbind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind()的第一个参数, 它的参数是 bind()的其他参数和其原本的参数。所以 bind 执行两个步骤：\n\n返回一个新函数\n可以传入参数\n\n我们按照分析 call()函数一样的思路来分析 bind()，首先看一下原先的 bind：\n12345678var foo = &#123;  name: \"Jack\",&#125;;function bar() &#123;  console.log(this.name);&#125;var bindFoo = bar.bind(foo);bindFoo(); // Jack\n\n所以可以看出 bar.bind(foo);返回一个新的函数，当这个函数执行时，才返回其中的结果，那我们先模拟一下这个：\n1234567891011121314Function.prototype.myBind = function (Context) &#123;  var self = this;  return function () &#123;    return self.apply(Context);  &#125;;&#125;;var foo = &#123;  name: \"Jack\",&#125;;function bar() &#123;  console.log(this.name);&#125;var bindFoo = bar.myBind(foo);bindFoo(); // Jack\n\n结果一样，说明这一步模拟的没有问题。那我们进行下一步的模拟，因为 bind 也是可以携带参数的，携带参数的方式和 call 相同：\n12345678910var foo = &#123;  name: \"Jack\",&#125;;function bar(age, goods) &#123;  console.log(this.name);  console.log(age);  console.log(goods);&#125;var bindFoo = bar.bind(foo, 1, \"1\");bindFoo(); // Jack 1 1\n\n模拟板升级：\n1234567Function.prototype.myBind = function (Context) &#123;  var self = this;  var args = [].slice.call(arguments, 1);  return function () &#123;    return self.apply(Context, args);  &#125;;&#125;;\n\n很完美，但是 bind 有个特点被忽视了，因为 bind 返回一个新的函数，那我们将返回的函数里面传参，会有什么效果，我们看一下：\n12345678910var foo = &#123;  name: \"Jack\",&#125;;function bar(age, goods) &#123;  console.log(this.name);  console.log(age);  console.log(goods);&#125;var bindFoo = bar.bind(foo, 1);bindFoo(\"1\"); // Jack 1 1\n\n可以看出 bind 可以只传入 age，然后再从返回的新函数中传入 goods，那我们需要把上述模拟进行升级：\n12345678Function.prototype.myBind = function (Context) &#123;  var self = this;  var args = [].slice.call(arguments, 1);  return function () &#123;    var bindArgs = [].slice.call(arguments);    return self.apply(Context, args.concat(bindArgs));  &#125;;&#125;;\n\n思路其实很简单，就是将两个 arguments 进行合并。本以为这样就结束了，但是 MDN 提到了 bind 的另外一个特点：绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。什么意思呢？用代码演示一下：\n123456789101112var foo = &#123;  name: \"Jack\",&#125;;function bar(age, goods) &#123;  console.log(this.name);  console.log(age);  console.log(goods);&#125;bar.prototype.friends = \"a\";var BindFoo = bar.bind(foo, 1);var bindFoo = new BindFoo(\"1\"); // undefined 1 1console.log(bindFoo.friends); // a\n\nthis.name 竟然输出 undefined，那是因为 new 后，BindFoo 中 this 的指向改变了，指向了 bindFoo，而 BindFoo 实际是 bar 函数，并且 bindFoo 没有 value 属性，所以就输出了 undefined，通过 instanceof 就可以看出来，bindFoo 是 BindFoo 的实例，也是 bar 的实例。\n123456789101112131415Function.prototype.myBind = function (Context) &#123;  var self = this;  var args = [].slice.call(arguments, 1);  var cacheFn = function () &#123;&#125;;  var bindFun = function () &#123;    var bindArgs = [].slice.call(arguments);    return self.apply(      this instanceof cacheFn ? this : Context,      args.concat(bindArgs)    );  &#125;;  cacheFn.prototype = this.prototype;  bindFun.prototype = new cacheFn();  return bindFun;&#125;;\n\n我们进行分步讲解：1、为什么要判断 this instanceof bindFun？之前也说到，当将 bind 返回后函数当做构造函数时，bindFoo 即是 BindFoo 的实例也是 bar 的实例，BindFoo 即为返回来的函数，在我们模拟的代码中就是 bindFun 这个函数，并且当 new 之后 this 指向的是实例，所以用 this instanceof bindFun 判断的实际就是函数前有没有 new 这个关键词。2、为什么要继承 this 的原型？这是为了继承 bar 原型上的属性。最后一步，健壮模拟的 bind，判断传过来的 this 是否为函数，也是最终版：\n1234567891011121314151617181920Function.prototype.myBind = function (Context) &#123;  if (typeof this !== \"function\") &#123;    throw new Error(      \"Function.prototype.bind - what is trying to be bound is not callable\"    );  &#125;  var self = this;  var args = [].slice.call(arguments, 1);  var cacheFn = function () &#123;&#125;;  var bindFun = function () &#123;    var bindArgs = [].slice.call(arguments);    return self.apply(      this instanceof cacheFn ? this : Context,      args.concat(bindArgs)    );  &#125;;  cacheFn.prototype = this.prototype;  bindFun.prototype = new cacheFn();  return bindFun;&#125;;\n","dateCreated":"2020-06-18T23:03:59+08:00","dateModified":"2020-06-25T19:52:37+08:00","datePublished":"2020-06-18T23:03:59+08:00","description":"call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。","headline":"call、apply和bind","image":["https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593095782575&di=0f02fa07eb8c80304015e32141a07c1f&imgtype=0&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"},"publisher":{"@type":"Organization","name":"TomatoMan","sameAs":["https://github.com/TomatoesMan/TomatoesMan.github.io"],"image":"author.jpg","logo":{"@type":"ImageObject","url":"author.jpg"}},"url":"https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/","keywords":"前端, javascript","thumbnailUrl":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593095782575&di=0f02fa07eb8c80304015e32141a07c1f&imgtype=0&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg"}</script>
    <meta name="description" content="call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。">
<meta property="og:type" content="blog">
<meta property="og:title" content="call、apply和bind">
<meta property="og:url" content="https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/index.html">
<meta property="og:site_name" content="Tomato&#39;s blog">
<meta property="og:description" content="call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-18T15:03:59.000Z">
<meta property="article:modified_time" content="2020-06-25T11:52:37.088Z">
<meta property="article:author" content="TomatoMan">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://TomatoesMan.github.io/assets/images/author.jpg"/>
    
    
        <meta property="og:image" content="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg"/>
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-suodpugx9ofcga79nznih1fcbmzciq3ml6rzj9xp1ewhmlpff4ih6yfwkzie.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            Tomato&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/author.jpg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/author.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">TomatoMan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/TomatoesMan/TomatoesMan.github.io"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            call、apply和bind
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-06-18T23:03:59+08:00">
	
		    6月 18, 2020
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/JS%E5%9F%BA%E7%A1%80/">JS基础</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。</p>
<a id="more"></a>

<h2 id="1、call"><a href="#1、call" class="headerlink" title="1、call"></a>1、call</h2><p><a href="https://www.w3school.com.cn/js/js_function_call.asp" target="_blank" rel="noopener">W3school</a>中对 call()方法的定义是：它可以用来调用所有者对象作为参数的方法。通过 call()，能够使用属于另一个对象的方法。<br>我们举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo);</span><br></pre></td></tr></table></figure>

<p>由上可以看出 call()函数主要做了两件事，第一个是改变 this 的指向，将 bar 中的 this 指向了 foo，第二个是执行了 bar 方法。</p>
<p>接下来我们来模拟 call 方法：</p>
<h4 id="第一步：实现简单的-call-方法："><a href="#第一步：实现简单的-call-方法：" class="headerlink" title="第一步：实现简单的 call 方法："></a>第一步：实现简单的 call 方法：</h4><p>上面的例子可以改造为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar();</span><br></pre></td></tr></table></figure>

<p>输出的结果和上述的一模一样，唯一的不同就是 foo 中多了一个 bar 的属性，那我们执行完后删除这个属性就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  Context.fn();</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo);</span><br></pre></td></tr></table></figure>

<p>结果和 call 一致。</p>
<h4 id="第二步：因为-call-可以带参数，所以我们接下来实现这个"><a href="#第二步：因为-call-可以带参数，所以我们接下来实现这个" class="headerlink" title="第二步：因为 call 可以带参数，所以我们接下来实现这个"></a>第二步：因为 call 可以带参数，所以我们接下来实现这个</h4><p>看一下原版的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(goods); <span class="comment">// 自行车</span></span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="number">10</span>, <span class="string">"自行车"</span>);</span><br></pre></td></tr></table></figure>

<p>因为参数是不固定的，所以可以想到 arguments。怎么将 arguments 传入对象中，这就是个难题，高兴的是 ES6 给了我们方法：解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  Context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(goods); <span class="comment">// 自行车</span></span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo, <span class="number">10</span>, <span class="string">"自行车"</span>);</span><br></pre></td></tr></table></figure>

<p>是不是感觉特别简单，但是 call 是 ES3 的方法，解构赋值是 ES6 的方法，感觉有点欺负它，那我们就需要重新想一个。这个方法也是查看了资料后才找到的，自己能力还是有限啊！<br>可以运用 eval()，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++&gt;) &#123;</span><br><span class="line">    args.push(<span class="string">'arguments[+'</span> i <span class="string">'+]'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'Context.fn(+'</span> args <span class="string">'+)'</span>);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(goods); <span class="comment">// 自行车</span></span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo, <span class="number">10</span>, <span class="string">'自行车'</span>);</span><br></pre></td></tr></table></figure>

<p>感觉很完美了，但是依旧有两小点需要注意：</p>
<ol>
<li>当 this 为 null 时</li>
<li>当函数有返回值时<br>我们先来看第一点：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Jack"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// Jack</span></span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>当 this 为 null 时，默认走向 window<br>第二点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    goods: <span class="string">"自行车"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo); <span class="comment">// &#123;age: 1, goods: "自行车"&#125;</span></span><br></pre></td></tr></table></figure>

<p>当函数有返回值时，结果就是这个返回值。</p>
<h4 id="第三步：我们对自己模拟的方法进行最后的优化："><a href="#第三步：我们对自己模拟的方法进行最后的优化：" class="headerlink" title="第三步：我们对自己模拟的方法进行最后的优化："></a>第三步：我们对自己模拟的方法进行最后的优化：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Context = Context ? Context : <span class="built_in">window</span>;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"Context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、apply"><a href="#2、apply" class="headerlink" title="2、apply"></a>2、apply</h2><p>call() 和 apply() 之间的区别，不同之处是：</p>
<ol>
<li>call() 方法分别接受参数。</li>
<li>apply() 方法接受数组形式的参数。</li>
</ol>
<p>所以 call 和 apply 只是接受参数的不同，思路还是和 call 一样，这次就不重复了直接贴代码：<br>运用解构赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Context = Context ? Context : <span class="built_in">window</span>;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>] ? <span class="built_in">arguments</span>[<span class="number">1</span>] : [];</span><br><span class="line">  <span class="keyword">var</span> result = Context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运用 eval：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Context = Context ? Context : <span class="built_in">window</span>;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="built_in">arguments</span>[<span class="number">1</span>] ? <span class="built_in">arguments</span>[<span class="number">1</span>] : [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"Context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">bar.myApply(foo);</span><br></pre></td></tr></table></figure>

<h2 id="3、bind"><a href="#3、bind" class="headerlink" title="3、bind"></a>3、bind</h2><p>bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind()的第一个参数, 它的参数是 bind()的其他参数和其原本的参数。<br>所以 bind 执行两个步骤：</p>
<ol>
<li>返回一个新函数</li>
<li>可以传入参数</li>
</ol>
<p>我们按照分析 call()函数一样的思路来分析 bind()，首先看一下原先的 bind：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo);</span><br><span class="line">bindFoo(); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>所以可以看出 bar.bind(foo);返回一个新的函数，当这个函数执行时，才返回其中的结果，那我们先模拟一下这个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(Context);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.myBind(foo);</span><br><span class="line">bindFoo(); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>结果一样，说明这一步模拟的没有问题。那我们进行下一步的模拟，因为 bind 也是可以携带参数的，携带参数的方式和 call 相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(goods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="number">1</span>, <span class="string">"1"</span>);</span><br><span class="line">bindFoo(); <span class="comment">// Jack 1 1</span></span><br></pre></td></tr></table></figure>

<p>模拟板升级：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(Context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很完美，但是 bind 有个特点被忽视了，因为 bind 返回一个新的函数，那我们将返回的函数里面传参，会有什么效果，我们看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(goods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="number">1</span>);</span><br><span class="line">bindFoo(<span class="string">"1"</span>); <span class="comment">// Jack 1 1</span></span><br></pre></td></tr></table></figure>

<p>可以看出 bind 可以只传入 age，然后再从返回的新函数中传入 goods，那我们需要把上述模拟进行升级：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(Context, args.concat(bindArgs));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路其实很简单，就是将两个 arguments 进行合并。<br>本以为这样就结束了，但是 MDN 提到了 bind 的另外一个特点：绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。什么意思呢？用代码演示一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(goods);</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.friends = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">var</span> BindFoo = bar.bind(foo, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> bindFoo = <span class="keyword">new</span> BindFoo(<span class="string">"1"</span>); <span class="comment">// undefined 1 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bindFoo.friends); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>this.name 竟然输出 undefined，那是因为 new 后，BindFoo 中 this 的指向改变了，指向了 bindFoo，而 BindFoo 实际是 bar 函数，并且 bindFoo 没有 value 属性，所以就输出了 undefined，通过 instanceof 就可以看出来，bindFoo 是 BindFoo 的实例，也是 bar 的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> cacheFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> bindFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> cacheFn ? <span class="keyword">this</span> : Context,</span><br><span class="line">      args.concat(bindArgs)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  cacheFn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFun.prototype = <span class="keyword">new</span> cacheFn();</span><br><span class="line">  <span class="keyword">return</span> bindFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们进行分步讲解：<br>1、为什么要判断 this instanceof bindFun？<br>之前也说到，当将 bind 返回后函数当做构造函数时，bindFoo 即是 BindFoo 的实例也是 bar 的实例，BindFoo 即为返回来的函数，在我们模拟的代码中就是 bindFun 这个函数，并且当 new 之后 this 指向的是实例，所以用 this instanceof bindFun 判断的实际就是函数前有没有 new 这个关键词。<br>2、为什么要继承 this 的原型？<br>这是为了继承 bar 原型上的属性。<br>最后一步，健壮模拟的 bind，判断传过来的 this 是否为函数，也是最终版：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> cacheFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> bindFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> cacheFn ? <span class="keyword">this</span> : Context,</span><br><span class="line">      args.concat(bindArgs)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  cacheFn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFun.prototype = <span class="keyword">new</span> cacheFn();</span><br><span class="line">  <span class="keyword">return</span> bindFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/javascript/" rel="tag">javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/22/var%E3%80%81let%E5%92%8Cconst/"
                    data-tooltip="var、let和const"
                    aria-label="上一篇: var、let和const"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/12/%E9%97%AD%E5%8C%85/"
                    data-tooltip="闭包"
                    aria-label="下一篇: 闭包"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 TomatoMan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/22/var%E3%80%81let%E5%92%8Cconst/"
                    data-tooltip="var、let和const"
                    aria-label="上一篇: var、let和const"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/12/%E9%97%AD%E5%8C%85/"
                    data-tooltip="闭包"
                    aria-label="下一篇: 闭包"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                        aria-label="分享到 Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/author.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">TomatoMan</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"
                            aria-label=": js基础类型和引用类型"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"
                            aria-label=": js基础类型和引用类型"
                        >
                            <h3 class="media-heading">js基础类型和引用类型</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年4月8日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
                            aria-label=": 类型转换"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"
                            aria-label=": 类型转换"
                        >
                            <h3 class="media-heading">类型转换</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年4月17日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h2 id="1、显示类型转换"><a href="#1、显示类型转换" class="headerlink" title="1、显示类型转换"></a>1、显示类型转换</h2><p>显示类型转换顾名思义就是用特有的方法对类型进行转换<br>显示类型转换的方式只有三种：</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/17/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"
                            aria-label=": 深拷贝和浅拷贝"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/17/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"
                            aria-label=": 深拷贝和浅拷贝"
                        >
                            <h3 class="media-heading">深拷贝和浅拷贝</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年4月17日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。<br>为什么引用数据类型会出现这样的问题？<br>第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。<br>所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"
                            aria-label=": 原型与原型链"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"
                            aria-label=": 原型与原型链"
                        >
                            <h3 class="media-heading">原型与原型链</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年4月20日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h2 id="1、创建对象"><a href="#1、创建对象" class="headerlink" title="1、创建对象"></a>1、创建对象</h2></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/20/%E7%BB%A7%E6%89%BF/"
                            aria-label=": 继承"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/20/%E7%BB%A7%E6%89%BF/"
                            aria-label=": 继承"
                        >
                            <h3 class="media-heading">继承</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年4月20日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>JS 是一门面向对象的语言，面向对象的三个特性：封装、继承、多态。虽然 JS 没有多态，但是继承还是有的，但是 JS 的继承只支持实现继承，实现的方式就是通过原型链。原型链我们上篇已经讲过了，所以本篇主要 JS 中几种继承的方式。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/"
                            aria-label=": new关键词"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/"
                            aria-label=": new关键词"
                        >
                            <h3 class="media-heading">new关键词</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年4月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>大部分面试的时候，面试官先已原型链铺路，随后就会问你 new 关键词都做了些什么？也是为了下一个继承问题再次铺路！<br>那这篇文章我们就来讲讲这个 new！<br>我们通常在什么地方能看到它，在创建实例的时候，new 后面加上一个构造函数，就是创建这个构造函数的实例。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/05/29/%E4%BD%9C%E7%94%A8%E5%9F%9F/"
                            aria-label=": 作用域"
                        >
                            <img class="media-image" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=11468326,3073197074&amp;fm=26&amp;gp=0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/05/29/%E4%BD%9C%E7%94%A8%E5%9F%9F/"
                            aria-label=": 作用域"
                        >
                            <h3 class="media-heading">作用域</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年5月29日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>何为作用域，查找度娘百科中是这么定义的：</p>
<p>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/05/29/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"
                            aria-label=": 执行上下文"
                        >
                            <img class="media-image" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=11468326,3073197074&amp;fm=26&amp;gp=0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/05/29/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"
                            aria-label=": 执行上下文"
                        >
                            <h3 class="media-heading">执行上下文</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年5月29日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>上篇介绍完 JS 的作用域，那接下来的几篇就要讲讲跟作用域相关的内容了。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/06/12/%E9%97%AD%E5%8C%85/"
                            aria-label=": 闭包"
                        >
                            <img class="media-image" src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=11468326,3073197074&amp;fm=26&amp;gp=0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/06/12/%E9%97%AD%E5%8C%85/"
                            aria-label=": 闭包"
                        >
                            <h3 class="media-heading">闭包</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年6月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>根据《高程》中所讲：闭包是指有权访问另一个函数作用域中的变量的函数。<br>《Javascript 权威指南》中指出，从技术角度讲，所有的 javascript 函数都是闭包。<br>闭包，之前感觉很神秘，今天我们来揭开它的面纱，看看究竟干了什么！</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                            aria-label=": call、apply和bind"
                        >
                            <img class="media-image" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1593095782575&amp;di=0f02fa07eb8c80304015e32141a07c1f&amp;imgtype=0&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1919037390%2C2349900337%26fm%3D214%26gp%3D0.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/"
                            aria-label=": call、apply和bind"
                        >
                            <h3 class="media-heading">call、apply和bind</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2020年6月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 16 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-gcbh7npmnxauwybwqqoitmia9ec0wihwvsb9n2qirts6y3uiazx7dlwaanx3.min.js"></script>

<!--SCRIPTS END-->


    



    
<script src="/assets/js/moment-with-locales.js"></script>

    
<script src="/assets/js/algoliasearch.js"></script>

    <script>
      var algoliaClient = algoliasearch('2ILBT3HBZ2', '2f34a1f86e95da45573cd221c686a072');
      var algoliaIndex = algoliaClient.initIndex('my-hexo-blog');
    </script>


    </body>
</html>
