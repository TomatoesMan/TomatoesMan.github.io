{"meta":{"title":"Tomato's blog","subtitle":"","description":"","author":"TomatoMan","url":"https://TomatoesMan.github.io","root":"/"},"pages":[{"title":"文章标签","date":"2020-06-25T05:41:02.000Z","updated":"2020-06-25T06:39:18.640Z","comments":false,"path":"tags/index.html","permalink":"https://tomatoesman.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-25T06:51:50.000Z","updated":"2020-06-25T06:52:47.681Z","comments":false,"path":"about/index.html","permalink":"https://tomatoesman.github.io/about/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-06-25T05:28:40.000Z","updated":"2020-06-25T06:39:02.161Z","comments":false,"path":"categories/index.html","permalink":"https://tomatoesman.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"var、let和const","slug":"var、let和const","date":"2020-06-22T14:35:21.000Z","updated":"2020-06-25T08:35:40.678Z","comments":true,"path":"2020/06/22/var、let和const/","link":"","permalink":"https://tomatoesman.github.io/2020/06/22/var%E3%80%81let%E5%92%8Cconst/","excerpt":"","text":"1、var在没出现 let 和 const 之前，我们定义变量只能用 var。但是用 var 定义变量通常有很多的问题，就是我们常说的变量提升，例如： 1234if (false) &#123; var a = 1;&#125;console.log(a); 如果初学者第一次看这段代码的时候，肯定会觉得段代码会报错，因为 if 中的条件是 false，并没有执行 var a = 1，所以最后应该报 a 没有定义的错误，但是实际最后却输出了 undefined，这就是变量提升。什么是变量提升：MDN 是这么说的：变量提升（Hoisting）被认为是， Javascript 中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。在 ECMAScript® 2015 Language Specification 之前的 JavaScript 文档中找不到变量提升（Hoisting）这个词。不过，需要注意的是，开始时，这个概念可能比较难理解，甚至恼人。这就没了？对这就没了！当看到的时候同样有这个疑问，所以我在var 描述中找到了这么一句话：变量声明，无论发生在何处，都在执行任何代码之前进行处理。所以以上代码可以被翻译成这样： 12345var a;if (false) &#123; a = 1;&#125;console.log(a); 2、let我们先看一下 let 的几大特性： 1、没有声明提升我们通过代码来看一下： 1234if (false) &#123; let a = 1;&#125;console.log(a); 欣喜若狂终于得到了我们想要的结果，报错，a 没有被定义。 2、重复声明报错12var a = 1;let a = 2; 哇塞，报错了，显示 a 已经被定义过了，这简直是太友好了，终于不会一不小心就改变了全局变量，也终于避免了重复命名的危险。 3、不绑定全局作用域12let a = 1;console.log(window.a); // undefined 根本没有定义到全局上，主要还是因为 let 是块级作用域不是全局作用域。 3、const在开发中 const 我们一般是来定义常量，即不可更改的量，它的基本特性和 let 是差不多的。 12const a = 1;a = 3; 执行上述代码时，会报错，因为 const 定义的是常量，无法进行修改。但是当 const 定义的是引用数据类型时： 12345const a = &#123; value: 1,&#125;;a.value = 2;console.log(a); // &#123;value: 2&#125; 感觉有些打脸，但确实如此，这是因为 const 定义的实际是引用地址，它判断是的引用地址是否发生变化，虽然改变了引用数据中的数据，但是它的引用地址并没有发生变化，所以就可以更改，但是这种方式还是不提倡的。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"call、apply和bind","slug":"call、apply和bind","date":"2020-06-18T15:03:59.000Z","updated":"2020-06-25T08:11:07.602Z","comments":true,"path":"2020/06/18/call、apply和bind/","link":"","permalink":"https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/","excerpt":"call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。","text":"call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。 1、callW3school中对 call()方法的定义是：它可以用来调用所有者对象作为参数的方法。通过 call()，能够使用属于另一个对象的方法。我们举个例子： 1234567var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;bar.call(foo); 由上可以看出 call()函数主要做了两件事，第一个是改变 this 的指向，将 bar 中的 this 指向了 foo，第二个是执行了 bar 方法。 接下来我们来模拟 call 方法： 第一步：实现简单的 call 方法：上面的例子可以改造为： 1234567var foo = &#123; name: \"Jack\", bar: function () &#123; console.log(this.name); &#125;,&#125;;foo.bar(); 输出的结果和上述的一模一样，唯一的不同就是 foo 中多了一个 bar 的属性，那我们执行完后删除这个属性就可以了。 123456789101112Function.prototype.myCall = function (Context) &#123; Context.fn = this; // 此时的this指向的是Function，即调用者 Context.fn(); delete Context.fn;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;bar.myCall(foo); 结果和 call 一致。 第二步：因为 call 可以带参数，所以我们接下来实现这个看一下原版的： 123456789var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); // 10 console.log(goods); // 自行车&#125;bar.call(foo, 10, \"自行车\"); 因为参数是不固定的，所以可以想到 arguments。怎么将 arguments 传入对象中，这就是个难题，高兴的是 ES6 给了我们方法：解构赋值 123456789101112131415Function.prototype.myCall = function (Context) &#123; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = [...arguments].slice(1); Context.fn(...args); delete Context.fn;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); // 10 console.log(goods); // 自行车&#125;bar.myCall(foo, 10, \"自行车\"); 是不是感觉特别简单，但是 call 是 ES3 的方法，解构赋值是 ES6 的方法，感觉有点欺负它，那我们就需要重新想一个。这个方法也是查看了资料后才找到的，自己能力还是有限啊！可以运用 eval()，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 123456789101112131415161718Function.prototype.myCall = function(Context) &#123; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = []; for (var i = 1; i &lt; arguments.length; i++&gt;) &#123; args.push('arguments[+' i '+]'); &#125; eval('Context.fn(+' args '+)'); delete Context.fn;&#125;var foo = &#123; name: 'Jack'&#125;function bar(age, goods) &#123; console.log(this.name); console.log(age); // 10 console.log(goods); // 自行车&#125;bar.myCall(foo, 10, '自行车'); 感觉很完美了，但是依旧有两小点需要注意： 当 this 为 null 时 当函数有返回值时我们先来看第一点： 12345var name = \"Jack\";function bar() &#123; console.log(this.name); // Jack&#125;bar.call(null); 当 this 为 null 时，默认走向 window第二点： 12345678910var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; return &#123; age: 1, goods: \"自行车\", &#125;;&#125;bar.call(foo); // &#123;age: 1, goods: \"自行车\"&#125; 当函数有返回值时，结果就是这个返回值。 第三步：我们对自己模拟的方法进行最后的优化：1234567891011Function.prototype.myCall = function (Context) &#123; var Context = Context ? Context : window; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; var result = eval(\"Context.fn(\" + args + \")\"); delete Context.fn; return result;&#125;; 2、applycall() 和 apply() 之间的区别，不同之处是： call() 方法分别接受参数。 apply() 方法接受数组形式的参数。 所以 call 和 apply 只是接受参数的不同，思路还是和 call 一样，这次就不重复了直接贴代码：运用解构赋值： 12345678Function.prototype.myApply = function (Context) &#123; var Context = Context ? Context : window; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = arguments[1] ? arguments[1] : []; var result = Context.fn(...args); delete Context.fn; return result;&#125;; 运用 eval： 12345678910111213141516171819Function.prototype.myApply = function (Context) &#123; var Context = Context ? Context : window; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = []; var arguments = arguments[1] ? arguments[1] : []; for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; var result = eval(\"Context.fn(\" + args + \")\"); delete Context.fn; return result;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;bar.myApply(foo); 3、bindbind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind()的第一个参数, 它的参数是 bind()的其他参数和其原本的参数。所以 bind 执行两个步骤： 返回一个新函数 可以传入参数 我们按照分析 call()函数一样的思路来分析 bind()，首先看一下原先的 bind： 12345678var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;var bindFoo = bar.bind(foo);bindFoo(); // Jack 所以可以看出 bar.bind(foo);返回一个新的函数，当这个函数执行时，才返回其中的结果，那我们先模拟一下这个： 1234567891011121314Function.prototype.myBind = function (Context) &#123; var self = this; return function () &#123; return self.apply(Context); &#125;;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;var bindFoo = bar.myBind(foo);bindFoo(); // Jack 结果一样，说明这一步模拟的没有问题。那我们进行下一步的模拟，因为 bind 也是可以携带参数的，携带参数的方式和 call 相同： 12345678910var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); console.log(goods);&#125;var bindFoo = bar.bind(foo, 1, \"1\");bindFoo(); // Jack 1 1 模拟板升级： 1234567Function.prototype.myBind = function (Context) &#123; var self = this; var args = [].slice.call(arguments, 1); return function () &#123; return self.apply(Context, args); &#125;;&#125;; 很完美，但是 bind 有个特点被忽视了，因为 bind 返回一个新的函数，那我们将返回的函数里面传参，会有什么效果，我们看一下： 12345678910var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); console.log(goods);&#125;var bindFoo = bar.bind(foo, 1);bindFoo(\"1\"); // Jack 1 1 可以看出 bind 可以只传入 age，然后再从返回的新函数中传入 goods，那我们需要把上述模拟进行升级： 12345678Function.prototype.myBind = function (Context) &#123; var self = this; var args = [].slice.call(arguments, 1); return function () &#123; var bindArgs = [].slice.call(arguments); return self.apply(Context, args.concat(bindArgs)); &#125;;&#125;; 思路其实很简单，就是将两个 arguments 进行合并。本以为这样就结束了，但是 MDN 提到了 bind 的另外一个特点：绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。什么意思呢？用代码演示一下： 123456789101112var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); console.log(goods);&#125;bar.prototype.friends = \"a\";var BindFoo = bar.bind(foo, 1);var bindFoo = new BindFoo(\"1\"); // undefined 1 1console.log(bindFoo.friends); // a this.name 竟然输出 undefined，那是因为 new 后，BindFoo 中 this 的指向改变了，指向了 bindFoo，而 BindFoo 实际是 bar 函数，并且 bindFoo 没有 value 属性，所以就输出了 undefined，通过 instanceof 就可以看出来，bindFoo 是 BindFoo 的实例，也是 bar 的实例。 123456789101112131415Function.prototype.myBind = function (Context) &#123; var self = this; var args = [].slice.call(arguments, 1); var cacheFn = function () &#123;&#125;; var bindFun = function () &#123; var bindArgs = [].slice.call(arguments); return self.apply( this instanceof cacheFn ? this : Context, args.concat(bindArgs) ); &#125;; cacheFn.prototype = this.prototype; bindFun.prototype = new cacheFn(); return bindFun;&#125;; 我们进行分步讲解：1、为什么要判断 this instanceof bindFun？之前也说到，当将 bind 返回后函数当做构造函数时，bindFoo 即是 BindFoo 的实例也是 bar 的实例，BindFoo 即为返回来的函数，在我们模拟的代码中就是 bindFun 这个函数，并且当 new 之后 this 指向的是实例，所以用 this instanceof bindFun 判断的实际就是函数前有没有 new 这个关键词。2、为什么要继承 this 的原型？这是为了继承 bar 原型上的属性。最后一步，健壮模拟的 bind，判断传过来的 this 是否为函数，也是最终版： 1234567891011121314151617181920Function.prototype.myBind = function (Context) &#123; if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; var self = this; var args = [].slice.call(arguments, 1); var cacheFn = function () &#123;&#125;; var bindFun = function () &#123; var bindArgs = [].slice.call(arguments); return self.apply( this instanceof cacheFn ? this : Context, args.concat(bindArgs) ); &#125;; cacheFn.prototype = this.prototype; bindFun.prototype = new cacheFn(); return bindFun;&#125;;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"闭包","slug":"闭包","date":"2020-06-12T12:54:24.000Z","updated":"2020-06-25T08:06:05.267Z","comments":true,"path":"2020/06/12/闭包/","link":"","permalink":"https://tomatoesman.github.io/2020/06/12/%E9%97%AD%E5%8C%85/","excerpt":"根据《高程》中所讲：闭包是指有权访问另一个函数作用域中的变量的函数。《Javascript 权威指南》中指出，从技术角度讲，所有的 javascript 函数都是闭包。闭包，之前感觉很神秘，今天我们来揭开它的面纱，看看究竟干了什么！","text":"根据《高程》中所讲：闭包是指有权访问另一个函数作用域中的变量的函数。《Javascript 权威指南》中指出，从技术角度讲，所有的 javascript 函数都是闭包。闭包，之前感觉很神秘，今天我们来揭开它的面纱，看看究竟干了什么！ 我们举个例子： 12345678function scope() &#123; let a = 1; return function () &#123; return a; &#125;;&#125;let foo = scope();foo(); 根据前面所写的《执行上下文》中我们可以找到当解析代码时，会执行上下文栈，那我们按照执行上下文来看一下函数内部都做了哪些事情。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var scope = [];scope.push(globalContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; scope: &lt;func&gt;, foo: &lt;uninitialized&gt;, &#125;, outer: null &#125;, VR: &#123; ER: &#123;&#125;, outer: null &#125;&#125;);scope.push(&lt;scope&gt;, scopefunctionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; arguments: &#123; length: 0 &#125; &#125;, outer: &lt;globalContext&gt; &#125;, VR: &#123; ER: &#123;&#125;, outer: null &#125;&#125;);scope.pop();scope.push(&lt;foo&gt;, foofunctionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; arguments: &#123; length: 0 &#125; &#125;, outer: &lt;scopefunctionContext&gt; &#125;, VR: &#123; ER: &#123;&#125;, outer: null &#125;&#125;);scope.pop(); 其实会很好奇，scope 函数执行完后明明已经在执行栈中移除了，为什么 foo 函数依旧能访问到其内部的变量。是因为 foo 函数的对外部引用是 scope 的词法环境，这个环境还没有消失。正因为 JS 有这个特点，所以才会生成闭包这个概念。 下面举几个常用的面试题，来自《高程》： 123456789101112function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; console.log(i); &#125;; &#125; return result;&#125;createFunctions().forEach((item) =&gt; &#123; item();&#125;); 运行上述之后，发现最后输出 10 个 10，为什么不是 0-9 呢？我们来分析一下，已 result[0]为例，在 result[0]运行之前，全局上下文是这样的： 1234567891011121314151617var scope = [];scope.push(globalContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; createFunctions: &lt;func&gt;, &#125;, outer: null &#125;, VR: &#123; ER: &#123; result: [....], i: 10 &#125;, outer: null &#125;&#125;) 当 result[0]运行时，它的函数上下文发生变化： 1234567891011functionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123;&#125;, outer: &lt;createFunctionsContext&gt; &#125;, VR: &#123; ER: &#123;&#125;, outer: &lt;createFunctionsContext&gt; &#125;&#125; 由于 result[0]中没有定义 i，所以就会向外部的词法环境中查找，最后找到 i，输出 10。 如果想输出预期结果 0-9，高程中也给出了解决方案： 1234567891011121314function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = (function (num) &#123; return function () &#123; console.log(num); &#125;; &#125;)(i); &#125; return result;&#125;createFunctions().forEach((item) =&gt; &#123; item();&#125;); 当再次执行 result[0]时，这个匿名函数的上下文： 12345678910111213141516171819functionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; 匿名function: &lt;func&gt; &#125;, outer: &lt;createFunctionsContext&gt; &#125;, VR: &#123; ER: &#123; arguments: &#123; 0: 0, length: 1 &#125;, num: 0 &#125;, outer: &lt;createFunctionsContext&gt; &#125;&#125; 当匿名函数执行时： 12345678910111213141516匿名functionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123;&#125;, outer: &lt;functionContext&gt; &#125;, VR: &#123; ER: &#123; arguments: &#123; length: 0 &#125;, num: 0 &#125;, outer: &lt;functionContext&gt; &#125;&#125; 同样其内部没有 num 变量，那它就会去外部的此法环境中查找，找到了 functionContext，functionContext 内部的 num 为 0，则输出 0。这样就完美解决了这个问题，也体现了闭包的作用，但现在有 let 了这种就用的很少了。闭包虽然能解决一些问题，但是尽量还是要少用闭包，因为其外部的词法环境已经销毁了，但其内部还在引用，这样的话闭包过多会造成内存泄漏，最简单直接的办法就是，执行完后设置为 null，这样就销毁了。","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"执行上下文","slug":"执行上下文","date":"2020-05-29T14:36:39.000Z","updated":"2020-06-25T08:10:05.367Z","comments":true,"path":"2020/05/29/执行上下文/","link":"","permalink":"https://tomatoesman.github.io/2020/05/29/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"上篇介绍完 JS 的作用域，那接下来的几篇就要讲讲跟作用域相关的内容了。","text":"上篇介绍完 JS 的作用域，那接下来的几篇就要讲讲跟作用域相关的内容了。 1、执行上下文执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文类型阅文前端团队翻译的《理解 Javascript 执行上下文和执行栈》中所说： 全局执行上下文：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。 eval 函数执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文。 2、执行上下文栈执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文，这与堆栈中栈的原理类似。 当 JS 引擎开始编译 JS 代码时，会创建一个全局执行上下文压入到执行上下文栈的最顶层，当调用一个函数时，就会创建一个函数执行上下文压入执行上下文栈的最顶层。 当最新的函数执行完毕后，其执行上下文将会从执行上下文栈弹出，然后将执行下一个函数。 我们可以将执行上下文栈模拟为一个空数组： 1stack = []; 通过下个例子来理解一下： 1234567891011121314var a = 1;function foo1() &#123; console.log(a);&#125;function foo2() &#123; foo1();&#125;function foo3() &#123; foo2();&#125;foo3(); 当执行上述例子时，先将全局执行上下文推入执行上下文栈 1stack = [globalContext]; 当函数调用的时候开始执行函数上下文： 123456789101112stack.push(&lt;foo3&gt;, functionContext);// foo3函数中调用了foo2stack.push(&lt;foo2&gt;, functionContext);// foo2函数中调用了foo1stack.push(&lt;foo1&gt;, functionContext);// foo1执行完毕stack.pop();// foo2执行完毕stack.pop();// foo1执行完毕stack.pop();// 之后再执行新的代码，但底层永远留有一个globalContext 3、执行上下文的创建在执行上下文创建的时候，分为两个阶段：1、创建阶段 2、执行阶段 3.1、创建阶段创建阶段有三个重要的属性： this 词法环境（作用域链） 变量环境 3.1.1、this在全局上下文中，this 指向的是全局对象，在浏览器中，指向的是 window在函数上下文中，this 指向的是函数的调用方，如果是对象调用该函数，则指向的是这个对象，否则 this 指向的是全局对象或者 undefined（严格模式） 123456789101112let person = &#123; name: \"Jack\", eat: function () &#123; console.log(this.name); &#125;,&#125;;person.eat(); // 此时的this指向person，因为是person调用的该函数function foo() &#123; console.log(this);&#125;foo(); // 此时的this指向window 3.1.2、词法环境（作用域链）词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用） 词法环境包括两个部分： 环境记录：存储变量和函数声明的实际位置 对外部环境的引用：意味着可以访问其外部的词法变量 在全局上下文中，对外环境的引用为 null，它拥有一个全局的对象（windowd 对象）以及其关联的属性和方法和用户自定义的全局变量。 在函数上下文中，用户自定义的变量存储在环境记录中，对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。另外在函数上下文创建时，在其环境记录中还会生成一个 arguments 对象，该对象包含了索引和传递给函数的参数之间的映射以及传递给函数的参数的长度（数量）。如下所示： 123456function add(a, b) &#123; return a + b;&#125;add(2, 3);// arguments对象Arguments: &#123;0: 2, 1: 3, length: 2&#125; 我们以一个例子，并用伪代码来看一下在词法环境中 JS 内部都做了什么： 123456var a, b = 1;function foo(a, b) &#123; return a + b;&#125;foo(2, 3); 我们用 ER 代表环境记录，用 outer 代表对外部环境的引用，伪代码写成： 1234567891011121314151617181920全局上下文：GlobalExectionContext = &#123; ER: &#123; a, b, foo &#125;, outer: null&#125;当运行函数时，会产生函数上下文：FunctionExectionContext = &#123; ER: &#123; arguments: &#123; 0: 2, 1: 3, length: 2 &#125; &#125;, outer: &lt;GlobalExectionContext&gt;&#125; 在 ES8 中规定环境记录同样拥有两个类型： 声明性环境记录：存储变量、函数和参数。一个函数环境包含声明性环境记录。 对象环境记录：用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。 3.1.3、变量环境变量环境也是一个词法环境，所以他包含了词法环境的所有特性，在 ES6 中变量环境包括两个一个是 LexicalEnvironment 组件另一个是 VariableEnvironment 组件，他俩的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。 这样我们再举例来看一下 JS 内部究竟干了什么： 1234567let a = 1;const b = 2;var c;function add(a, b) &#123; return a + b;&#125;c = add(1, 3); 我们同样用伪代码来模拟一下吗，用 LE 代表 LexicalEnvironment，用 VE 代表 VariableEnvironment： 123456789101112131415161718192021222324252627282930313233343536全局上下文：GlobalExectionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; a: &lt;uninitialized&gt;, b: &lt;uninitialized&gt;, add: &lt;func&gt; &#125;, outer: null, &#125;, VE: &#123; ER: &#123; c: undefined &#125;, outer: null, &#125;&#125;当调用add时，生成函数上下文：FunctionExectionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; arguments: &#123; 0: 1, 1: 3, length: 2 &#125; &#125;, outer: &lt;GlobalExectionContext&gt;, &#125;, VE: &#123; ER: null, outer: &lt;GlobalExectionContext&gt;, &#125;&#125; 此时你一定会对 let、const、var 的值有一个疑惑，那是因为在创建阶段的时候，代码会被扫描和解析成变量和函数声明，函数声明存储在环境中，而 var 会被定义为 undefined，let 和 const 会被定位为 uninitialized，这就是为什么你可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因，这个错误就是暂时性死区或者叫做临时死亡（TDZ），原因就是在访问一个已经声明但没有初始化的变量。 3.2、执行阶段在此阶段，完成对所有变量的分配，最后执行代码。注：在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。 这篇查阅了很多相关资料，但是觉得很多还是理解的不是很透彻，今后有时间会继续补充，也希望大家能多给些评价。 参考：【译】理解 Javascript 执行上下文和执行栈","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"作用域","slug":"作用域","date":"2020-05-29T14:14:37.000Z","updated":"2020-06-25T08:10:36.298Z","comments":true,"path":"2020/05/29/作用域/","link":"","permalink":"https://tomatoesman.github.io/2020/05/29/%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"何为作用域，查找度娘百科中是这么定义的： 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。","text":"何为作用域，查找度娘百科中是这么定义的： 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 1、静态作用域（词法作用域）通常来说 JS 是静态作用域，函数的作用域在函数定义的时候就已经确定了。可以举个例子： 123456789var scope = 1;function foo() &#123; console.log(scope);&#125;function bar() &#123; var scope = 2; foo();&#125;bar(); 最后输出为 1，因为 JS 是静态作用域，所以 foo 函数的作用域在其定义的时候就被确定了，当在 bar 函数中执行 foo()时，没有去查找 bar 中的 scope 变量，而是去查找 foo 函数中的 scope，当 foo 函数中没有找到这个变量的时候他会在全局中查找，所以最后输出 1。 2、动态作用域函数的作用域在函数调用的时候才决定。其实大部分的语言都是基于静态作用域的，如果 JS 是动态作用域的话，那上述例子最后的结果应该是 2 而不是 1，因为当 foo()无法找到 scope 的变量引用时，会顺着调用栈在调用 foo()的地方查找 scope，而不是在嵌套的词法作用域链中向上查找。由于 foo()是在 bar()中调用的，引擎会检查 bar()的作用域，并在其中找到值为 2 的变量 scope。看到这里有没有感觉到这个动态作用域的工作原理像极了 JS 中的 this，关于 this 的机制我们将在后续中进行讲解。 3、JS 的全局作用域、块级作用域、函数作用域3.1 全局作用域在 ES6 之前，JS 只有全局作用域和函数作用域，但是当全局作用域用的过多时就会发现一个大问题，就是全局污染，为了这个解决这个问题推出了好多方法：模块化、闭包、命名空间等等等等。什么是全局作用域？全局作用域即贯穿整个 JS 文档，在任何地方都能够访问到，JS 中有个全局对象 window，如声明一个全局变量，就相当于在 window 上添加一个属性。 3.2 块级作用域块级作用域是 ES6 中才出现的新特性，通常使用的 let、const 都是显式声明块级作用域的方法。在《你不知道的 JavaScript》中对块级作用域的总结是这样的：块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。其实我认为通俗的理解就是，在代码块中定义的变量或者函数，在其代码块外无法访问。 3.3 函数作用域函数作用域即定义在函数代码块中的变量和函数，外部无法访问。举个栗子： 1234567var a = 1;function foo() &#123; var a = 2; console.log(a);&#125;foo();console.log(a); 运行上述结果可以的出结论，foo 函数运行完后在 foo 函数中输出的为 2，在全局上输出的为 1。但是这样并不是很理想，因为 foo 函数是挂载在全局中的，也会容易造成一个全局污染的问题，其次必须显式调用(foo())才能运行函数代码，还好 JS 给我们提供了一个解决这种问题的方法，即自执行函数。可以通过自执行函数将上面的例子进行改造： 1234567var a = 1;(function foo() &#123; var a = 2; console.log(a);&#125;)();console.log(a);console.log(foo); // Uncaught ReferenceError: foo is not defined 执行结果与之前相同，当查看 foo 函数时会报 foo 没有被定义的错误。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"new关键词","slug":"new关键词","date":"2020-04-21T14:05:33.000Z","updated":"2020-06-25T08:04:55.549Z","comments":true,"path":"2020/04/21/new关键词/","link":"","permalink":"https://tomatoesman.github.io/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/","excerpt":"大部分面试的时候，面试官先已原型链铺路，随后就会问你 new 关键词都做了些什么？也是为了下一个继承问题再次铺路！那这篇文章我们就来讲讲这个 new！我们通常在什么地方能看到它，在创建实例的时候，new 后面加上一个构造函数，就是创建这个构造函数的实例。","text":"大部分面试的时候，面试官先已原型链铺路，随后就会问你 new 关键词都做了些什么？也是为了下一个继承问题再次铺路！那这篇文章我们就来讲讲这个 new！我们通常在什么地方能看到它，在创建实例的时候，new 后面加上一个构造函数，就是创建这个构造函数的实例。 首先我们创建一个构造函数，看看 new 都做了哪些事情： 1234567891011function Person() &#123; this.name = \"Jack\"; this.age = \"29\";&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = new Person();console.log(person.name); //Jackconsole.log(person.age); // 29person.eat(); // 烤鸭 我们从上述可以看出，new 关键词主要做了以下几个事情： 创建了一个新的对象， 将新对象的__proto__函数指向构造函数的 prototype，这个新对象就可以访问构造函数原型上的属性 将 this 指向改变，指向新的对象，这样就可以访问构造函数内部的属性 返回新的对象 接下来来模拟一下 new 函数： 1234567function MyNew() &#123; let obj = new Object(); Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125; 我们来验证一下写的这个方法是否正确： 1234567891011function Person() &#123; this.name = \"Jack\"; this.age = \"29\";&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = MyNew(Person);console.log(person.name); //Jackconsole.log(person.age); // 29person.eat(); // 烤鸭 输出结果一样，那忽然有个想法，构造函数毕竟是个函数，如果构造函数有返回值，那 new 后结果是怎样呢： 12345678910111213141516171819202122232425262728293031// 返回基本数据类型function Person() &#123; this.name = \"Jack\"; this.age = \"29\"; return 1;&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = new Person();console.log(person.name); //Jackconsole.log(person.age); // 29person.eat(); // 烤鸭// 返回对象function Person() &#123; this.name = \"Jack\"; this.age = \"29\"; return &#123; sex: \"nan\", like: \"nv\", &#125;;&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = new Person();console.log(person.name); //undefinedconsole.log(person.age); // undefinedconsole.log(person.sex); //Jackconsole.log(person.like); // 29person.eat(); // Uncaught TypeError: person.eat is not a function 当构造函数返回的是一个基本数据类型时，跟没有返回值是一样的结果，但是当返回值是一个对象时，就会真的返回这个对象，return 之前定义的属性都会失效，并且定义在原型上的属性也会失效。根据这个特性，对之前写的 MyNew 函数进行升级。 1234567function MyNew() &#123; let obj = new Object(); Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; let res = Constructor.apply(obj, arguments); return typeof res === \"object\" ? res : obj;&#125;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"继承","slug":"继承","date":"2020-04-20T02:18:58.000Z","updated":"2020-06-25T08:07:37.407Z","comments":true,"path":"2020/04/20/继承/","link":"","permalink":"https://tomatoesman.github.io/2020/04/20/%E7%BB%A7%E6%89%BF/","excerpt":"JS 是一门面向对象的语言，面向对象的三个特性：封装、继承、多态。虽然 JS 没有多态，但是继承还是有的，但是 JS 的继承只支持实现继承，实现的方式就是通过原型链。原型链我们上篇已经讲过了，所以本篇主要 JS 中几种继承的方式。","text":"JS 是一门面向对象的语言，面向对象的三个特性：封装、继承、多态。虽然 JS 没有多态，但是继承还是有的，但是 JS 的继承只支持实现继承，实现的方式就是通过原型链。原型链我们上篇已经讲过了，所以本篇主要 JS 中几种继承的方式。 1、借用构造函数实现继承这种继承方法最原始的继承，实现的非常简单就是在子类型构造函数的内部实现超类型的构造函数。可以通过 call 和 apply 来实现。 12345678910function Father() &#123; this.money = \"$1\";&#125;function Son() &#123; Father.call(this);&#125;var son1 = new Son();console.log(son1.money); // $1var son2 = new Son();console.log(son2.money); // $1 上述可见，这完全实现了继承，儿子继承了老子的钱，虽然只有 1 美元，但也是爱啊！ 但是这样有一个问题，我们来看一下： 123456789101112function Father() &#123; this.money = \"$1\";&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;var son1 = new Son();console.log(son1.money); // $1son1.makeMoney(); //Uncaught TypeError: son1.makeMoney is not a function 发现了吧，这是一个大问题啊，虽然儿子继承了老子的钱，但是没有继承老子的赚钱的能力，虽然 1 美元是一笔大款，但是没有赚钱的能力，早晚也会花光的啊！这是因为方法都在构造函数中定义，因此函数复用就无从谈起了，而且在父类的原型上定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因为这个问题，借助构造函数的技术通常都不是单独使用的。那如何实现继承父类原型上的方法呢？这就要讲到另外一个实现继承的方式了，用原型链继承。 2、原型链实现继承原型链在 JS 中是一种特殊的存在，那如何实现在原型链上的继承呢？是否想到了 new 这个关键词？new 干了哪些事情呢？这是一个经典面试题，简单的说是： 创建一个新对象 将新对象的__proto__指向构造函数的 prototype 对象 将构造函数的作用域赋值给新对象 （也就是 this 指向新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新的对象 第二条就能满足咱们的要求。所以继承父类原型链上的方法我们可以这样写： 1234567891011function Father() &#123; this.money = \"$1\";&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123;&#125;Son.prototype = new Father();var son1 = new Son(); // $1console.log(son1.money);son1.makeMoney(); // 努力工作 简直完美啊，儿子即继承了 1 美元又继承了努力赚钱的方法。但是好像忽略了一点，这个父亲好像有两个儿子，现在这个父亲不止只有钱还有很多东西，那我们将它们写成一个数组，此时小儿子偷摸的想要老父亲的自行车，老父亲允许了，让他自己拿于是： 123456789101112131415function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123;&#125;Son.prototype = new Father();var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // [\"$1\", \"手电筒\", \"冰箱\", \"自行车\"]son1.makeMoney(); // 努力工作console.log(son2.goods); // [\"$1\", \"手电筒\", \"冰箱\", \"自行车\"]son2.makeMoney(); // 努力工作 貌似有些尴尬，因为小儿子继承自行车这个事情一下子就被大儿子发现了。这是因为包含引用类型值的原型属性会被所有实例共享。这也是为什么要使用构造函数来定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个原型的实例，于是原先的实例属性也就变成了现在的原型属性。 以这个例子来说，父类的 goods 是个数组（引用数据类型），每个父类的实例都会有一个 goods 的属性，在子类通过原型链继承了父类的原型时，子类的原型就是父类的实例，那么每个子类也同样拥有了 goods 这个原型属性，就相当于在 son.prototype.goods 一样，但是由于包含引用类型的原型属性会被所有实例共享，所以当 son1 对 goods 进行修改时，son2 也会被修改。 3、组合继承组合继承就是把构造函数继承和原型链继承组合在一起，结合两者的长处。 1234567891011121314151617function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = new Father();var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // ['$1', '手电筒', '冰箱']son1.makeMoney(); // 努力工作console.log(son2.goods); // ['$1', '手电筒', '冰箱', '自行车']son2.makeMoney(); // 努力工作 终于满足了小儿子独自继承自行车的梦想。 4、组合继承的优化组合继承是 JS 中最经典的继承方式，但是上述中还有些许的缺点，会发现在创建一个子类型的实例时，会创建两次父类的实例，接下来就对这一点进行优化。上述借用原型链继承中，应用 new 关键词的目的，就是希望把父类的原型赋值给子类，那可以直接将父类的原型赋值过去，优化 1 如下： 1234567891011121314151617function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = Father.prototype;var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // ['$1', '手电筒', '冰箱']son1.makeMoney(); // 努力工作console.log(son2.goods); // ['$1', '手电筒', '冰箱', '自行车']son2.makeMoney(); // 努力工作 结果没有任何问题，也解决了调用两次父类实例的问题，但是： 1234son1.constructorƒ Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125; 子类虽然是继承父类的，但是它的实例也是一个个体啊，儿子 1 和儿子 2 都是儿子啊，怎么一下子成为老子了，这肯定不行。所以我们再次优化，优化 2： 123456789101112131415161718function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = Object.create(Father.prototype);Son.prototype.constuctor = Son;var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // ['$1', '手电筒', '冰箱']son1.makeMoney(); // 努力工作console.log(son2.goods); // ['$1', '手电筒', '冰箱', '自行车']son2.makeMoney(); // 努力工作 这样才算是真正优化完成。 5、原型式继承本来觉得写到上一条的时候就结束了，但是看到了《高程》里对继承的讲述，还有 ES6 继承特性的底层实现原理，觉得还是有必要好好的了解这一块的知识。 如高程所讲，提出这种继承方式的人叫道格拉斯·克罗克福德，他在 2006 年写了一篇名为《Prototypal Inheritance in Javascript》（Javascript 中原型式继承），在此书中他实现了一种新型的继承方式，这个继承方式没有使用严格意义上的构造函数，而是建造一个基准的对象，通过原型将已有的基准对象再创建一个新的对象，同时还不必因此创建自定义类型，为了实现这个目的，他创建了如下函数： 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 他在里面创建了一个临时的构造函数，然后将传入的对象赋值给这个临时构造函数的原型，最后返回这个临时构造函数的新实例。看下面这个例子： 12345678var father = &#123; money: \"$1\", goods: [\"手电筒\", \"冰箱\"],&#125;;var son1 = object(father);var son2 = object(father);son2.goods.push(\"自行车\");console.log(father.goods); // ['手电筒', '冰箱', 'John', '自行车'] 毕竟是通过原型继承，所以终究还是会有原型继承应有的问题，引用类型的属性会被共享，但是有没有感觉这个方法和 Object.create()很像，没错 object.create()就是基于这个方法建立的。 12345678var father = &#123; money: \"$1\", goods: [\"手电筒\", \"冰箱\"],&#125;;var son1 = Object.create(father);var son2 = Object.create(father);son2.goods.push(\"自行车\");console.log(father.friends); // ['手电筒', '冰箱', 'John', '自行车'] 但 Object.create()不同的是，它还有第二个参数，第二个参数是可选值，设置第二个参数时，可以指定任何属性都会覆盖原型上的同名属性。 6、寄生式继承这种继承方式同样是道格拉斯·克罗克福德提出的，有些类似于借用构造函数继承，但是同样的他利用了一个临时构造函数的思想，即所说的寄生思想，将一个对象作为基准，然后寄生在这个对象上，这样就可以拥有这个对象的所有属性和方法，封装成一个函数，在函数内部给这个对象的副本添加新的属性和方法。 1234567function createAnother(o) &#123; var clone = object(o); clone.sayHi = function () &#123; console.log(\"hi\"); &#125;; return clone;&#125; 但是这种呢，无法做到函数的复用大大降低效率。 7、寄生组合式继承前面提到的组合继承时最经典的继承方式，但是有个很重要的问题，会执行两次父类的构造函数。没事我们可以用寄生组合式继承来解决这个问题。 我们引用《高程》对寄生组合式继承解释：即通过借用构造函数来继承属性，通过原型链的混用形式来继承方法。其背后的思路是：不必为了子类型的原型而调用超类型的构造函数，我们所需要的的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。如下所示： 12345function inheritPrototype(father, son) &#123; var prototype = object(father.prototype); prototype.constructor = son; son.prototype = prototype;&#125; 这个示例实现了最简单的寄生组合式继承。它接受了两个参数，分别是父类的构造函数和子类的构造函数。在函数内部第一步是创建一个父类型原型副本，第二步是将新的副本添加 constructor，弥补因重构原型而失去的默认 constuctor 属性，第三步是将新的副本赋值给子类型的原型上。 这样我们就可以保证只执行一次父类的构造函数。 12345678910function Father() &#123; this.money = \"$1\";&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;inheritPrototype(Father, Son); 8、ES6 的继承 class…extends…以前说到继承的时候只是觉得是个语法糖，用起来很是方便，但是通过写这篇文章查阅资料时看到了其底层实现的原理。这也是写了原型式继承、寄生继承、寄生组合式继承的原因。 我们先来看一下 ES6 继承： 123456789101112131415class Father &#123; constructor() &#123; this.money = \"$1\"; this.goods = [\"手电筒\", \"冰箱\"]; &#125; makeMoney = function () &#123; console.log(\"努力工作\"); &#125;;&#125;class Son extends Father &#123; constructor() &#123; super(); &#125;&#125; 用 Bable 转成 ES5 后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465\"use strict\";function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError( \"this hasn't been initialised - super() hasn't been called\" ); &#125; return call &amp;&amp; (typeof call === \"object\" || typeof call === \"function\") ? call : self;&#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError( \"Super expression must either be null or a function, not \" + typeof superClass ); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true, &#125;, &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Father = function Father() &#123; _classCallCheck(this, Father); this.makeMoney = function () &#123; console.log(\"努力工作\"); &#125;; this.money = \"$1\"; this.goods = [\"手电筒\", \"冰箱\"];&#125;;var Son = (function (_Father) &#123; _inherits(Son, _Father); function Son() &#123; _classCallCheck(this, Son); return _possibleConstructorReturn( this, (Son.__proto__ || Object.getPrototypeOf(Son)).call(this) ); &#125; return Son;&#125;)(Father); 我们可以看到当创建类的时候，ES6 转换为 ES5 时，跟以前创建类会多一个_classCallCheck 函数，其实看名称就知道是一个检测，它接受两个参数，第一个是 this，第二个是构造函数，判断 this 是否是这个这个构造函数的实例，即 instanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，说白了就是判断调用前是否有 new 关键字，不是则抛出 Cannot call a class as a function 异常，所以能进一步可知 class 就是一个语法糖。 ES6 的继承转换为 ES5 后发现子类是一个自执行的函数，将父类作为参数传递过去。首先是_inherits 函数，同样接受两个参数，一个是子类构造函数，一个是父类构造函数。看其内部结构： 首先判断父类的类型 基于父类的原型创建一个新的对象。并通过 Object.create 的第二个参数，将新对象的构造函数指向子类，再将其赋值给子类的原型。 将子类的__proto__指向父类的构造函数 第二步是不是很熟悉，没错就是寄生组合式继承的简单版。之后是个闭包，保存父类的引用，闭包内部的实现步骤： 判断调用前是否有 new 关键字 因为_inherits 函数执行后，Son.__proto__ || Object.getPrototypeOf(Son)实际上指的就是父类的构造函数，通过 call 方法将其调用改为当前的 this _possibleConstructorReturn 函数中，首先校验 this 是否被初始化，super 是否调用，并返回父类已经赋值完的 this。 然后进行子类构造函数中的逻辑 当我们没有写子类构造函数时： 12345678910111213class Son extends Father &#123;&#125;// 转为ES5var Son = (function (_Father) &#123; _inherits(Son, _Father); function Son() &#123; _classCallCheck(this, Son); return _possibleConstructorReturn( this, (Son.__proto__ || Object.getPrototypeOf(Son)).apply(this, arguments) ); &#125; return Son;&#125;)(Father); 可见默认的构造函数中会主动调用父类构造函数，并默认把当前 constructor 传递的参数传给了父类。所以当我们声明了 constructor 后必须主动调用 super(),否则无法调用父构造函数，无法完成继承。本篇就先写到这吧，欢迎留言讨论。 参考资料： JavaScript 高级程序设计（第 3 版）","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"原型与原型链","slug":"原型和原型链","date":"2020-04-20T01:07:29.000Z","updated":"2020-06-25T08:13:51.262Z","comments":true,"path":"2020/04/20/原型和原型链/","link":"","permalink":"https://tomatoesman.github.io/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"1、创建对象 创建对象有几种方法： 字面量创建 123let obj = &#123; name: \"o1\",&#125;; object 构造函数创建 123let obj = new Object(&#123; name: \"o2\",&#125;); 构造函数创建 1234let Person = function () &#123; this.name = \"o3\";&#125;;let obj = new Person(); object 方法创建 1234let person = &#123; name: \"o4\",&#125;;let obj = Object.create(person); 此方法是 ES6 新出的方法，此方法的好处可以理解为继承一个对象, 添加的属性是在原型下 2、原型、构造函数、实例、原型链 每个函数都有一个 prototype 的属性，每个函数通过 prototype 属性指向的对象，我们就称之为原型对象。可能比较笼统，对原型也可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 我们可以看看对象的 prototype 到底返回的是什么： 12function Person() &#123;&#125;Person.prototype;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2020-04-17T07:23:42.000Z","updated":"2020-06-25T08:09:15.368Z","comments":true,"path":"2020/04/17/深拷贝和浅拷贝/","link":"","permalink":"https://tomatoesman.github.io/2020/04/17/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。为什么引用数据类型会出现这样的问题？第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。","text":"这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。为什么引用数据类型会出现这样的问题？第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。 1、浅拷贝12345let arr = [1, 2, 3];let new_arr = arr;arr.push(4);console.log(arr); //[1, 2, 3, 4]console.log(new_arr); //[1, 2, 3, 4] 开发时我们经常能遇到上面这种情况，当对原数组添加新值时，新数组也会发生改变，这种情况我们就称之为浅拷贝。原因是浅拷贝只拷贝引用地址，而地址都是指向了同一个对象，所以彼此之间的改变会相互影响。大部分情况下的拷贝都是浅拷贝，除了上面=（赋值）外实现浅拷贝的方法也有很多： 12345concat();slice();ES6新增：展开运算符(...)Array.from() 上述方法中 concat 会有些特殊： 12345let arr = [1, 2, 3];let new_arr = [].concat(arr);arr.push(4);console.log(arr); //[1, 2, 3, 4]console.log(new_arr); //[1, 2, 3] 上述结果显示，当改变原数组时，新数组并没有发生改变，会以为 concat 属于深拷贝的方法。但当进行下述运算时： 123456var arr = [&#123; old: \"old\" &#125;, [\"old\"]];var new_arr = arr.concat();arr[0].old = \"new\";arr[1][0] = \"new\";console.log(arr); //[&#123;old: 'new'&#125;, ['new']]console.log(new_arr); //[&#123;old: 'new'&#125;, ['new']] 所以可以得出结论，当数组元素是基本数据类型时，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们来写个函数简单实现一个浅拷贝： 12345678910let shallowCopy = (obj) =&gt; &#123; if (typeof obj !== \"object\") return; let new_obj = obj instanceof Array ? [] : &#123;&#125;; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; new_obj[key] = obj[key]; &#125; &#125; return new_obj;&#125;; 2、深拷贝深拷贝是完全拷贝一个新的对象，相当于开辟了一个新的内存空间，新旧两个对象不相互影响。实现深拷贝的方法主要有两个，一个是 JSON.parse(JSON.stringify())和还有一个是递归 123456let arr = [&#123; old: \"old\" &#125;, [\"old\"]];let new_arr = JSON.parse(JSON.stringify(arr));arr[0].old = \"new\";arr[1][0] = \"new\";console.log(arr); //[&#123;old: 'new'&#125;, ['new']]console.log(new_arr); //[&#123;old: 'old'&#125;, ['old']] 但是 JSON.parse(JSON.stringify())有个最大的问题就是，不能拷贝函数 123let arr = [&#123; old: \"old\" &#125;, function () &#123;&#125;];let new_arr = JSON.parse(JSON.stringify(arr));console.log(new_arr); //[&#123;old: 'old'&#125;, null] 我们通过递归的形式简单实现一个深拷贝： 1234567891011let deepCopy = (obj) =&gt; &#123; if (typeof obj !== Object) return; let new_obj = obj instanceof Array ? [] : &#123;&#125;; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; new_obj[key] = typeof obj[key] === \"object\" ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return new_obj;&#125;;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"类型转换","slug":"类型转换","date":"2020-04-17T03:38:47.000Z","updated":"2020-06-25T08:08:10.381Z","comments":true,"path":"2020/04/17/类型转换/","link":"","permalink":"https://tomatoesman.github.io/2020/04/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"1、显示类型转换显示类型转换顾名思义就是用特有的方法对类型进行转换显示类型转换的方式只有三种：","text":"1、显示类型转换显示类型转换顾名思义就是用特有的方法对类型进行转换显示类型转换的方式只有三种： 1、Number() 原始类型转换 数值：转换后还是数值 字符串：如果可以被解析为数值，则转化为相应的数值会忽略所有前导的 0，否则得到 NaN，空字符串为 0 1Number(\"000001\"); //1 布尔值：true 转成 1，false 转成 0 undefined：转成 NaN null：转成 0 对象类型转换 先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤 如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤 如果 toString 方法返回的是复合类型的值，则报错 parseInt 和 parseFloat parseInt：只解析整数，当传入的值以‘0x’或‘0X’开头时，会解析成十六进制数 parseFloat：既可以解析整数又可以解析浮点数 共同点：都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN 2、String() 原始类型转换 数值：转为相应的字符串 字符串：转换后还是原来的值 布尔值：true 转为‘true’，false 转为‘false’ undefined：转为‘undefined null：转为‘null’ 对象类型转换 先调用 toString 方法，如果 toString 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤 如果 toString 方法返回的是复合类型的值，再调用 valueOf 方法，如果 valueOf 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤 如果 valueOf 方法返回的是复合类型的值，则报错 JSON.stringify()JSON.stringify 底层也是调用了 toString 方法 3、Boolean()undefined、null、-0、+0、NaN、’’（空字符串）返回的都是 false，除了上述的都是返回 true，包括对象类型 2、隐式类型转换隐式类型转换同样有三种： 1、+（加号）1.1 一元+（加号）运算符查看ES5 规范 11.4.6可以看到，当+（加号）作为一元运算符时，底层会调用 ToNumber 方法去处理，相当于 Number()，当+（加号）后是普通数值时，返回的就是 Number(数值) 1+\"1\"; //1 当+（加号）后是对象类型时，对象类型就会像显示类型中所讲： 先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤 如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤 如果 toString 方法返回的是复合类型的值，则报错 12+[]; //0 []先调用valueof方法返回[]，再调用toString方法返回\"\"+&#123;&#125;; //NaN &#123;&#125;相当于new Object() 先调用valueof方法返回&#123;&#125;，再调用toString方法返回\"[object Object]\" 1.2 二元+（加号）运算符查看ES5 规范 11.6.1可以看到当 value1+value2 时： 1. lprim = ToPrimitive(value1) 2. rprim = ToPrimitive(value2) 3. 如果 lprim 和 rprim 都是 String 类型时，则直接返回 ToString(lprim)和 ToString(rprim)拼接结果 4. 返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果ToPrimitive、ToString、ToNumber 三者皆为内部函数: ToPrimitive 执行的步骤： 如果 obj 为基本类型，直接返回 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 ToString 相当于 String() ToNumber 相当于 Number() 按上述规范，对下列几个例子进行讲解： 12345null + 1; //1//1、lprim = ToPrimitive(null) 因为null为基本数据类型，所以返回null//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1//3、lprim和lprim都不是String类型，所以执行第四部//4、ToNumber(null)+ToNumber(1),所以返回为1 12345undefined + 1; //NaNnull//1、lprim = ToPrimitive(undefined) 因为undefined为基本数据类型，所以返回undefined//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1//3、lprim和lprim都不是String类型，所以执行第四部//4、ToNumber(undefined)+ToNumber(1),所以返回为NaN 1234[] + []; //''//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''//2、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''//3、lprim和lprim都是String类型，所以直接返回拼接，结果为'' 1234[] + &#123;&#125;; //'[object Object]'//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''//2、lprim = ToPrimitive(&#123;&#125;) &#123;&#125;的valueof为&#123;&#125;不是基本数据类型，再调用toString方法返回的是'[object Object]'//3、lprim和lprim都是String类型，所以直接返回拼接，结果为'[object Object]' 123&#123;&#125; + []; //0//按照规范来说，这个的结果应该和上一个一样，但是为什么会出现如此的不同，是因为在浏览器中，&#123;&#125;相当于一个独立的代码块，所以浏览器认为&#123;&#125;+[]相当于+[]，所以返回0//如果想返回和上一个一样的结果的话可以在表达式外加括号,(&#123;&#125; + [])这样就返回正常的结果了 1&#123;&#125; + &#123;&#125;; //谷歌返回'[object Object][object Object]' 火狐返回NaN 2、比较运算2.1 ==相等同样我们查看ES5 规范 11.9.3中所讲：比较 x == y，其中 x 和 y 是值，产生 true 或 false。这样的比较执行如下： 1. 如果 x,y 类型相同，则 a. 如果 x 是 Undefined，则返回 true。 b. 如果 x 为 Null，则返回 true。 c. 如果 x 是数字，则 i. 如果 x 为 NaN，则返回 false。 ii. 如果 y 为 NaN，则返回 false。 iii. 如果 x 与 y 相同，则返回 true。 iv. 如果 x 为+0 且 y 为 − 0，则返回 true。 v. 如果 x 为 − 0 且 y 为+0，则返回 true。 vi.返回 false。 d. 如果 x 类型为 String，则如果 x 和 y 是完全相同的字符序列（相同的长度和相同位置的相同字符），则返回 true。否则，返回 false。 e. 如果 x 类型为布尔值，则如果 x 和 y 均为 true 或均为 false，则返回 true。否则，返回 false。 f. 如果 x 和 y 指向同一对象，则 返回 true。否则，返回 false。 2. 如果 x 是 Null 和 y 是 Undefined 的，返回 true。 3. 如果 X 是 Undefined 和 y 为 Null，返回 true。 4. 如果 x 类型是 Number 且 y 类型是 String，则返回比较结果 x == ToNumber（y）。 5. 如果 x 类型为 String 且 y 类型为 Number，则返回比较结果 ToNumber（x）== y。 6. 如果 x 类型为布尔值，则返回比较结果 ToNumber（x）== y。 7. 如果 y 类型为布尔型，则返回比较结果 x == ToNumber（y）。 8. 如果 x 类型是 String 或 Number 且 y 类型是 Object，则返回比较结果 x == ToPrimitive（y）。 9. 如果 x 类型是 Object 并且 y 类型是 String 或 Number，则返回比较结果 ToPrimitive（x）== y。 10. 返回 false。按上述规范，对下列几个例子进行讲解： 123undefined == undefined; //truenull == null; //ture//查看上述的1.a、1.b条 12NaN == NaN; //false//查看上述的1.c.i条 123undefined == null; //truenull == undefined; //ture//查看上述的2、3条 1231 == \"1\"; //true\"1\" == 1; //ture//查看上述的4、5条 123false == 0; //true0 == false; //ture//查看上述的6、7条 123[] == 0; //true0 == []; //ture//查看上述的8、9条 2.2 &lt;判断同样我们查看ES5 规范 11.8.5中所讲：比较 x &lt; y（其中 x 和 y 是值）会产生 true，false 或 undefined（这表明至少一个操作数是 NaN）。除 x 和 y 外，该算法还使用名为 LeftFirst 的布尔标志 作为参数。该标志用于控制对 x 和 y 进行具有潜在可见副作用的操作的顺序 。这是必需的，因为 ECMAScript 指定了从左到右的表达式求值。LeftFirst 的默认值 为 true，表示 x 参数对应于 y 参数对应表达式左侧出现的表达式。如果 LeftFirst 为假，则相反，操作必须在 x 之前对 y 执行。这样的比较执行如下： 1. 如果LeftFirst标志为true，则 a. 设 px为调用ToPrimitive的结果（x，Number）。 b. 令 py为调用ToPrimitive的结果（y，Number）。 2. 否则需要颠倒评估顺序以保留从左到右的评估 a. 令 py为调用ToPrimitive的结果（y，Number）。 b. 设 px为调用ToPrimitive的结果（x，Number）。 3. 如果px和py都不是String类型，则 a. 令 nx为调用ToNumber（px）的结果。因为px和py是原始值，所以评估顺序并不重要。 b. 令 ny为调用ToNumber（py）的结果。 c. 如果 nx是NaN，则返回undefined。 d. 如果 ny是NaN，则返回undefined。 e. 如果 nx和ny是相同的Number值，则返回false。 f. 如果 nx为+0且ny为− 0，则返回false。 g. 如果 nx为− 0 且ny为+0，则返回false。 h. 如果 nx为+ ∞，则返回false。 i. 如果 ny为+ ∞，则返回true。 j. 如果 ny为-∞，则返回false。 k. 如果 nx为-∞，则返回true。 l. 如果nx的数学值小于ny的数学值（请注意，这些数学值都是有限的且不都是零），则返回true。否则，返回 false。 4. 否则，px和py都是字符串 a. 如果 py是px的前缀，则返回false。（如果q 可以是连接p和其他String r的结果，则String值p是String值q的前缀。请注意，任何String都是其自身的前缀，因为r 可能是空String。） b. 如果 px是py的前缀，则返回true。 c. 令 k为最小的非负整数，以使px内的位置k处的字符不同于py内的位置k处的字符。（必须有一个k，因为String都不是另一个的前缀。） d. 设m为整数，表示字符在px内位置k处的代码单位值。 e. 设n为整数，表示字符在py中位置k处的代码单位值。 f. 如果 m &lt; n，则返回true。否则，返回 false。按上述规范，对下列几个例子进行讲解： 12[] &lt; []; //false// 以我理解为首先LeftFirst发现左边为false，而后颠倒发现左边依旧为false，则相当于fasle&lt;fasle 最后结果为fasle 12[] &lt; &#123;&#125;; //ture// 相当于''和'[object Object]'进行比较，则明显空字符串小 参考：冴羽：JavaScript 深入之头疼的类型转换(上)冴羽：JavaScript 深入之头疼的类型转换(下)","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"js基础类型和引用类型","slug":"js基础类型和引用类型","date":"2020-04-08T14:14:00.000Z","updated":"2020-06-25T08:11:59.949Z","comments":true,"path":"2020/04/08/js基础类型和引用类型/","link":"","permalink":"https://tomatoesman.github.io/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型","text":"开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型 1、什么是基础类型（值类型、原始类型）保存在栈中的类型就是基础类型，原因是基础类型存储的空间很小，存放在栈中方便查找，且不易于改变 js 中的基础类型（值类型、原始类型）有哪些12Undefined、Null、Boolean、Number、String、Symbol（ES6中新加类型）// undefined和null是所有类型的子类型 2、什么是引用类型指有多个值构成的对象，引用数据类型是存储在堆中，也就是说存储的变量处的值是一个指针，指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度 js 中的引用类型有哪些1Object; 3、如何判断类型3.1 typeof具体使用： 12345678910111213console.log(typeof a); //'undefined'console.log(typeof true); //'boolean'console.log(typeof \"123\"); //'string'console.log(typeof 123); //'number'console.log(typeof NaN); //'number'console.log(typeof null); //'object'let obj = new String();console.log(typeof obj); //'object'let fn = function () &#123;&#125;;console.log(typeof fn); //'function'console.log(typeof class c &#123;&#125;); //'function'let sym = Symbol();console.log(typeof sym); //'symbol' 实现原理如下： 1不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。 所以 typeof null 的返回值是 object，这是个“历史遗留问题”。因为 typeof 判断引用类型时不太准确，所以我们选用其他方法。 3.2 instanceof通常来说，instanceof 是判断一个实例是否属于某种类型具体使用： 123456console.log(1 instanceof Number); //falseconsole.log(\"1\" instanceof String); //falseconsole.log(true instanceof Boolean); //falseconsole.log(function Foo() &#123;&#125; instanceof Function); //trueconsole.log(&#123;&#125; instanceof Object); //trueconsole.log([] instanceof Array); //true 从以上结果可以看出，instanceof 对引用类型来说判断的非常准确，但是对于基础类型却不能精准的判断。原因是 instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型的实例，1、‘1’、true 并不是实例，所以为 false。如下所示： 123console.log(new Number(1) instanceof Number); //trueconsole.log(new String(\"1\") instanceof String); //trueconsole.log(new Boolean(true) instanceof Boolean); //true 但是对 undefined 和 null，却比较特殊 12console.log(new null() instanceof Null); //Uncaught TypeError: null is not a constructorconsole.log(new undefined() instanceof Undefined); //Uncaught TypeError: undefined is not a constructor 原因是因为 undefined 和 null 并不是构造函数 3.3 constructor具体使用： 123456console.log((1).constructor === Number); //trueconsole.log(\"1\".constructor === String); //trueconsole.log(true.constructor === Boolean); //trueconsole.log([].constructor === Array); //trueconsole.log(&#123;&#125;.constructor === Object); //trueconsole.log(function Foo() &#123;&#125;.constructor === Function); //true 看着貌似很准确的样子，但是还是有缺陷，当创建一个对象改变他的原型的时候，就不再准确了！ 1234function Foo() &#123;&#125;Foo.prototype = new Array();let foo = new Foo();console.log(foo.constructor === Array); //true 这是因为 js 每个函数都有一个 prototype 属性，指向原型对象，对象.prototype.constructor 指向的是该对象的构造函数，当把该对象的原型对象更改时，该函数的构造对象也会更改，所以就会出现如上的问题 3.4 Object.prototype.toString.call()具体使用： 123456789console.log(Object.prototype.toString.call(1)); //[object Number]console.log(Object.prototype.toString.call(\"1\")); //[object String]console.log(Object.prototype.toString.call(true)); //[object Boolean]console.log(Object.prototype.toString.call([])); //[object Array]console.log(Object.prototype.toString.call(&#123;&#125;)); //[object Object]console.log(Object.prototype.toString.call(function Foo() &#123;&#125;)); //[object Function]console.log(Object.prototype.toString.call(undefined)); //[object Undefined]console.log(Object.prototype.toString.call(null)); //[object Null]console.log(Object.prototype.toString.call(Symbol())); //[object Symbol] 这是最准确的类型判定的方法，就算改变原型也不会有问题。具体分析一下这个方法背后的故事：每个 Object 原型上都有一个 toString 的方法，当调用这个方法的时候会执行三个步骤：1、获取对象的类名（对象类型）2、将[object、获取的对象类型]组合为字符串3、返回字符串 为什么要用 call 方法？因为 Array、String 等类型都对其继承下来原型上的 toSring 方法进行了重写，无法返回我们想要的结果，所以我们通过 call 方法，将 Object.prototype.toString 上的 Object 的指向改变，才能对类型进行精准的判断。 Object.toString 和 Object.prototype.toString 的区别？Object.toString 是 Object 构造器的方法，返回的是函数 1Object.toString(&#123;&#125;); //\"function Object() &#123; [native code] &#125;\" Object.prototype.toString 是 Object 原型上的方法，返回的是类型字符串，才是我们想要的结果 1Object.prototype.toString(&#123;&#125;); //\"[object Object]\"","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]}],"categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"},{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]}