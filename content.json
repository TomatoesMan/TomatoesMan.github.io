{"meta":{"title":"Tomato's blog","subtitle":"","description":"","author":"TomatoMan","url":"https://TomatoesMan.github.io","root":"/"},"pages":[{"title":"about","date":"2020-06-25T06:51:50.000Z","updated":"2020-06-25T06:52:47.681Z","comments":false,"path":"about/index.html","permalink":"https://tomatoesman.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-06-25T09:40:18.000Z","updated":"2020-06-25T09:48:17.124Z","comments":true,"path":"all-archives/index.html","permalink":"https://tomatoesman.github.io/all-archives/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-06-25T05:28:40.000Z","updated":"2020-06-25T09:24:50.032Z","comments":false,"path":"categories/index.html","permalink":"https://tomatoesman.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2020-06-25T05:41:02.000Z","updated":"2020-06-25T09:25:05.795Z","comments":false,"path":"tags/index.html","permalink":"https://tomatoesman.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"export","slug":"export","date":"2020-07-27T14:53:43.000Z","updated":"2020-07-27T14:56:10.085Z","comments":true,"path":"2020/07/27/export/","link":"","permalink":"https://tomatoesman.github.io/2020/07/27/export/","excerpt":"在原始的 JS 时代，是没有模块化的概念的，随着前端项目的越来越大，并且前端的地位越来越主要，急需模块化的概念引入进来。在 ES6 之前，社区制定了一些模块化的方案，如：CommonJS 和 AMD。ES6 之后这两个正在慢慢的被 import 和 export 所取代。 这让我想起了之前面试的时候一个面试官问我 ES6 为什么要引入 import 和 export，我的回答是为了模块化的加载，避免全局污染，然后他问了一个让我至今难忘的问题，为什么是 import 和 export 这两个单词？？？？😓😓😓 当时的我顿时语塞，只能弱弱的回答一句，JS 规范的….","text":"在原始的 JS 时代，是没有模块化的概念的，随着前端项目的越来越大，并且前端的地位越来越主要，急需模块化的概念引入进来。在 ES6 之前，社区制定了一些模块化的方案，如：CommonJS 和 AMD。ES6 之后这两个正在慢慢的被 import 和 export 所取代。 这让我想起了之前面试的时候一个面试官问我 ES6 为什么要引入 import 和 export，我的回答是为了模块化的加载，避免全局污染，然后他问了一个让我至今难忘的问题，为什么是 import 和 export 这两个单词？？？？😓😓😓 当时的我顿时语塞，只能弱弱的回答一句，JS 规范的…. 1、exportexport 用于规定模块对外的接口，不管你是否定义，export 导出的模块都是处于严格模式，不能用在嵌入式脚本中。 export 导出的语法有两种： 命名导出（每个模块包含任意数量） 默认导出（每个模块只包含一个） 1.1、命名导出如在 a.js 文件中，想要导出几个变量，我们可以写成如下两种形式。 12345678910// a.js// 第一种export var a = 1;export var b = 2;export var c = 3;// 第二种var a = 1;var b = 2;var c = 3;export &#123; a, b, c &#125;; 以上两种形式是等价的，但是倾向于第二种写法，因为第二种写法便于阅读，能一眼看出要导出的变量是什么。 除了能导出变量，我们在开发中应用最多的就是导出函数和类。 1234567891011export function foo(a, b) &#123; return a + b;&#125;// 等价于function foo(a, b) &#123; return a + b;&#125;export &#123; foo &#125;;// 应用到箭头函数const foo = (a, b) =&gt; a + b;export &#123; foo &#125;; 导出的名称除了可以是该变量原本的名称外，还可以通过 as 关键词对其重命名。 12var a = 1;export &#123; a as b, a as c &#125;; 上述通过 as 关键词对 a 变量进行了重命名，并且同一个变量可以重命名多次。 有一点值得注意的是，export 输出的一定是一个变量，变量，变量，重要的事情说三遍。 12345// 第一种export 1; // 报错// 第二种var a = 1;export a; // 报错 上述两种导出接口的方式均报错，因为输出均不是变量，第二种虽然 a 是变量，但是实际上跟第一种是一样的，只是变换了一下写法，函数和类也是如此。 1.2、默认导出我们可以通过 export default 命名对模块进行默认导出，并且一个模块中只能有一个默认导出。 123456789101112export default function (a, b) &#123; return a + b;&#125;export default function foo(a, b) &#123; return a + b;&#125;export default 1;var a = 1;export default a; 上一节我们说 export 最重要的是导出的接口是变量，在默认导出中发现如果导出的不是变量的话也是可以的，这是因为 default 其实就是一个变量，所以可以导出的不是一个变量，但是 default 后面跟着的是一个变量话，会报错。 1export default var a = 1; // 报错 2、importimport 命令用于输入其他模块提供的功能。export 有两种语法形式，对应的 import 也有两种语法形式 2.1、当输出是用的 export 语法时123456// a.jsvar a = 1;var b = 2;export &#123; a, b &#125;;import &#123; a, b &#125; from \"a.js\"; 当 export 输出模块接口时，import 要用大括号来进行导入，默认情况下导入的名称要和输出的名称一致。如果想要更改导入的名称，我们同样可以用 as 关键词进行重命名。 123456// a.jsvar a = 1;var b = 2;export &#123; a, b &#125;;import &#123; a as a1, b as b1 &#125; from \"a.js\"; 2.2、当输出是用的 export default 语法时12345// a.jsvar a = 1;export default a;import a from \"a.js\"; 也可以和上一节一块使用： 12345678// a.jsvar a = 1;var b = 2;var c = 3;export default c;export &#123; a, b &#125;;import c, &#123; a, b &#125; from \"a.js\"; 2.3、import 的其他特性import 表达式引入进来的所有模块都是只读形式，也就是说，不允许在加载模块的脚本里面，改写模块。 123import &#123; a &#125; from \"a.js\";a = &#123;&#125;; // Syntax Error : 'a' is read-only; 但是如果引入的模块是一个对象类型的话，它的属性是可以更改。 12import &#123; a &#125; from \"a.js\";a.name = \"Jack\"; // 合法 虽说此功能合法，但是在实际开发中还是要慎用。 import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 1import &#123; myMethod &#125; from \"util\"; 上面代码中，util 是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 import 还有一个特性时，import 具有提升，会提升到整个文件的最顶端，首先执行。 12foo(); // 不会报错import &#123; foo &#125; from \"a.js\"; 上述例子不会报错的原因就是因为 import 具有提升，提升到了 foo()之前，首先执行。 除此之外，import 不能当做表达式和变量，不能参与运算。 1234567import &#123;'1' + foo&#125; from 'a.js' // 报错// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; import 还可以仅仅导入模块，但不做任何的输入。 1import \"a.js\"; 这将运行模块中的全局代码, 但实际上不导入任何值。 与上述相反的是，将模块全部导入，整体加载，并且同样支持通过 as 关键词重命名。 123import * from 'a.js'import * as b from 'a.js' 2.4、export 和 import 复合写法如果在一个模块中先输入后输出同一个模块，那可以运用 export 和 import 复合写法，即 export…from… 1234export &#123; foo, bar &#125; from \"a.js\";// 可以简单的理解为import &#123; foo, bar &#125; from \"a.js\";export &#123; foo, bar &#125;; 值得注意的是，上述的 foo 和 bar 并没有引入到当前模块，当前模块相当于一个中转站，只是对 foo 和 bar 进行转发。 同样我们依然可以对转发的模块进行重命名，而且可以通过*对其全部转发。 12export &#123; foo as foo1 &#125; from \"a.js\";export * from \"a.js\"; 在 ES2020 中还可以对*通过 as 关键词进行重命名。 1234export * as a from \"a.js\";// 等价于import * as a from \"a.js\";export &#123; a &#125;; 除此之外，在 export 和 import 复合写法中，我们可以对默认模块进行转发。 1export &#123; default &#125; from \"a.js\"; 是不是感觉很奇怪，没错，我第一次见到的时候也很奇怪，但是后期想了一下，export…from…导入变量，default 也是变量的一种，所以这种也就不奇怪了。 依旧可以通过 as 进行重命名。 1export &#123; default as foo &#125; from \"a.js\"; 并且还可以将具名接口改为默认接口。 1234export &#123; foo as default &#125; from \"a.js\";// 等价于import &#123; foo &#125; from \"a.js\";export default foo; 2.5、import()ES2020 中新增了 import()，主要是为了解决无法动态导入的问题，因为之前也说过，JS 为了静态分析优化，所以 import 必须放在整个模块的顶部，并且不能和表达式混合使用，这在有些场景，尤其是 Node 中很是麻烦，这也是为什么 Node 还是偏向用 require 导入接口的原因之一。 使用 import()动态加载接口的用法很简单，括号内填写要动态导入接口就可以。 1import(\"a.js\"); import()会返回一个 Promise 对象。 1import(\"a.js\").then((value) =&gt; console.log(value)); import()的应用，最直观的就是应用在动态加载组件上，我们可以看到 dva 中dva/dynamic其内部主要就是运用了 import()，对组件和路由进行动态加载，达到优化目的。 1234567import dynamic from \"dva/dynamic\";const UserPageComponent = dynamic(&#123; app, models: () =&gt; [import(\"./models/users\")], component: () =&gt; import(\"./routes/UserPage\"),&#125;);","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"Symbol","slug":"Symbol","date":"2020-07-18T06:42:08.000Z","updated":"2020-07-18T07:01:09.967Z","comments":true,"path":"2020/07/18/Symbol/","link":"","permalink":"https://tomatoesman.github.io/2020/07/18/Symbol/","excerpt":"前言这篇文章说实话，在写完的那一刻真的对 Symbol 这个类型肃然起敬，平时真的不用这个数据类型，也没有想过会用它，之前还是停留在只是知道这个单词的阶段，在写完后才发觉它的强大。","text":"前言这篇文章说实话，在写完的那一刻真的对 Symbol 这个类型肃然起敬，平时真的不用这个数据类型，也没有想过会用它，之前还是停留在只是知道这个单词的阶段，在写完后才发觉它的强大。 Symbol，ES6 中新增的数据类型，为什么要增加这么一个数据类型？当初一个面试官这么问的我，当时年少轻狂的我，内心的 os 是，我哪知道 🤣！其实还是对 Symbol 这个数据类型不熟悉。 在 ES6 之前，对象的键只能是字符串类型，但是这样有个问题，就是会造成键名命名冲突，后者覆盖前者，这个时候就需要一个唯一值来充当键名，Symbol 横空出世。 1、概念symbol 是一种基本数据类型，Symbol()函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。但是它不是构造函数，不能用 new Symbol()来创建。 12let symbol = Symbol();typeof symbol; // \"symbol\" Symbol 作为对象属性时，当在对象内部时，必须要用方括号括起来，不用方括号括起来代表的是字符串。 123456let s = Symbol();let obj = &#123; [s]: \"Jack\",&#125;;obj[s]; // \"Jack\"obj.s; // undefined 而且当要取该属性的值时，不能用点运算符，因为点运算符后面同样是字符串类型。 创建 Symbol 数据类型时，都是 Symbol()这么创建的，当打印出来时，都为 Symbol()，这样很难区别各个 Symbol 类型的变量是什么意思。所以在 Symbol 函数内可以接收一个字符串的参数，表示该定义 Symbol 类型变量的描述。 123let s1 = Symbol(\"a\");console.log(s1); // Symbol(a)s1.toString(); // \"Symbol(a)\" 如果 Symbol 类型接收的一个对象类型的话，那就会先调用其内部的 toString 方法，将其变为一个字符串，然后才生成一个 Symbol 值。 12345678let arr = [1, 2, 3];let s1 = Symbol(arr);console.log(s1); // Symbol(1,2,3)let obj = &#123; toString: () =&gt; \"abc\",&#125;;let s2 = Symbol(obj);console.log(s2); // Symbol(abc) Symbol 类型的变量是不能和其他变量参与运算的，而且其只能转为 String 类型和 Boolean 类型。 12345let s = Symbol();console.log(\"1\" + s); // TypeError: Cannot convert a Symbol value to a strings.toString(); // \"Symbol()\"Boolean(s); // trueNumber(s); // TypeError: Cannot convert a Symbol value to a number 2、Symbol.prototype.description当给 Symbol 添加描述时，可以通过 Symbol.prototype.description 来获取该描述。 12let s = Symbol(\"Jack\");s.description; // 'Jack' 3、Symbol.for(key)和 Symbol.keyFor(sym)最开始看到这两个方法时，我以为是两个遍历的方法 😅。 Symbol.for(key)：使用给定的 key 搜索现有的 symbol，如果找到则返回该 symbol。否则将使用给定的 key 在全局 symbol 注册表中创建一个新的 symbol。 Symbol.keyFor(sym)：从全局 symbol 注册表中，为给定的 symbol 检索一个 key。 123let s1 = Symbol.for(\"foo\");let s2 = Symbol.for(\"foo\");s1 === s2; // true Symbol.for 会搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。所以由其创建的两个相同描述的值会相等。这种创建就和普通的 Symbol()有着截然不同的结果了： 123let s1 = Symbol(\"foo\");let s2 = Symbol(\"foo\");s1 === s2; // false 因为不管怎样 Symbol()返回的都是一个全新的值，换句话说 Symbol()生成的值没有注册在全局中，所以返回的值都是全新的，而 Symbol.for()会在先在全局中查找，有就返回这个值，没有则创建新的值，但新的值也是挂载在全局中的。 Symbol.keyFor(sym)是在全局中查找是否有该 Symbol 值，有则返回该描述。 1234let s1 = Symbol.for(\"Jack\");Symbol.keyFor(s1); // 'Jack'let s2 = Symbol(\"Rose\");Symbol.keyFor(s2); // undefined 因为 s2 没有挂载在全局中，所以 Symbol.keyFor()找不到它，故返回 undefined。 4、内置的 Symbol 属性除了定义自己使用的 Symbol 值以外，ES6 还提供了 13（有可能今后会更多 😛） 个内置的 Symbol 值，指向语言内部使用的方法。 4.1 Symbol.asyncIteratorSymbol.asyncIterator 符号指定了一个对象的默认异步迭代器。如果一个对象设置了这个属性，它就是异步可迭代对象，可用于 for await…of 循环。换句话说一个异步可迭代对象内部必须有 Symbol.asyncIterator 属性。 12345678910111213141516const myAsyncIterable = new Object();myAsyncIterable[Symbol.asyncIterator] = async function* () &#123; yield \"hello\"; yield \"async\"; yield \"iteration!\";&#125;;(async () =&gt; &#123; for await (const x of myAsyncIterable) &#123; console.log(x); // expected output: // \"hello\" // \"async\" // \"iteration!\" &#125;&#125;)(); 当执行 for await…of 时，就会执行该变量中 Symbol.asyncIterator 属性值。 4.2、Symbol.hasInstanceSymbol.hasInstance 用于判断某对象是否为某构造器的实例。因此你可以用它自定义 instanceof 操作符在某个类上的行为。换句话说当判断一个实例是否为一个类的实例时，其实就是执行该类里面的 Symbol.hasInstance 属性。 1234567class Fu &#123; [Symbol.hasInstance](num) &#123; return num === 1; &#125;&#125;1 instanceof new Fu(); // true2 instanceof new Fu(); // false 4.3、Symbol.isConcatSpreadable内置的 Symbol.isConcatSpreadable 符号用于配置某对象作为 Array.prototype.concat()方法的参数时是否展开其数组元素。 123456789// 默认情况下let arr = [1, 2, 3];let brr = [4, 5, 6];arr.concat(brr); // [1, 2, 3, 4, 5, 6]// 设置了Symbol.isConcatSpreadable后let arr = [1, 2, 3];let brr = [4, 5, 6];brr[Symbol.isConcatSpreadable] = false;arr.concat(brr); // [1, 2, 3, [4, 5, 6]] 将数组的 Symbol.isConcatSpreadable 属性设置为 false 后，使用 concat 方法时该数据就不会展开。 对于类数组而言，默认数组使用 concat 方法该类数组是不展开的，我们可以给类数组的 Symbol.isConcatSpreadable 设置为 true，这样就可以展开了，并且完成了类数组转换为数组，这样类数组转数组又多了一个方法。 12345678910111213// 默认情况下function foo(x, y) &#123; let arr = [].concat(arguments); console.log(arr); //[Arguments(2)]&#125;foo(1, 2);// 设置了Symbol.isConcatSpreadable为true后function foo(x, y) &#123; arguments[Symbol.isConcatSpreadable] = true; let arr = [].concat(arguments); console.log(arr); //[1, 2]&#125;foo(1, 2); 4.4、Symbol.iteratorSymbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。 12345678const myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable]; // [1, 2, 3] 对象进行 for…of 循环时，会调用 Symbol.iterator 方法， 4.5、Symbol.matchSymbol.match 指定了匹配的是正则表达式而不是字符串。String.prototype.match() 方法会调用此函数。换句话说就是当 str.match()执行时如果该属性存在，就会返回该方法的返回值。 123456class foo &#123; [Symbol.match](string) &#123; return string; &#125;&#125;\"Jack\".match(new foo()); // 'Jack' 除上述之外，MDN 还提出了该属性另外一个功能：此函数还用于标识对象是否具有正则表达式的行为。比如， String.prototype.startsWith()，String.prototype.endsWith() 和 String.prototype.includes() 这些方法会检查其第一个参数是否是正则表达式，是正则表达式就抛出一个 TypeError。现在，如果 match symbol 设置为 false（或者一个 假值），就表示该对象不打算用作正则表达式对象。 123456\"/bar/\".startsWith(/bar/); // TypeError: First argument to String.prototype.startsWith must not be a regular expression// 当设置为false之后var re = /foo/;re[Symbol.match] = false;\"/foo/\".startsWith(re); // true\"/baz/\".endsWith(re); // false 4.6、Symbol.matchAllSymbol.matchAll 返回一个迭代器，该迭代器根据字符串生成正则表达式的匹配项。此函数可以被 String.prototype.matchAll() 方法调用。 123\"abc\".matchAll(/a/);// 等价于/a/[Symbol.matchAll](\"abc\"); 4.7、Symbol.replaceSymbol.replace 这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。String.prototype.replace() 方法会调用此方法。 1234567891011121314String.prototype.replace(searchValue, replaceValue);// 等同于searchValue[Symbol.replace](this, replaceValue);// 例子class Replace1 &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.replace](string) &#123; return `s/$&#123;string&#125;/$&#123;this.value&#125;/g`; &#125;&#125;console.log(\"foo\".replace(new Replace1(\"bar\"))); // \"s/foo/bar/g\" 4.8、Symbol.searchSymbol.search 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 String.prototype.search()。 12345678910String.prototype.search(regexp);// 等价于regexp[Symbol.search](this);// 例子class Search1 &#123; [Symbol.search](str) &#123; return `$&#123;str&#125; Word`; &#125;&#125;\"Hello\".search(new Search1()); // Hello Word 4.9、Symbol.speciesSymbol.species 是个函数值属性，其被构造函数用以创建派生对象，换句话说 species 访问器属性允许子类覆盖对象的默认构造函数。 我们举个例子： 123456// 默认情况下class MyArray extends Array &#123;&#125;let arr = new MyArray(1, 2, 3);let brr = arr.map((item) =&gt; item);brr instanceof MyArray; // truebrr instanceof Array; // true 类 MyArray 继承于 Array，arr 为 MyArray 的实例，brr 为 arr 的衍生物，所以 brr 是 MyArray 的实例，并且由于原型链的缘故，brr 也是 Array 的实例。如果此时，我们只想让 brr 为 Array 的实例，那 Symbol.species 属性值就派上用场了。 123456789101112131415class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;let arr = new MyArray(1, 2, 3);let brr = arr.map((item) =&gt; item);brr instanceof MyArray; // falsebrr instanceof Array; // true// 默认情况下class MyArray extends Array &#123; static get [Symbol.species]() &#123; return this; &#125;&#125; 值得注意的是，定义 Symbol.species 属性时，前面必须声明是静态的 static 并且要运用 get 取值器。 4.10、Symbol.splitSymbol.split 指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过 String.prototype.split() 调用。 12345678910String.prototype.split(separator, limit);// 等价于separator[Symbol.split](this, limit);// 例子class Split1 &#123; [Symbol.split](str) &#123; return `$&#123;str&#125; Word`; &#125;&#125;\"Hello\".split(new Split1()); // Hello Word 4.11、Symbol.toPrimitiveSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数在调用时，会传递一个字符串参数 hint，表示要转换到的原始值的预期类型。字符串 hint 的类型有三种：’number’, ‘string’, ‘default’。 1234567891011121314151617let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case \"number\": return 123; case \"string\": return \"123\"; case \"default\": return \"default\"; default: throw new Error(); &#125; &#125;, &#125; + obj; // 123`$&#123;obj&#125;`; // '123'obj + \"\"; // \"default\" 4.12、Symbol.toStringTagSymbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。通俗点讲就是在 Object.prototype.toString()去判断自定义对象的数据类型时，返回的都是 object，可以通过这个属性来给自定义对象添加类型标签。在我之前写的【重学 JS 之路】js 基础类型和引用类型写到最精确判断数据类型的方法就是 Object.prototype.toString()，至于是为什么，在这就不过多阐述了，可以看这篇文章。 12Object.prototype.toString.call('123'); // [object String]...more 另外一些对象类型则不然，toString() 方法能识别它们是因为引擎为它们设置好了 toStringTag 标签： 1234Object.prototype.toString.call(new Map()); // \"[object Map]\"Object.prototype.toString.call(function* () &#123;&#125;); // \"[object GeneratorFunction]\"Object.prototype.toString.call(Promise.resolve()); // \"[object Promise]\"...more 当我们自己定义一个类时，调用 Object.prototype.toString()时，由于没有内部定义 toStringTag 标签，所以只能返回”[object Object]” 123456789class Foo &#123;&#125;Object.prototype.toString.call(new Foo()); // \"[object Object]\"// 设置Symbol.toStringTagclass Foo &#123; get [Symbol.toStringTag]() &#123; return \"Foo\"; &#125;&#125;Object.prototype.toString.call(new Foo()); // \"[object Foo]\" 4.13、Symbol.unscopablessSymbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。说白了其属性就是控制，在 with 词法环境中哪些属性会被 with 删除。 12345678910Array.prototype[Symbol.unscopabless];// &#123;// copyWithin: true,// entries: true,// fill: true,// find: true,// findIndex: true,// includes: true,// keys: true// &#125; 这里简单的讲解一下 with 函数，with 主要是用来对对象取值的，举个简单的例子： 12345678910let obj = &#123;&#125;;with (obj) &#123; let newa = a; let newb = b; console.log(newa + newb);&#125;// 等价于let newa = obj.a;let newb = obj.b;console.log(newa + newb); with 的 优点：当 with 传入的值非常复杂时，即当 object 为非常复杂的嵌套结构时，with 就使得代码显得非常简洁。with 的缺点：js 的编译器会检测 with 块中的变量是否属于 with 传入的对象， 上述例子为例，js 会检测 a 和 b 是否属于 obj 对象，这样就会的导致 with 语句的执行速度大大下降，性能比较差。 回归正题，我们举个例子看一下 Symbol.unscopables 属性的作用。 12345678910111213141516171819202122let obj = &#123; foo() &#123; return 1; &#125;,&#125;;with (obj) &#123; foo(); // 1&#125;// 设置了Symbol.unscopableslet obj = &#123; foo() &#123; return 1; &#125;, get [Symbol.unscopables]() &#123; return &#123; foo: true, &#125;; &#125;,&#125;;with (obj) &#123; foo(); // Uncaught ReferenceError: foo is not defined&#125; 设置后报错的原因是因为 with 已经将 obj 中的 foo 方法删除了。 此次也是对 Symbol 有了个重新的认识，也希望对你有所帮助。点个赞吧！💥🧡💖","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"Set和Map","slug":"Set和Map","date":"2020-07-09T14:09:11.000Z","updated":"2020-07-09T14:11:41.461Z","comments":true,"path":"2020/07/09/Set和Map/","link":"","permalink":"https://tomatoesman.github.io/2020/07/09/Set%E5%92%8CMap/","excerpt":"ES6 新增了两个数据结构，一个是 set，另外一个是 map。 1、set在《你不知道的 JavaScript(下卷)》中是这么定义的：set 是一个值的集合，其中的值唯一（重复会被忽略）。它类似于数组，但是每个成员的值是唯一的。","text":"ES6 新增了两个数据结构，一个是 set，另外一个是 map。 1、set在《你不知道的 JavaScript(下卷)》中是这么定义的：set 是一个值的集合，其中的值唯一（重复会被忽略）。它类似于数组，但是每个成员的值是唯一的。 set 是一个构造函数，可以通过 new 来创建一个 set 实例。 12let set = new Set([1, 2, 3, 1, 4]);console.log(set); // &#123;1, 2, 3, 4&#125; 上述可以看出，new Set 会自动过滤掉重复值，并返回一个集合，我们可以利用这个特性，来写出简单的数组去重。 123let set = new Set([1, 2, 3, 1, 4]);let arr = [...set];console.log(arr); // [1, 2, 3, 4] set 通过 add()来增加成员，将新值放在集合尾部，如果新值跟原集合中的成员重复的话，会被自动过滤掉。 123456let set = new Set([1, 2, 3, 1, 4]);set.add(1);console.log(set); // &#123;1, 2, 3, 4&#125;let set = new Set([1, 2, 3, 1, 4]);set.add(0);console.log(set); // &#123;1, 2, 3, 4, 0&#125; Set 的构造函数可以接受一个具有 Iterable 接口的其他数据结构作为参数。 123456789// 例1let set = new Set(\"string\");console.log(set); // &#123;\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"&#125;// 例2function foo(a, b) &#123; let set = new Set(arguments); console.log(set); // &#123;1, 2&#125;&#125;foo(1, 2); 2、set 的 APIset 的实例属性有两个： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size： 返回 Set 对象中的值的个数。 实例方法分为两类，一个是操作类，一个是遍历类。操作类： Set.prototype.add(value)：在 Set 对象尾部添加一个元素。返回该 Set 对象。 Set.prototype.clear()：移除 Set 对象内的所有元素。 Set.prototype.delete(value)：移除 Set 的中与这个值相等的元素，返回 Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回 true，否则返回 false）。Set.prototype.has(value)在此后会返回 false。 Set.prototype.has(value)：返回一个布尔值，表示该值在 Set 中存在与否。 12345678910111213// 例1let set = new Set([1, 2, 3]);set.clear();console.log(set); // &#123;&#125;// 例2let set = new Set([1, 2, 3]);let result = set.delete(1);console.log(result); // trueconsole.log(set); // &#123;2, 3&#125;// 例3let set = new Set([1, 2, 3]);let result = set.has(1);console.log(result); // true 遍历类： Set.prototype.values()：返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。 Set.prototype.keys()：与 values()方法相同，返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。 Set.prototype.forEach(callbackFn[, thisArg])：按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。如果提供了 thisArg 参数，回调中的 this 会是这个参数。 Set.prototype.entries()：返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和 Map 对象保持相似，每个值的键和值相等。 12345678// 例1let set = new Set([1, 2, 3]);let keys = set.keys();console.log(keys); // &#123;1, 2, 3&#125;// 例2let set = new Set([1, 2, 3]);let values = set.values();console.log(values); // &#123;1, 2, 3&#125; 上述两个例子，因为 Sset 没有键名，只有值，所以 keys 和 values 的结果是一样的。Set 同样拥有 forEach 方法： 1234567let set = new Set([1, 2, 3]);set.forEach((key, value) =&gt; &#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`);&#125;);// 1:1// 2:2// 3:3 跟数组的 forEach 方法不同的是，它的回调函数的参数是其 key 值和 value 值，但是 Set 没有 key 值，所以其 key 和 value 相等。forEach 的第二个参数是 this 值，其绑定的是回调函数中的 this 值。最后一个实例方法是 entries： 12345678let set = new Set([1, 2, 3]);let entries = set.entries();console.log(entries);// &#123;// [1, 1],// [2, 2],// [3, 3]// &#125; enteries()返回一个遍历器，返回一个键值对，但其键值对均相等。 3、WeakSetWeakSet 也是一个构造函数，与 Set 一直，WeakSet 和 Set 两者相似但不同，不同点主要有两个： WeakSet 的成员值必须是对象（可迭代的对象），而并不像 set 一样可以是原生类型值。 WeakSet 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 WeakSet 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的。 12345let weakSet = new WeakSet([1, 2]); // Uncaught TypeError: Invalid value used in weak setlet weakSet = new WeakSet([ [1, 2], [3, 4],]); // &#123;[1, 2], [3, 4]&#125; WeakSet 有三个实例方法： WeakSet.prototype.add(value)：返回构造函数即 WeakSet 本身。 WeakSet.prototype.delete(value)：从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false。 WeakSet.prototype.has(value)：返回一个布尔值, 表示给定的值 value 是否存在于这个 WeakSet 中。 12345678910111213var ws = new WeakSet();var foo = &#123;&#125;;var bar = &#123;&#125;;ws.add(foo);ws.add(bar);ws.has(foo); // truews.has(bar); // truews.delete(foo); // 从set中删除 foo 对象ws.has(foo); // false, foo 对象已经被删除了ws.has(bar); // true, bar 依然存在 4、Map在 JS 中对象是创建无序键 / 值对数据结构 [ 也称为 映射（map）] 的主要机制。但是，对象作为映射的主要缺点是不能使用非字符串值作为键。所以在 ES6 提出一个新的数据结构，Map。Map 和对象很类似，都是键值对的形式，但是 Map 的键可以是任意类型(对象或者原始值)，NaN 也可以作为键，不再只局限于字符串。任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作 Map 构造函数的参数。 12let map = new Map([[&#123; a: 1 &#125;, 3]]);console.log(map); // &#123;&#123;a:1&#125;: 3&#125; 在 MDN 中清晰的列出了 Map 和 Object 间的不同： Map Object 意外的键 Map 默认情况不包含任何键。只包含显式插入的键。 一个 Object 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。注意: 虽然 ES5 开始可以用 Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 键的类型 一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。 一个 Object 的键必须是一个 String 或是 Symbol。 键的顺序 Map 中的 key 是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。 一个 Object 的键是无序的。注意：自 ECMAScript 2015 规范以来，对象确实保留了字符串和 Symbol 键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。 Size Map 的键值对个数可以轻易地通过 size 属性获取 Object 的键值对个数只能手动计算 迭代 Map 是 iterable 的，所以可以直接被迭代。 迭代一个 Object 需要以某种方式获取它的键然后才能迭代。 性能 在频繁增删键值对的场景下表现更好。 在频繁添加和删除键值对的场景下未作出优化。 5、Map 的 APIMap 的实例属性有两个： Map.prototype.constructor：返回一个函数，它创建了实例的原型。默认是 Map 函数。 Map.prototype.size： 返回 Map 对象的键/值对的数量。 实例方法分为两类，一个是操作类，一个是遍历类。操作类： Map.prototype.set(key, value)：设置 Map 对象中键的值。返回该 Map 对象。 Map.prototype.get(key)：返回键对应的值，如果不存在，则返回 undefined。 Map.prototype.has(key)：返回一个布尔值，表示 Map 实例是否包含键对应的值。 Map.prototype.delete(key)：如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 Map.prototype.has(key) 将返回 false 。 Map.prototype.clear()：移除 Map 对象的所有键/值对。 123456789let map = new Map();let key = &#123; name: \"Jack\" &#125;;let value = \"啥\";map.set(key, value); // &#123;&#123;name: 'Jack'&#125;: '啥'&#125;map.get(key); // '啥'map.get(a); // undefinedmap.has(key); // truemap.delete(key); // truemap.clear(); // &#123;&#125; 遍历类： Map.prototype.entries()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg])：按插入顺序，为 Map 对象里的每一键值对调用一次 callbackFn 函数。如果为 forEach 提供了 thisArg，它将在每次回调中作为 this 值。 Map.prototype.keys()：返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键 。 Map.prototype.values()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值 。 1234567891011121314151617181920let map = new Map([ [\"name\", \"Jack\"], [&#123; age: 25 &#125;, \"啥\"],]);map.entries(); // MapIterator &#123;\"name\" =&gt; \"Jack\", &#123;age: 25&#125; =&gt; \"啥\"&#125;for (let item of map.entries()) &#123; console.log(item); // [\"name\", \"Jack\"] [&#123;age: 25&#125;, \"啥\"]&#125;map.forEach((value, key, map) =&gt; &#123; console.log(value, key, map); // Jack name Map(2) &#123;\"name\" =&gt; \"Jack\", &#123;age: 25&#125; =&gt; \"啥\"&#125; //\"啥\"&#123;age: 25&#125; Map(2) &#123;\"name\" =&gt; \"Jack\", &#123;age: 25&#125; =&gt; \"啥\"&#125;&#125;);map.keys(); // MapIterator &#123;\"name\", &#123;age: 25&#125;&#125;for (let item of map.keys()) &#123; console.log(item); // \"name\" &#123;age: 25&#125;&#125;map.values(); // MapIterator &#123;\"Jack\", \"啥\"&#125;for (let item of map.values()) &#123; console.log(item); // \"Jack\" \"啥\"&#125; 6、Map 和其他数据结构的转换6.1、Map 转数组ES6 给出一个最简单的方式，扩展运算符。 12345let map = new Map([ [\"name\", \"Jack\"], [&#123; age: 25 &#125;, \"啥\"],]);console.log([...map]); // [['name', 'Jack'], [&#123;age: 25&#125;, '啥']] 除此之外还可以用 Array.from()。 12345let map = new Map([ [\"name\", \"Jack\"], [&#123; age: 25 &#125;, \"啥\"],]);console.log(Array.from(map)); // [['name', 'Jack'], [&#123;age: 25&#125;, '啥']] 6.2、Map 转对象如果所有 Map 的键都是字符串，它可以无损地转为对象。 1234567891011function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map().set(\"yes\", true).set(\"no\", false);strMapToObj(myMap);// &#123; yes: true, no: false &#125; 6.3 Map 转 JSONMap 转 JSON 有两个形式，第一种是键名都是字符串的类型的，第二种是键名中包含非字符串类型。第一种的话直接将 map 转为对象，然后再用 JSON.Stringfy()进行转换。第二种的话可以转成数组 JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123; foo: 3 &#125;, [\"abc\"]);mapToArrayJson(myMap);// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' 7、WeakMapWeakMap 和 WeakSet 有些类似，都是弱引用，并且成员值的键必须是对象。 12let weakMap = new WeakMap([[1, 3]]); // Uncaught TypeError: Invalid value used as weak map keylet weakMap = new WeakMap([[&#123; name: \"Jack\" &#125;, 3]]); // &#123;&#123;name: 'Jack'&#125;: 3&#125; WeakMap 有四个实例方法： WeakMap.prototype.delete(key)：移除 key 的关联对象。执行后 WeakMap.prototype.has(key)返回 false。 WeakMap.prototype.get(key)：返回 key 关联对象, 或者 undefined(没有 key 关联对象时)。 WeakMap.prototype.has(key)：根据是否有 key 关联对象返回一个 Boolean 值。 WeakMap.prototype.set(key, value)：在 WeakMap 中设置一组 key 关联对象，返回这个 WeakMap 对象。 123456let weakMap = new WeakMap();let obj = &#123; name: \"Jack\" &#125;;weakMap.set(obj, 3); // &#123;&#123;name: 'Jack': 3&#125;&#125;weakMap.get(obj); // 3weakMap.has(obj); // trueweakMap.delete(obj); // true 参考： Set 和 Map 数据结构","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"Async和Await","slug":"Async和Await","date":"2020-07-06T14:14:10.000Z","updated":"2020-07-06T14:16:04.669Z","comments":true,"path":"2020/07/06/Async和Await/","link":"","permalink":"https://tomatoesman.github.io/2020/07/06/Async%E5%92%8CAwait/","excerpt":"async 是 ES7 提出的新特性，说白了就是 Generator 的语法糖。既然是语法糖，那我们首先说一下它的改进之处。 1、async 对 Generator 的改进","text":"async 是 ES7 提出的新特性，说白了就是 Generator 的语法糖。既然是语法糖，那我们首先说一下它的改进之处。 1、async 对 Generator 的改进 1.1、写法改进12345678Generator函数;function* foo() &#123; yield \"b\";&#125;Async函数;async function foo() &#123; await \"b\";&#125; 对比发现，async 函数在写法上，是将 Generator 函数的星号换成了 async 关键词，yield 关键词换成了 await。 1.2、 内置执行器Generator 函数的执行必须依靠执行器，而 async 函数自带执行器。所以 async 函数不用像 Generator 函数一样要用 next 方法才会执行，完全可以跟普通函数一样。 1.3、 更好的实用性co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 1.4、 返回值为 Promiseasync 函数返回的是一个 Promise 对象，可以试用 then 方法，不像 Generator 函数返回的是一个 Iterator 对象。 2、async 基本用法async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句，并且 await 必须要在 async 函数中，不然就会报错。 12345async function foo() &#123; let result = await \"b\"; return result;&#125;foo().then((value) =&gt; console.log(value)); // 6 上述可以看出，async 函数中 return 语句返回的值，会成为 then 回调函数的参数。当 async 函数中抛出错误时，会作为 catch 函数的参数传入。 1234async function foo() &#123; throw new Error(\"出错\");&#125;foo().catch((err) =&gt; console.log(err)); // Error: 出错 3、await 表达式通常来说 await 后边大部分都是 Promise 对象，当时 Promise 对象时，返回的是 Promise 对象 resolved 状态下的结果，如果是基本数据类型时，就是直接返回该结果。 12345async function foo() &#123; let result = await new Promise((resolve) =&gt; resolve(1)); return result;&#125;foo().then((value) =&gt; console.log(value)); // 1 当 await 后边是一个 thenable 对象是，会被当做是 Promise 对象一样处理。 123456789let thenable = &#123; name: \"Jack\", then: (resolve) =&gt; resolve(\"2\"),&#125;;async function foo() &#123; let result = await thenable; return result;&#125;foo().then((value) =&gt; console.log(value)); // 2 await 后面的 Promise 对象出现错误时： 1234567async function foo() &#123; await Promise.reject(\"出错了\"); await Promise.resolve(\"1\");&#125;foo() .then((value) =&gt; console.log(value)) .catch((err) =&gt; console.log(err)); // 出错了 当有多个 await 时，只要其中一个 await 后的 Promise 报错，那该表达式之后的所有语句将不再执行。如果想要执行之后的语句的话，可以使用 try…catch… 1234567891011async function foo() &#123; try &#123; await Promise.reject(\"出错了\"); &#125; catch (err) &#123; console.log(err); // 出错了 &#125; return await Promise.resolve(\"1\");&#125;foo() .then((value) =&gt; console.log(value)) // 1 .catch((err) =&gt; console.log(err)); 除此之外还有一种方法： 1234567async function foo() &#123; await Promise.reject(\"出错了\").catch((err) =&gt; console.log(err)); // 出错了 return await Promise.resolve(\"1\");&#125;foo() .then((value) =&gt; console.log(value)) // 1 .catch((err) =&gt; console.log(err)); 因为 catch 抓的是它之前的错误。值得注意的是，如果有多个 await 时，这几个 await 并不是同时触发，而是继发，即上一条 await 后的 Promise 成功后再触发下一条 await，如果想同时触发的话，可选用 Promise.all 方法。 1234567async function foo() &#123; let [a, b] = await Promise.all([ new Promise((resolve) =&gt; resolve(1)), new Promise((resolve) =&gt; resolve(2)), ]); return [a, b];&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"Generator","slug":"Generator","date":"2020-07-02T14:17:50.000Z","updated":"2020-07-02T14:24:15.601Z","comments":true,"path":"2020/07/02/Generator/","link":"","permalink":"https://tomatoesman.github.io/2020/07/02/Generator/","excerpt":"Generator 是 ES6 提出的一种异步编程的解决办法，它与传统的函数完全不同，本章从基础概念和基本用法进行讲解和解析。在此之前也是对 Generator 函数云里雾里，所以通过此次学习，希望能对 Generator 有更深的理解和认识。 1.概念Generator 中文的意思是’生成器’，阮一峰：ECMAScript 6 入门中对 Generator 解释是：Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。","text":"Generator 是 ES6 提出的一种异步编程的解决办法，它与传统的函数完全不同，本章从基础概念和基本用法进行讲解和解析。在此之前也是对 Generator 函数云里雾里，所以通过此次学习，希望能对 Generator 有更深的理解和认识。 1.概念Generator 中文的意思是’生成器’，阮一峰：ECMAScript 6 入门中对 Generator 解释是：Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。Generator 有两个特点：第一个是在定义时，要在 function 关键字和函数名中加一个星号，第二个就是在函数体中运用 yeild 表达式表示不同的状态。 123456function* foo() &#123; yield \"a\"; yield \"b\";&#125;let f = foo();console.log(f); 和普通函数不同的是，当运行这个函数时，返回不是这个函数的结果，而是一个遍历器对象，或者可以说是一个含有内部状态指针的对象。如果想输出值得话，要用 next 方法来进行输出。next 方法就是向下移动指针，即每次调用 next 方法，就是从函数头部或者从上一次 yield 表达式移动到下一次 yield 表达式（或者 return 为止）。 12345678function* foo() &#123; yield \"a\"; yield \"b\";&#125;let f = foo();f.next(); // &#123;value: \"a\", done: false&#125;f.next(); // &#123;value: \"b\", done: false&#125;f.next(); // &#123;value: undefined, done: true&#125; 上述可以看出，调用 next 时输出的是一个对象，即 value 值代表 yield 后面的结果，done 代表遍历还没有结束，当遍历结束时，value 值都为 undefined，done 都为 true。 2.yield 表达式yield 有个懒惰的特性，即 yield 后面的表达式，如果不调用 next 方法，是不会执行的。 1234function* foo() &#123; yield 1 + 1;&#125;foo().next(); // 2 只有当 next 指针移动到该 yield 的时候，才会执行后面的表达式。yield 和 return 是有不同之处的，在 Generator 函数中，可以定义多个 yield 表达式，但是 return 只能定义一个，并且在 yield 中遍历还没有完成，但在遇到 return 时，遍历就终止了。 12345678910function* foo() &#123; yield \"a\"; yield \"b\"; return \"c\";&#125;let f = foo();f.next(); // &#123;value: \"a\", done: false&#125;f.next(); // &#123;value: \"b\", done: false&#125;f.next(); // &#123;value: \"c\", done: true&#125;f.next(); // &#123;value: undefined, done: true&#125; 当遇到 return 时，遍历结束 done 为 true，value 值为 return 后的结果，在此之后的 next 的结果都为{value: undefined, done: true}。如果在 Generator 函数中没有 yield 表达式： 12345function* foo() &#123; console.log(\"a\");&#125;let f = foo();f.next(); foo()返回的依旧是一个含有内部状态指针的对象，只有当 next 方法执行时该函数才会执行。当 yield 和其他表达式融合时，如果 yield 表达式在左边，要将 yield 表达式用圆括号包裹，否则就会报语法错误。 12345678function* foo() &#123; console.log('a'+ yield 'b'); // Uncaught SyntaxError: Unexpected identifier&#125;function* foo() &#123; console.log('a'+ (yield 'b')); // &#123;value: \"b\", done: false&#125;&#125;let f = foo();f.next(); 当用作函数参数或放在赋值表达式的右边，可以不加括号。 1234function* demo() &#123; foo(yield \"a\", yield \"b\"); // OK let input = yield; // OK&#125; 3.next 方法yield 是没有返回值的，它的返回值是 undefined，我们可以通过 next 方法将参数传递给 yield，此参数将会为 yield 的返回值。 123456789101112function* f() &#123; for (var i = 0; true; i++) &#123; var reset = yield i; if (reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next(); // &#123; value: 0, done: false &#125;g.next(); // &#123; value: 1, done: false &#125;g.next(true); // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 表达式，变量 reset 的值总是 undefined。当 next 方法带一个参数 true 时，变量 reset 就被重置为这个参数（即 true），因此 i 会等于-1，下一轮循环就会从-1 开始递增。不用 next 方法是否可以输出值呢？答案是可以的，可以用 for…of…方法遍历 Generator 函数。 123456789101112function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v); // 1 2 3 4 5&#125; 值得注意的是，for…of…在 done 为 ture 的时候就会终止执行，所以 return 后的 6 没有输出。 4.yield* 表达式yield* 表达式是为了解决在一个 Generator 函数中调用另一个 Generator 函数所提供的方法。 123456789101112131415function* foo() &#123; yield 1; yield 2; yield 3; yield* foo1();&#125;等同于;function* foo() &#123; yield 1; yield 2; yield 3; for (let v of foo1()) &#123; yield v; &#125;&#125; 当 yield*后边的 Generator 函数中没有 return 时，作用就是 for…of…遍历 Generator 函数，如果 Generator 函数中有 return 时，则获取的是 return 值。 12345678910111213141516function* foo() &#123; yield 1; yield 2; yield 3; var value = yield* foo1(); console.log(value);&#125;function* foo1() &#123; yield 4; return 5;&#125;let f = foo();f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // 5 &#123;value: undefined, done: true&#125; 其实 yield*后面只要是带有 Iterator 接口的都会被遍历。 12345function* foo() &#123; yield* [1, 2, 3, 4];&#125;let f = foo();f.next(); // &#123;value: 1, done: false&#125; 再举个例子： 123456789101112function* foo() &#123; yield \"a\"; yield \"b\"; return \"END\";&#125;function* bar(func) &#123; let result = yield* func(); console.log(result);&#125;[...bar(foo)];// END// [\"a\", \"b\"] 上述中 foo 是拥有 return 表达式的函数，所以 return 后的结果会‘赋值’给 yield*表达式的返回值，所以 result 是’END’，并且拓展运算符默认调用 Iterator 接口，所以会先打印出 result，然后再执行 yield。 参考：阮一峰：ECMAScript 6 入门","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"Promise","slug":"Promise","date":"2020-06-28T15:31:26.000Z","updated":"2020-06-28T15:33:13.296Z","comments":true,"path":"2020/06/28/Promise/","link":"","permalink":"https://tomatoesman.github.io/2020/06/28/Promise/","excerpt":"Promise 让人又恨又爱的存在，恨是因为面试的时候会围绕它出很多题，又绕又头疼，爱是真香，谁都逃不过真香定律。 1、概念Promise 是异步编程的一个新的解决方案，阮一峰：ECMAScript 6 入门中给出对 promise 的含义是：所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 是一个构造函数，它有两个特点：","text":"Promise 让人又恨又爱的存在，恨是因为面试的时候会围绕它出很多题，又绕又头疼，爱是真香，谁都逃不过真香定律。 1、概念Promise 是异步编程的一个新的解决方案，阮一峰：ECMAScript 6 入门中给出对 promise 的含义是：所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 是一个构造函数，它有两个特点： Promise 有三个状态：pending（进行中）、resolved（已成功）和 rejected（已失败）。并且状态不受外部的影响。 状态一旦改变就无法修改。只能有两个过程：一个是从 pending 到 resolved 还有一个就是从 pending 到 rejected，不可能从 resolved 到 rejected，一旦成功就不可能再失败了。 Promise 一旦创建就会立即执行，不能中途取消。 2、用法通常我们来说，Promise 主要是解决异步回调地狱。什么是回调地狱？从网上找了几张图，大家可以感受一下被回调地狱所支配的恐惧：回调地狱最大的缺点就是代码可读性差，编写费劲。接下来我们来看一下 Promise 的基本用法： 12345678new Promise((resolve, reject)=&gt;&#123; ... if(success) &#123; resolve(value); &#125;else &#123; reject(error); &#125;&#125;) 之前说过，Promise 是一个构造函数，它接收一个函数参数，这个函数中接收两个参数，一个是 resolve 还有一个是 rejected，这两个参数均为函数，并且这两个参数不用自己部署，JS 引擎会自动部署。resolve 函数的作用是当异步函数成功时，将成功后的值传递出去，同时也是将状态从 pending 变为 resolved，reject 函数的作用是当异步函数失败后，将失败的错误信息传递出去，同时也是将状态从 pending 变为 rejected。 2.1、then()当 Promise 实例创建成功后，可以执行其原型上的 then 方法，then 方法同样接收两个函数参数，第一个是接收的 resolve 回调的结果，第二个是 reject 回调的结果，第二个参数是非必填的。 12345678910new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;).then( (value) =&gt; console.log(value) // 1);new Promise((resolve, reject) =&gt; &#123; reject(\"出现错误\");&#125;).then( (error) =&gt; console.log(error) // 出现错误); 因为 Promise 的对象时立即创建的，所以在 resolve 和 reject 函数之前的操作都会立即执行： 123456new Promise((resolve, reject) =&gt; &#123; console.log(2); resolve(1);&#125;).then( (value) =&gt; console.log(value) // 2 1); Promise 执行 then 方法后会返回回来一个新的 Promise 对象，所以可以采用链式调用。 12345new Promise((resolve) =&gt; &#123; resolve(1);&#125;) .then((value) =&gt; value + 1) .then((value) =&gt; console.log(value)); // 2 第一个 then 函数的返回值，可以作为参数传给第二个 then 函数。如果第一个 then 函数返回的依旧是一个 Promise 对象呢？即是一个 Promise 封装的异步操作： 12345678910new Promise((resolve) =&gt; &#123; resolve(1);&#125;) .then( (value) =&gt; new Promise((resolve) =&gt; &#123; resolve(3); &#125;) ) .then((value) =&gt; console.log(value)); // 3 此时第二个 then 函数传入的参数，即为第一个 then 函数返回的 Promise 对象的 resolved 状态下传递的值。也可以说只有第一个 then 返回的 Promise 执行状态成功时，第二个 then 函数才会执行。 2.2、catch()除了 then 函数外，在 Promise 原型上还有一个 catch 函数，此函数时当 Promise 内部异步出现错误的时候即为 rejected 状态时，才执行。 1234567new Promise((resolve, reject)=&gt;&#123; throw new Error('test')&#125;).catch(err=&gt;console.log(err)) // Error: test等同于：new Promise((resolve, reject)=&gt;&#123; throw new Error('test')&#125;).then(null, err=&gt;console.log(err)) // Error: test 当 then 第二个参数和 catch 函数同时存在时，将不会执行 catch 函数： 12345new Promise((resolve, reject) =&gt; &#123; throw new Error(\"test\");&#125;) .then(null, (err) =&gt; console.log(err)) // Error: test .catch((err) =&gt; console.log(err)); 那此时的 catch 捕获的是哪个 Promise 的错误呢？捕获的是前一个 Promise 的错误，即 then 函数返回回来的 Promise 错误： 1234567new Promise((resolve, reject) =&gt; &#123; throw new Error(\"test\");&#125;) .then(null, (err) =&gt; &#123; throw new Error(\"test1\"); &#125;) .catch((err) =&gt; console.log(err)); // Error: test1 Promise 的错误有一种类似冒泡机制，当 catch 之前没有没有任何函数截获错误，那终究会被 catch 截获。 12345new Promise((resolve, reject) =&gt; &#123; throw new Error(\"test\");&#125;) .then() .catch((err) =&gt; console.log(err)); // Error: test 只要 catch 前任何一个 Promise 报错，那终究会被 catch 截获。通常情况下，不建议使用 then 函数的第二个参数来进行错误的捕获，如上所说的 catch 写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用 catch()方法，而不使用 then()方法的第二个参数。then()返回一个新的 Promise 对象，catch()同样返回一个 Promise 对象，同样可以使用链式调用： 123456new Promise((resolve, reject) =&gt; &#123; throw new Error(\"test\");&#125;) .then() .catch((err) =&gt; console.log(err)) // Error: test .then(() =&gt; console.log(2)); // 2 当 catch 捕获完错误后，会接着执行下面的 then 方法，当没有错误抛出时，则会跳过 catch，直接执行后面的 then 方法。但是之后的 Promise 出现错误时，之前的 catch 就捕获不到了。 12345678new Promise((resolve, reject) =&gt; &#123; throw new Error(\"test\");&#125;) .then() .catch((err) =&gt; &#123; throw new Error(\"test1\"); &#125;) // Error: test .then(() =&gt; console.log(2)); catch 后面可以链式调用 then 方法，同样也可以调用 catch 方法，后面的 catch 方法是接收前一个 catch 方法所抛出的错误。 2.3、finally在 ES8 中新加入了一个方法，即 finally，此方法不同于 then 和 catch，它不跟踪与 Promise 对象状态的改变，即不管 Promise 的最终状态如何，都会执行这个方法，同时 finally 不同于 then 和 catch 地方就是，它不接受任何参数。 1234567891011new Promise((resolve) =&gt; &#123; resolve(1);&#125;) .then((value) =&gt; console.log(value)) // 1 .finally(() =&gt; console.log(2)); // 2new Promise(() =&gt; &#123; throw new Error(\"test\");&#125;) .catch((err) =&gt; console.log(err)) // Error test .finally(() =&gt; console.log(2)); // 2 finally 同样返回一个新的 Promise 对象，用法和之前的 then 和 catch 一样，这块就不做过多的讲解了。 3、其他 API除了上述 Promise 原型上的方法外，Promise 还有很多其他的 API。 3.1、 Promise.all通过字面意思就能看出来，这个方法是‘全部’意思，由此可见可以接受多个 Promise 对象。该方法接受具有 Iterator 接口并且每个成员都是 Promise 实例的参数，并返回一个新的 Promise 对象。 1234567891011let p = Promise.all([ new Promise((resolve) =&gt; &#123; resolve(1); &#125;), new Promise((resolve) =&gt; &#123; resolve(2); &#125;), new Promise((resolve) =&gt; &#123; resolve(3); &#125;),]); 并且，只有当接受的参数中所有成员的状态都为 resolved 的时候，p 的状态才会为 resolved，如果有一个成员的状态为 rejected，那 p 的状态就为 rejected。当所有成员的状态均为 resolved 的时候，会将每个成员 resolved 状态下的值拼成数组传递给 p 的回调函数。 123456789101112let p = Promise.all([ new Promise((resolve) =&gt; &#123; resolve(1); &#125;), new Promise((resolve) =&gt; &#123; resolve(2); &#125;), new Promise((resolve) =&gt; &#123; resolve(3); &#125;),]);p.then((result) =&gt; console.log(result)); // [1, 2, 3] 当有一个成员的状态为 rejected 的时候，则会将第一个 rejected 状态的值返给 p 的 catch 方法。 123456789101112let p = Promise.all([ new Promise((resolve) =&gt; &#123; resolve(1); &#125;), new Promise((resolve, rejecct) =&gt; &#123; rejecct(2); &#125;), new Promise((resolve) =&gt; &#123; resolve(3); &#125;),]);p.catch((err) =&gt; console.log(err)); 如果有一个成员为 rejected 状态，并且自身调用了 catch 方法，那将不会走 p 对象的 catch 方法，这一点要注意。 3.2、 Promise.racerace 翻译成中文是竞赛的意思，他表示多个 Promise 对象，哪个成员率先改变状态，那 Promise.race 返回的 Promise 对象的状态变为什么，并将值转递给 p 的回调函数，它和 Promise.all 接收的参数一样。 12345678910111213141516171819202122232425let p = Promise.race([ new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(1), 100); &#125;), new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(2), 50); &#125;), new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(3), 200); &#125;),]);p.then((result) =&gt; console.log(result)); // 2let p = Promise.race([ new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(1), 100); &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(2), 50); &#125;), new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(3), 200); &#125;),]);p.catch((err) =&gt; console.log(err)); // 2 3.3、Promise.allSettled该方法是 ES2020 新加入的，和 all 一样，返回一个新的 Promise 对象，接收一组 Promise 对象，但是和 all 区别的是，当不管每个成员的 Promise 是什么状态，只要执行结束，则返回的 Promise 对象就会执行结束。 123456789101112let p = Promise.allSettled([ new Promise((resolve) =&gt; &#123; resolve(1); &#125;), new Promise((resolve, rejecct) =&gt; &#123; rejecct(2); &#125;), new Promise((resolve) =&gt; &#123; resolve(3); &#125;),]);p.then((value) =&gt; console.log(JSON.stringify(value))); // [&#123;status:\"fulfilled\",value:1&#125;,&#123;status:\"rejected\",reason:2&#125;,&#123;status:\"fulfilled\",value:3&#125;] 有时候异步请求并不在意是否能够成功，这个时候这个方法就很符合场景了，并且返回一个数组，数组中每个对象有两个状态，一个是 fulfilled，另一个是 rejected，返回之后可以进行筛选，查看错误信息。 3.4、Promise.resolve将一个对象转化为一个 Promise 对象。 123Promise.resolve(\"foo\");等价于;new Promise((resolve) =&gt; resolve(\"foo\")); 当 Promise.resolve 的参数是一个 Promise 实例时，原封不动的返回这个实例： 123let p = new Promsie((resolve) =&gt; resolve(1));let p1 = Promise.resolve(p);p === p1; // true 当参数是一个 thenable 对象时，即含有 then 方法的对象时，会返回一个 Promise 对象，并立即执行 then 方法。 1234567let thenable = &#123; then: function (resolve, reject) &#123; resolve(1); &#125;,&#125;;let p = Promise.resolve(thenable);p.then((value) =&gt; console.log(value)); // 1 当参数是不是一个 thenable 对象时，由于参数不是一个异步的，所以当 Promise.resolve 后，直接的状态就是 resolved 的状态，所以 then 后就会输出原值。 123456789101. 参数是个普通对象let obj = &#123; name: '1'&#125;let p = Promise.resolve(obj);p.then(value=&gt;console.log(value)) // &#123;name: '1'&#125;2. 参数是个基本数据类型let num = '1';let p = Promise.resolve(num);p.then(value=&gt;console.log(value)) // 1 当不传参数的时候，返回的就是一个带有 resolved 状态的 Promise 对象。 3.5、Promise.reject返回一个状态为 rejected 的 Promise 对象，传入的参数作为错误信息作为后续方法传递的参数。 123let num = \"1\";let p = Promise.reject(num);p.then(null, (err) =&gt; console.log(err)); // 1 当参数是 thenable 对象时，返回的不是 error 信息而是 thenable 对象。 1234567let thenable = &#123; then: function (resolve, reject) &#123; reject(1); &#125;,&#125;;let p = Promise.reject(thenable);p.then(null, (err) =&gt; console.log(err === thenable)); // true","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"var、let和const","slug":"var、let和const","date":"2020-06-22T14:35:21.000Z","updated":"2020-06-25T12:06:05.668Z","comments":true,"path":"2020/06/22/var、let和const/","link":"","permalink":"https://tomatoesman.github.io/2020/06/22/var%E3%80%81let%E5%92%8Cconst/","excerpt":"1、var在没出现 let 和 const 之前，我们定义变量只能用 var。但是用 var 定义变量通常有很多的问题，就是我们常说的变量提升，例如：","text":"1、var在没出现 let 和 const 之前，我们定义变量只能用 var。但是用 var 定义变量通常有很多的问题，就是我们常说的变量提升，例如： 1234if (false) &#123; var a = 1;&#125;console.log(a); 如果初学者第一次看这段代码的时候，肯定会觉得段代码会报错，因为 if 中的条件是 false，并没有执行 var a = 1，所以最后应该报 a 没有定义的错误，但是实际最后却输出了 undefined，这就是变量提升。什么是变量提升：MDN 是这么说的：变量提升（Hoisting）被认为是， Javascript 中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。在 ECMAScript® 2015 Language Specification 之前的 JavaScript 文档中找不到变量提升（Hoisting）这个词。不过，需要注意的是，开始时，这个概念可能比较难理解，甚至恼人。这就没了？对这就没了！当看到的时候同样有这个疑问，所以我在var 描述中找到了这么一句话：变量声明，无论发生在何处，都在执行任何代码之前进行处理。所以以上代码可以被翻译成这样： 12345var a;if (false) &#123; a = 1;&#125;console.log(a); 2、let我们先看一下 let 的几大特性： 1、没有声明提升我们通过代码来看一下： 1234if (false) &#123; let a = 1;&#125;console.log(a); 欣喜若狂终于得到了我们想要的结果，报错，a 没有被定义。 2、重复声明报错12var a = 1;let a = 2; 哇塞，报错了，显示 a 已经被定义过了，这简直是太友好了，终于不会一不小心就改变了全局变量，也终于避免了重复命名的危险。 3、不绑定全局作用域12let a = 1;console.log(window.a); // undefined 根本没有定义到全局上，主要还是因为 let 是块级作用域不是全局作用域。 3、const在开发中 const 我们一般是来定义常量，即不可更改的量，它的基本特性和 let 是差不多的。 12const a = 1;a = 3; 执行上述代码时，会报错，因为 const 定义的是常量，无法进行修改。但是当 const 定义的是引用数据类型时： 12345const a = &#123; value: 1,&#125;;a.value = 2;console.log(a); // &#123;value: 2&#125; 感觉有些打脸，但确实如此，这是因为 const 定义的实际是引用地址，它判断是的引用地址是否发生变化，虽然改变了引用数据中的数据，但是它的引用地址并没有发生变化，所以就可以更改，但是这种方式还是不提倡的。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"}]},{"title":"call、apply和bind","slug":"call、apply和bind","date":"2020-06-18T15:03:59.000Z","updated":"2020-06-25T11:52:37.088Z","comments":true,"path":"2020/06/18/call、apply和bind/","link":"","permalink":"https://tomatoesman.github.io/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/","excerpt":"call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。","text":"call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。 1、callW3school中对 call()方法的定义是：它可以用来调用所有者对象作为参数的方法。通过 call()，能够使用属于另一个对象的方法。我们举个例子： 1234567var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;bar.call(foo); 由上可以看出 call()函数主要做了两件事，第一个是改变 this 的指向，将 bar 中的 this 指向了 foo，第二个是执行了 bar 方法。 接下来我们来模拟 call 方法： 第一步：实现简单的 call 方法：上面的例子可以改造为： 1234567var foo = &#123; name: \"Jack\", bar: function () &#123; console.log(this.name); &#125;,&#125;;foo.bar(); 输出的结果和上述的一模一样，唯一的不同就是 foo 中多了一个 bar 的属性，那我们执行完后删除这个属性就可以了。 123456789101112Function.prototype.myCall = function (Context) &#123; Context.fn = this; // 此时的this指向的是Function，即调用者 Context.fn(); delete Context.fn;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;bar.myCall(foo); 结果和 call 一致。 第二步：因为 call 可以带参数，所以我们接下来实现这个看一下原版的： 123456789var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); // 10 console.log(goods); // 自行车&#125;bar.call(foo, 10, \"自行车\"); 因为参数是不固定的，所以可以想到 arguments。怎么将 arguments 传入对象中，这就是个难题，高兴的是 ES6 给了我们方法：解构赋值 123456789101112131415Function.prototype.myCall = function (Context) &#123; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = [...arguments].slice(1); Context.fn(...args); delete Context.fn;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); // 10 console.log(goods); // 自行车&#125;bar.myCall(foo, 10, \"自行车\"); 是不是感觉特别简单，但是 call 是 ES3 的方法，解构赋值是 ES6 的方法，感觉有点欺负它，那我们就需要重新想一个。这个方法也是查看了资料后才找到的，自己能力还是有限啊！可以运用 eval()，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 123456789101112131415161718Function.prototype.myCall = function(Context) &#123; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = []; for (var i = 1; i &lt; arguments.length; i++&gt;) &#123; args.push('arguments[+' i '+]'); &#125; eval('Context.fn(+' args '+)'); delete Context.fn;&#125;var foo = &#123; name: 'Jack'&#125;function bar(age, goods) &#123; console.log(this.name); console.log(age); // 10 console.log(goods); // 自行车&#125;bar.myCall(foo, 10, '自行车'); 感觉很完美了，但是依旧有两小点需要注意： 当 this 为 null 时 当函数有返回值时我们先来看第一点： 12345var name = \"Jack\";function bar() &#123; console.log(this.name); // Jack&#125;bar.call(null); 当 this 为 null 时，默认走向 window第二点： 12345678910var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; return &#123; age: 1, goods: \"自行车\", &#125;;&#125;bar.call(foo); // &#123;age: 1, goods: \"自行车\"&#125; 当函数有返回值时，结果就是这个返回值。 第三步：我们对自己模拟的方法进行最后的优化：1234567891011Function.prototype.myCall = function (Context) &#123; var Context = Context ? Context : window; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; var result = eval(\"Context.fn(\" + args + \")\"); delete Context.fn; return result;&#125;; 2、applycall() 和 apply() 之间的区别，不同之处是： call() 方法分别接受参数。 apply() 方法接受数组形式的参数。 所以 call 和 apply 只是接受参数的不同，思路还是和 call 一样，这次就不重复了直接贴代码：运用解构赋值： 12345678Function.prototype.myApply = function (Context) &#123; var Context = Context ? Context : window; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = arguments[1] ? arguments[1] : []; var result = Context.fn(...args); delete Context.fn; return result;&#125;; 运用 eval： 12345678910111213141516171819Function.prototype.myApply = function (Context) &#123; var Context = Context ? Context : window; Context.fn = this; // 此时的this指向的是Function，即调用者 var args = []; var arguments = arguments[1] ? arguments[1] : []; for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; var result = eval(\"Context.fn(\" + args + \")\"); delete Context.fn; return result;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;bar.myApply(foo); 3、bindbind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind()的第一个参数, 它的参数是 bind()的其他参数和其原本的参数。所以 bind 执行两个步骤： 返回一个新函数 可以传入参数 我们按照分析 call()函数一样的思路来分析 bind()，首先看一下原先的 bind： 12345678var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;var bindFoo = bar.bind(foo);bindFoo(); // Jack 所以可以看出 bar.bind(foo);返回一个新的函数，当这个函数执行时，才返回其中的结果，那我们先模拟一下这个： 1234567891011121314Function.prototype.myBind = function (Context) &#123; var self = this; return function () &#123; return self.apply(Context); &#125;;&#125;;var foo = &#123; name: \"Jack\",&#125;;function bar() &#123; console.log(this.name);&#125;var bindFoo = bar.myBind(foo);bindFoo(); // Jack 结果一样，说明这一步模拟的没有问题。那我们进行下一步的模拟，因为 bind 也是可以携带参数的，携带参数的方式和 call 相同： 12345678910var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); console.log(goods);&#125;var bindFoo = bar.bind(foo, 1, \"1\");bindFoo(); // Jack 1 1 模拟板升级： 1234567Function.prototype.myBind = function (Context) &#123; var self = this; var args = [].slice.call(arguments, 1); return function () &#123; return self.apply(Context, args); &#125;;&#125;; 很完美，但是 bind 有个特点被忽视了，因为 bind 返回一个新的函数，那我们将返回的函数里面传参，会有什么效果，我们看一下： 12345678910var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); console.log(goods);&#125;var bindFoo = bar.bind(foo, 1);bindFoo(\"1\"); // Jack 1 1 可以看出 bind 可以只传入 age，然后再从返回的新函数中传入 goods，那我们需要把上述模拟进行升级： 12345678Function.prototype.myBind = function (Context) &#123; var self = this; var args = [].slice.call(arguments, 1); return function () &#123; var bindArgs = [].slice.call(arguments); return self.apply(Context, args.concat(bindArgs)); &#125;;&#125;; 思路其实很简单，就是将两个 arguments 进行合并。本以为这样就结束了，但是 MDN 提到了 bind 的另外一个特点：绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。什么意思呢？用代码演示一下： 123456789101112var foo = &#123; name: \"Jack\",&#125;;function bar(age, goods) &#123; console.log(this.name); console.log(age); console.log(goods);&#125;bar.prototype.friends = \"a\";var BindFoo = bar.bind(foo, 1);var bindFoo = new BindFoo(\"1\"); // undefined 1 1console.log(bindFoo.friends); // a this.name 竟然输出 undefined，那是因为 new 后，BindFoo 中 this 的指向改变了，指向了 bindFoo，而 BindFoo 实际是 bar 函数，并且 bindFoo 没有 value 属性，所以就输出了 undefined，通过 instanceof 就可以看出来，bindFoo 是 BindFoo 的实例，也是 bar 的实例。 123456789101112131415Function.prototype.myBind = function (Context) &#123; var self = this; var args = [].slice.call(arguments, 1); var cacheFn = function () &#123;&#125;; var bindFun = function () &#123; var bindArgs = [].slice.call(arguments); return self.apply( this instanceof cacheFn ? this : Context, args.concat(bindArgs) ); &#125;; cacheFn.prototype = this.prototype; bindFun.prototype = new cacheFn(); return bindFun;&#125;; 我们进行分步讲解：1、为什么要判断 this instanceof bindFun？之前也说到，当将 bind 返回后函数当做构造函数时，bindFoo 即是 BindFoo 的实例也是 bar 的实例，BindFoo 即为返回来的函数，在我们模拟的代码中就是 bindFun 这个函数，并且当 new 之后 this 指向的是实例，所以用 this instanceof bindFun 判断的实际就是函数前有没有 new 这个关键词。2、为什么要继承 this 的原型？这是为了继承 bar 原型上的属性。最后一步，健壮模拟的 bind，判断传过来的 this 是否为函数，也是最终版： 1234567891011121314151617181920Function.prototype.myBind = function (Context) &#123; if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; var self = this; var args = [].slice.call(arguments, 1); var cacheFn = function () &#123;&#125;; var bindFun = function () &#123; var bindArgs = [].slice.call(arguments); return self.apply( this instanceof cacheFn ? this : Context, args.concat(bindArgs) ); &#125;; cacheFn.prototype = this.prototype; bindFun.prototype = new cacheFn(); return bindFun;&#125;;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"闭包","slug":"闭包","date":"2020-06-12T12:54:24.000Z","updated":"2020-06-25T12:03:59.588Z","comments":true,"path":"2020/06/12/闭包/","link":"","permalink":"https://tomatoesman.github.io/2020/06/12/%E9%97%AD%E5%8C%85/","excerpt":"根据《高程》中所讲：闭包是指有权访问另一个函数作用域中的变量的函数。《Javascript 权威指南》中指出，从技术角度讲，所有的 javascript 函数都是闭包。闭包，之前感觉很神秘，今天我们来揭开它的面纱，看看究竟干了什么！","text":"根据《高程》中所讲：闭包是指有权访问另一个函数作用域中的变量的函数。《Javascript 权威指南》中指出，从技术角度讲，所有的 javascript 函数都是闭包。闭包，之前感觉很神秘，今天我们来揭开它的面纱，看看究竟干了什么！ 我们举个例子： 12345678function scope() &#123; let a = 1; return function () &#123; return a; &#125;;&#125;let foo = scope();foo(); 根据前面所写的《执行上下文》中我们可以找到当解析代码时，会执行上下文栈，那我们按照执行上下文来看一下函数内部都做了哪些事情。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var scope = [];scope.push(globalContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; scope: &lt;func&gt;, foo: &lt;uninitialized&gt;, &#125;, outer: null &#125;, VR: &#123; ER: &#123;&#125;, outer: null &#125;&#125;);scope.push(&lt;scope&gt;, scopefunctionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; arguments: &#123; length: 0 &#125; &#125;, outer: &lt;globalContext&gt; &#125;, VR: &#123; ER: &#123;&#125;, outer: null &#125;&#125;);scope.pop();scope.push(&lt;foo&gt;, foofunctionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; arguments: &#123; length: 0 &#125; &#125;, outer: &lt;scopefunctionContext&gt; &#125;, VR: &#123; ER: &#123;&#125;, outer: null &#125;&#125;);scope.pop(); 其实会很好奇，scope 函数执行完后明明已经在执行栈中移除了，为什么 foo 函数依旧能访问到其内部的变量。是因为 foo 函数的对外部引用是 scope 的词法环境，这个环境还没有消失。正因为 JS 有这个特点，所以才会生成闭包这个概念。 下面举几个常用的面试题，来自《高程》： 123456789101112function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; console.log(i); &#125;; &#125; return result;&#125;createFunctions().forEach((item) =&gt; &#123; item();&#125;); 运行上述之后，发现最后输出 10 个 10，为什么不是 0-9 呢？我们来分析一下，已 result[0]为例，在 result[0]运行之前，全局上下文是这样的： 1234567891011121314151617var scope = [];scope.push(globalContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; createFunctions: &lt;func&gt;, &#125;, outer: null &#125;, VR: &#123; ER: &#123; result: [....], i: 10 &#125;, outer: null &#125;&#125;) 当 result[0]运行时，它的函数上下文发生变化： 1234567891011functionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123;&#125;, outer: &lt;createFunctionsContext&gt; &#125;, VR: &#123; ER: &#123;&#125;, outer: &lt;createFunctionsContext&gt; &#125;&#125; 由于 result[0]中没有定义 i，所以就会向外部的词法环境中查找，最后找到 i，输出 10。 如果想输出预期结果 0-9，高程中也给出了解决方案： 1234567891011121314function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = (function (num) &#123; return function () &#123; console.log(num); &#125;; &#125;)(i); &#125; return result;&#125;createFunctions().forEach((item) =&gt; &#123; item();&#125;); 当再次执行 result[0]时，这个匿名函数的上下文： 12345678910111213141516171819functionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; 匿名function: &lt;func&gt; &#125;, outer: &lt;createFunctionsContext&gt; &#125;, VR: &#123; ER: &#123; arguments: &#123; 0: 0, length: 1 &#125;, num: 0 &#125;, outer: &lt;createFunctionsContext&gt; &#125;&#125; 当匿名函数执行时： 12345678910111213141516匿名functionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123;&#125;, outer: &lt;functionContext&gt; &#125;, VR: &#123; ER: &#123; arguments: &#123; length: 0 &#125;, num: 0 &#125;, outer: &lt;functionContext&gt; &#125;&#125; 同样其内部没有 num 变量，那它就会去外部的此法环境中查找，找到了 functionContext，functionContext 内部的 num 为 0，则输出 0。这样就完美解决了这个问题，也体现了闭包的作用，但现在有 let 了这种就用的很少了。闭包虽然能解决一些问题，但是尽量还是要少用闭包，因为其外部的词法环境已经销毁了，但其内部还在引用，这样的话闭包过多会造成内存泄漏，最简单直接的办法就是，执行完后设置为 null，这样就销毁了。","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"执行上下文","slug":"执行上下文","date":"2020-05-29T14:36:39.000Z","updated":"2020-06-25T12:03:48.155Z","comments":true,"path":"2020/05/29/执行上下文/","link":"","permalink":"https://tomatoesman.github.io/2020/05/29/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"上篇介绍完 JS 的作用域，那接下来的几篇就要讲讲跟作用域相关的内容了。","text":"上篇介绍完 JS 的作用域，那接下来的几篇就要讲讲跟作用域相关的内容了。 1、执行上下文执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文类型阅文前端团队翻译的《理解 Javascript 执行上下文和执行栈》中所说： 全局执行上下文：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。 eval 函数执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文。 2、执行上下文栈执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文，这与堆栈中栈的原理类似。 当 JS 引擎开始编译 JS 代码时，会创建一个全局执行上下文压入到执行上下文栈的最顶层，当调用一个函数时，就会创建一个函数执行上下文压入执行上下文栈的最顶层。 当最新的函数执行完毕后，其执行上下文将会从执行上下文栈弹出，然后将执行下一个函数。 我们可以将执行上下文栈模拟为一个空数组： 1stack = []; 通过下个例子来理解一下： 1234567891011121314var a = 1;function foo1() &#123; console.log(a);&#125;function foo2() &#123; foo1();&#125;function foo3() &#123; foo2();&#125;foo3(); 当执行上述例子时，先将全局执行上下文推入执行上下文栈 1stack = [globalContext]; 当函数调用的时候开始执行函数上下文： 123456789101112stack.push(&lt;foo3&gt;, functionContext);// foo3函数中调用了foo2stack.push(&lt;foo2&gt;, functionContext);// foo2函数中调用了foo1stack.push(&lt;foo1&gt;, functionContext);// foo1执行完毕stack.pop();// foo2执行完毕stack.pop();// foo1执行完毕stack.pop();// 之后再执行新的代码，但底层永远留有一个globalContext 3、执行上下文的创建在执行上下文创建的时候，分为两个阶段：1、创建阶段 2、执行阶段 3.1、创建阶段创建阶段有三个重要的属性： this 词法环境（作用域链） 变量环境 3.1.1、this在全局上下文中，this 指向的是全局对象，在浏览器中，指向的是 window在函数上下文中，this 指向的是函数的调用方，如果是对象调用该函数，则指向的是这个对象，否则 this 指向的是全局对象或者 undefined（严格模式） 123456789101112let person = &#123; name: \"Jack\", eat: function () &#123; console.log(this.name); &#125;,&#125;;person.eat(); // 此时的this指向person，因为是person调用的该函数function foo() &#123; console.log(this);&#125;foo(); // 此时的this指向window 3.1.2、词法环境（作用域链）词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用） 词法环境包括两个部分： 环境记录：存储变量和函数声明的实际位置 对外部环境的引用：意味着可以访问其外部的词法变量 在全局上下文中，对外环境的引用为 null，它拥有一个全局的对象（windowd 对象）以及其关联的属性和方法和用户自定义的全局变量。 在函数上下文中，用户自定义的变量存储在环境记录中，对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。另外在函数上下文创建时，在其环境记录中还会生成一个 arguments 对象，该对象包含了索引和传递给函数的参数之间的映射以及传递给函数的参数的长度（数量）。如下所示： 123456function add(a, b) &#123; return a + b;&#125;add(2, 3);// arguments对象Arguments: &#123;0: 2, 1: 3, length: 2&#125; 我们以一个例子，并用伪代码来看一下在词法环境中 JS 内部都做了什么： 123456var a, b = 1;function foo(a, b) &#123; return a + b;&#125;foo(2, 3); 我们用 ER 代表环境记录，用 outer 代表对外部环境的引用，伪代码写成： 1234567891011121314151617181920全局上下文：GlobalExectionContext = &#123; ER: &#123; a, b, foo &#125;, outer: null&#125;当运行函数时，会产生函数上下文：FunctionExectionContext = &#123; ER: &#123; arguments: &#123; 0: 2, 1: 3, length: 2 &#125; &#125;, outer: &lt;GlobalExectionContext&gt;&#125; 在 ES8 中规定环境记录同样拥有两个类型： 声明性环境记录：存储变量、函数和参数。一个函数环境包含声明性环境记录。 对象环境记录：用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。 3.1.3、变量环境变量环境也是一个词法环境，所以他包含了词法环境的所有特性，在 ES6 中变量环境包括两个一个是 LexicalEnvironment 组件另一个是 VariableEnvironment 组件，他俩的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。 这样我们再举例来看一下 JS 内部究竟干了什么： 1234567let a = 1;const b = 2;var c;function add(a, b) &#123; return a + b;&#125;c = add(1, 3); 我们同样用伪代码来模拟一下吗，用 LE 代表 LexicalEnvironment，用 VE 代表 VariableEnvironment： 123456789101112131415161718192021222324252627282930313233343536全局上下文：GlobalExectionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; a: &lt;uninitialized&gt;, b: &lt;uninitialized&gt;, add: &lt;func&gt; &#125;, outer: null, &#125;, VE: &#123; ER: &#123; c: undefined &#125;, outer: null, &#125;&#125;当调用add时，生成函数上下文：FunctionExectionContext = &#123; this: &lt;Global Object&gt;, LE: &#123; ER: &#123; arguments: &#123; 0: 1, 1: 3, length: 2 &#125; &#125;, outer: &lt;GlobalExectionContext&gt;, &#125;, VE: &#123; ER: null, outer: &lt;GlobalExectionContext&gt;, &#125;&#125; 此时你一定会对 let、const、var 的值有一个疑惑，那是因为在创建阶段的时候，代码会被扫描和解析成变量和函数声明，函数声明存储在环境中，而 var 会被定义为 undefined，let 和 const 会被定位为 uninitialized，这就是为什么你可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因，这个错误就是暂时性死区或者叫做临时死亡（TDZ），原因就是在访问一个已经声明但没有初始化的变量。 3.2、执行阶段在此阶段，完成对所有变量的分配，最后执行代码。注：在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。 这篇查阅了很多相关资料，但是觉得很多还是理解的不是很透彻，今后有时间会继续补充，也希望大家能多给些评价。 参考：【译】理解 Javascript 执行上下文和执行栈","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"作用域","slug":"作用域","date":"2020-05-29T14:14:37.000Z","updated":"2020-06-25T12:03:40.106Z","comments":true,"path":"2020/05/29/作用域/","link":"","permalink":"https://tomatoesman.github.io/2020/05/29/%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"何为作用域，查找度娘百科中是这么定义的： 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。","text":"何为作用域，查找度娘百科中是这么定义的： 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 1、静态作用域（词法作用域）通常来说 JS 是静态作用域，函数的作用域在函数定义的时候就已经确定了。可以举个例子： 123456789var scope = 1;function foo() &#123; console.log(scope);&#125;function bar() &#123; var scope = 2; foo();&#125;bar(); 最后输出为 1，因为 JS 是静态作用域，所以 foo 函数的作用域在其定义的时候就被确定了，当在 bar 函数中执行 foo()时，没有去查找 bar 中的 scope 变量，而是去查找 foo 函数中的 scope，当 foo 函数中没有找到这个变量的时候他会在全局中查找，所以最后输出 1。 2、动态作用域函数的作用域在函数调用的时候才决定。其实大部分的语言都是基于静态作用域的，如果 JS 是动态作用域的话，那上述例子最后的结果应该是 2 而不是 1，因为当 foo()无法找到 scope 的变量引用时，会顺着调用栈在调用 foo()的地方查找 scope，而不是在嵌套的词法作用域链中向上查找。由于 foo()是在 bar()中调用的，引擎会检查 bar()的作用域，并在其中找到值为 2 的变量 scope。看到这里有没有感觉到这个动态作用域的工作原理像极了 JS 中的 this，关于 this 的机制我们将在后续中进行讲解。 3、JS 的全局作用域、块级作用域、函数作用域3.1 全局作用域在 ES6 之前，JS 只有全局作用域和函数作用域，但是当全局作用域用的过多时就会发现一个大问题，就是全局污染，为了这个解决这个问题推出了好多方法：模块化、闭包、命名空间等等等等。什么是全局作用域？全局作用域即贯穿整个 JS 文档，在任何地方都能够访问到，JS 中有个全局对象 window，如声明一个全局变量，就相当于在 window 上添加一个属性。 3.2 块级作用域块级作用域是 ES6 中才出现的新特性，通常使用的 let、const 都是显式声明块级作用域的方法。在《你不知道的 JavaScript》中对块级作用域的总结是这样的：块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。其实我认为通俗的理解就是，在代码块中定义的变量或者函数，在其代码块外无法访问。 3.3 函数作用域函数作用域即定义在函数代码块中的变量和函数，外部无法访问。举个栗子： 1234567var a = 1;function foo() &#123; var a = 2; console.log(a);&#125;foo();console.log(a); 运行上述结果可以的出结论，foo 函数运行完后在 foo 函数中输出的为 2，在全局上输出的为 1。但是这样并不是很理想，因为 foo 函数是挂载在全局中的，也会容易造成一个全局污染的问题，其次必须显式调用(foo())才能运行函数代码，还好 JS 给我们提供了一个解决这种问题的方法，即自执行函数。可以通过自执行函数将上面的例子进行改造： 1234567var a = 1;(function foo() &#123; var a = 2; console.log(a);&#125;)();console.log(a);console.log(foo); // Uncaught ReferenceError: foo is not defined 执行结果与之前相同，当查看 foo 函数时会报 foo 没有被定义的错误。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"new关键词","slug":"new关键词","date":"2020-04-21T14:05:33.000Z","updated":"2020-06-25T11:52:45.285Z","comments":true,"path":"2020/04/21/new关键词/","link":"","permalink":"https://tomatoesman.github.io/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/","excerpt":"大部分面试的时候，面试官先已原型链铺路，随后就会问你 new 关键词都做了些什么？也是为了下一个继承问题再次铺路！那这篇文章我们就来讲讲这个 new！我们通常在什么地方能看到它，在创建实例的时候，new 后面加上一个构造函数，就是创建这个构造函数的实例。","text":"大部分面试的时候，面试官先已原型链铺路，随后就会问你 new 关键词都做了些什么？也是为了下一个继承问题再次铺路！那这篇文章我们就来讲讲这个 new！我们通常在什么地方能看到它，在创建实例的时候，new 后面加上一个构造函数，就是创建这个构造函数的实例。 首先我们创建一个构造函数，看看 new 都做了哪些事情： 1234567891011function Person() &#123; this.name = \"Jack\"; this.age = \"29\";&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = new Person();console.log(person.name); //Jackconsole.log(person.age); // 29person.eat(); // 烤鸭 我们从上述可以看出，new 关键词主要做了以下几个事情： 创建了一个新的对象， 将新对象的__proto__函数指向构造函数的 prototype，这个新对象就可以访问构造函数原型上的属性 将 this 指向改变，指向新的对象，这样就可以访问构造函数内部的属性 返回新的对象 接下来来模拟一下 new 函数： 1234567function MyNew() &#123; let obj = new Object(); Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125; 我们来验证一下写的这个方法是否正确： 1234567891011function Person() &#123; this.name = \"Jack\"; this.age = \"29\";&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = MyNew(Person);console.log(person.name); //Jackconsole.log(person.age); // 29person.eat(); // 烤鸭 输出结果一样，那忽然有个想法，构造函数毕竟是个函数，如果构造函数有返回值，那 new 后结果是怎样呢： 12345678910111213141516171819202122232425262728293031// 返回基本数据类型function Person() &#123; this.name = \"Jack\"; this.age = \"29\"; return 1;&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = new Person();console.log(person.name); //Jackconsole.log(person.age); // 29person.eat(); // 烤鸭// 返回对象function Person() &#123; this.name = \"Jack\"; this.age = \"29\"; return &#123; sex: \"nan\", like: \"nv\", &#125;;&#125;Person.prototype.eat = function () &#123; console.log(\"烤鸭\");&#125;;var person = new Person();console.log(person.name); //undefinedconsole.log(person.age); // undefinedconsole.log(person.sex); //Jackconsole.log(person.like); // 29person.eat(); // Uncaught TypeError: person.eat is not a function 当构造函数返回的是一个基本数据类型时，跟没有返回值是一样的结果，但是当返回值是一个对象时，就会真的返回这个对象，return 之前定义的属性都会失效，并且定义在原型上的属性也会失效。根据这个特性，对之前写的 MyNew 函数进行升级。 1234567function MyNew() &#123; let obj = new Object(); Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; let res = Constructor.apply(obj, arguments); return typeof res === \"object\" ? res : obj;&#125;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"继承","slug":"继承","date":"2020-04-20T02:18:58.000Z","updated":"2020-06-25T11:52:13.208Z","comments":true,"path":"2020/04/20/继承/","link":"","permalink":"https://tomatoesman.github.io/2020/04/20/%E7%BB%A7%E6%89%BF/","excerpt":"JS 是一门面向对象的语言，面向对象的三个特性：封装、继承、多态。虽然 JS 没有多态，但是继承还是有的，但是 JS 的继承只支持实现继承，实现的方式就是通过原型链。原型链我们上篇已经讲过了，所以本篇主要 JS 中几种继承的方式。","text":"JS 是一门面向对象的语言，面向对象的三个特性：封装、继承、多态。虽然 JS 没有多态，但是继承还是有的，但是 JS 的继承只支持实现继承，实现的方式就是通过原型链。原型链我们上篇已经讲过了，所以本篇主要 JS 中几种继承的方式。 1、借用构造函数实现继承这种继承方法最原始的继承，实现的非常简单就是在子类型构造函数的内部实现超类型的构造函数。可以通过 call 和 apply 来实现。 12345678910function Father() &#123; this.money = \"$1\";&#125;function Son() &#123; Father.call(this);&#125;var son1 = new Son();console.log(son1.money); // $1var son2 = new Son();console.log(son2.money); // $1 上述可见，这完全实现了继承，儿子继承了老子的钱，虽然只有 1 美元，但也是爱啊！ 但是这样有一个问题，我们来看一下： 123456789101112function Father() &#123; this.money = \"$1\";&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;var son1 = new Son();console.log(son1.money); // $1son1.makeMoney(); //Uncaught TypeError: son1.makeMoney is not a function 发现了吧，这是一个大问题啊，虽然儿子继承了老子的钱，但是没有继承老子的赚钱的能力，虽然 1 美元是一笔大款，但是没有赚钱的能力，早晚也会花光的啊！这是因为方法都在构造函数中定义，因此函数复用就无从谈起了，而且在父类的原型上定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因为这个问题，借助构造函数的技术通常都不是单独使用的。那如何实现继承父类原型上的方法呢？这就要讲到另外一个实现继承的方式了，用原型链继承。 2、原型链实现继承原型链在 JS 中是一种特殊的存在，那如何实现在原型链上的继承呢？是否想到了 new 这个关键词？new 干了哪些事情呢？这是一个经典面试题，简单的说是： 创建一个新对象 将新对象的__proto__指向构造函数的 prototype 对象 将构造函数的作用域赋值给新对象 （也就是 this 指向新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新的对象 第二条就能满足咱们的要求。所以继承父类原型链上的方法我们可以这样写： 1234567891011function Father() &#123; this.money = \"$1\";&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123;&#125;Son.prototype = new Father();var son1 = new Son(); // $1console.log(son1.money);son1.makeMoney(); // 努力工作 简直完美啊，儿子即继承了 1 美元又继承了努力赚钱的方法。但是好像忽略了一点，这个父亲好像有两个儿子，现在这个父亲不止只有钱还有很多东西，那我们将它们写成一个数组，此时小儿子偷摸的想要老父亲的自行车，老父亲允许了，让他自己拿于是： 123456789101112131415function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123;&#125;Son.prototype = new Father();var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // [\"$1\", \"手电筒\", \"冰箱\", \"自行车\"]son1.makeMoney(); // 努力工作console.log(son2.goods); // [\"$1\", \"手电筒\", \"冰箱\", \"自行车\"]son2.makeMoney(); // 努力工作 貌似有些尴尬，因为小儿子继承自行车这个事情一下子就被大儿子发现了。这是因为包含引用类型值的原型属性会被所有实例共享。这也是为什么要使用构造函数来定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个原型的实例，于是原先的实例属性也就变成了现在的原型属性。 以这个例子来说，父类的 goods 是个数组（引用数据类型），每个父类的实例都会有一个 goods 的属性，在子类通过原型链继承了父类的原型时，子类的原型就是父类的实例，那么每个子类也同样拥有了 goods 这个原型属性，就相当于在 son.prototype.goods 一样，但是由于包含引用类型的原型属性会被所有实例共享，所以当 son1 对 goods 进行修改时，son2 也会被修改。 3、组合继承组合继承就是把构造函数继承和原型链继承组合在一起，结合两者的长处。 1234567891011121314151617function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = new Father();var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // ['$1', '手电筒', '冰箱']son1.makeMoney(); // 努力工作console.log(son2.goods); // ['$1', '手电筒', '冰箱', '自行车']son2.makeMoney(); // 努力工作 终于满足了小儿子独自继承自行车的梦想。 4、组合继承的优化组合继承是 JS 中最经典的继承方式，但是上述中还有些许的缺点，会发现在创建一个子类型的实例时，会创建两次父类的实例，接下来就对这一点进行优化。上述借用原型链继承中，应用 new 关键词的目的，就是希望把父类的原型赋值给子类，那可以直接将父类的原型赋值过去，优化 1 如下： 1234567891011121314151617function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = Father.prototype;var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // ['$1', '手电筒', '冰箱']son1.makeMoney(); // 努力工作console.log(son2.goods); // ['$1', '手电筒', '冰箱', '自行车']son2.makeMoney(); // 努力工作 结果没有任何问题，也解决了调用两次父类实例的问题，但是： 1234son1.constructorƒ Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125; 子类虽然是继承父类的，但是它的实例也是一个个体啊，儿子 1 和儿子 2 都是儿子啊，怎么一下子成为老子了，这肯定不行。所以我们再次优化，优化 2： 123456789101112131415161718function Father() &#123; this.goods = [\"$1\", \"手电筒\", \"冰箱\"];&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = Object.create(Father.prototype);Son.prototype.constuctor = Son;var son1 = new Son();var son2 = new Son();son2.goods.push(\"自行车\");console.log(son1.goods); // ['$1', '手电筒', '冰箱']son1.makeMoney(); // 努力工作console.log(son2.goods); // ['$1', '手电筒', '冰箱', '自行车']son2.makeMoney(); // 努力工作 这样才算是真正优化完成。 5、原型式继承本来觉得写到上一条的时候就结束了，但是看到了《高程》里对继承的讲述，还有 ES6 继承特性的底层实现原理，觉得还是有必要好好的了解这一块的知识。 如高程所讲，提出这种继承方式的人叫道格拉斯·克罗克福德，他在 2006 年写了一篇名为《Prototypal Inheritance in Javascript》（Javascript 中原型式继承），在此书中他实现了一种新型的继承方式，这个继承方式没有使用严格意义上的构造函数，而是建造一个基准的对象，通过原型将已有的基准对象再创建一个新的对象，同时还不必因此创建自定义类型，为了实现这个目的，他创建了如下函数： 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 他在里面创建了一个临时的构造函数，然后将传入的对象赋值给这个临时构造函数的原型，最后返回这个临时构造函数的新实例。看下面这个例子： 12345678var father = &#123; money: \"$1\", goods: [\"手电筒\", \"冰箱\"],&#125;;var son1 = object(father);var son2 = object(father);son2.goods.push(\"自行车\");console.log(father.goods); // ['手电筒', '冰箱', 'John', '自行车'] 毕竟是通过原型继承，所以终究还是会有原型继承应有的问题，引用类型的属性会被共享，但是有没有感觉这个方法和 Object.create()很像，没错 object.create()就是基于这个方法建立的。 12345678var father = &#123; money: \"$1\", goods: [\"手电筒\", \"冰箱\"],&#125;;var son1 = Object.create(father);var son2 = Object.create(father);son2.goods.push(\"自行车\");console.log(father.friends); // ['手电筒', '冰箱', 'John', '自行车'] 但 Object.create()不同的是，它还有第二个参数，第二个参数是可选值，设置第二个参数时，可以指定任何属性都会覆盖原型上的同名属性。 6、寄生式继承这种继承方式同样是道格拉斯·克罗克福德提出的，有些类似于借用构造函数继承，但是同样的他利用了一个临时构造函数的思想，即所说的寄生思想，将一个对象作为基准，然后寄生在这个对象上，这样就可以拥有这个对象的所有属性和方法，封装成一个函数，在函数内部给这个对象的副本添加新的属性和方法。 1234567function createAnother(o) &#123; var clone = object(o); clone.sayHi = function () &#123; console.log(\"hi\"); &#125;; return clone;&#125; 但是这种呢，无法做到函数的复用大大降低效率。 7、寄生组合式继承前面提到的组合继承时最经典的继承方式，但是有个很重要的问题，会执行两次父类的构造函数。没事我们可以用寄生组合式继承来解决这个问题。 我们引用《高程》对寄生组合式继承解释：即通过借用构造函数来继承属性，通过原型链的混用形式来继承方法。其背后的思路是：不必为了子类型的原型而调用超类型的构造函数，我们所需要的的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。如下所示： 12345function inheritPrototype(father, son) &#123; var prototype = object(father.prototype); prototype.constructor = son; son.prototype = prototype;&#125; 这个示例实现了最简单的寄生组合式继承。它接受了两个参数，分别是父类的构造函数和子类的构造函数。在函数内部第一步是创建一个父类型原型副本，第二步是将新的副本添加 constructor，弥补因重构原型而失去的默认 constuctor 属性，第三步是将新的副本赋值给子类型的原型上。 这样我们就可以保证只执行一次父类的构造函数。 12345678910function Father() &#123; this.money = \"$1\";&#125;Father.prototype.makeMoney = function () &#123; console.log(\"努力工作\");&#125;;function Son() &#123; Father.call(this);&#125;inheritPrototype(Father, Son); 8、ES6 的继承 class…extends…以前说到继承的时候只是觉得是个语法糖，用起来很是方便，但是通过写这篇文章查阅资料时看到了其底层实现的原理。这也是写了原型式继承、寄生继承、寄生组合式继承的原因。 我们先来看一下 ES6 继承： 123456789101112131415class Father &#123; constructor() &#123; this.money = \"$1\"; this.goods = [\"手电筒\", \"冰箱\"]; &#125; makeMoney = function () &#123; console.log(\"努力工作\"); &#125;;&#125;class Son extends Father &#123; constructor() &#123; super(); &#125;&#125; 用 Bable 转成 ES5 后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465\"use strict\";function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError( \"this hasn't been initialised - super() hasn't been called\" ); &#125; return call &amp;&amp; (typeof call === \"object\" || typeof call === \"function\") ? call : self;&#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError( \"Super expression must either be null or a function, not \" + typeof superClass ); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true, &#125;, &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Father = function Father() &#123; _classCallCheck(this, Father); this.makeMoney = function () &#123; console.log(\"努力工作\"); &#125;; this.money = \"$1\"; this.goods = [\"手电筒\", \"冰箱\"];&#125;;var Son = (function (_Father) &#123; _inherits(Son, _Father); function Son() &#123; _classCallCheck(this, Son); return _possibleConstructorReturn( this, (Son.__proto__ || Object.getPrototypeOf(Son)).call(this) ); &#125; return Son;&#125;)(Father); 我们可以看到当创建类的时候，ES6 转换为 ES5 时，跟以前创建类会多一个_classCallCheck 函数，其实看名称就知道是一个检测，它接受两个参数，第一个是 this，第二个是构造函数，判断 this 是否是这个这个构造函数的实例，即 instanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，说白了就是判断调用前是否有 new 关键字，不是则抛出 Cannot call a class as a function 异常，所以能进一步可知 class 就是一个语法糖。 ES6 的继承转换为 ES5 后发现子类是一个自执行的函数，将父类作为参数传递过去。首先是_inherits 函数，同样接受两个参数，一个是子类构造函数，一个是父类构造函数。看其内部结构： 首先判断父类的类型 基于父类的原型创建一个新的对象。并通过 Object.create 的第二个参数，将新对象的构造函数指向子类，再将其赋值给子类的原型。 将子类的__proto__指向父类的构造函数 第二步是不是很熟悉，没错就是寄生组合式继承的简单版。之后是个闭包，保存父类的引用，闭包内部的实现步骤： 判断调用前是否有 new 关键字 因为_inherits 函数执行后，Son.__proto__ || Object.getPrototypeOf(Son)实际上指的就是父类的构造函数，通过 call 方法将其调用改为当前的 this _possibleConstructorReturn 函数中，首先校验 this 是否被初始化，super 是否调用，并返回父类已经赋值完的 this。 然后进行子类构造函数中的逻辑 当我们没有写子类构造函数时： 12345678910111213class Son extends Father &#123;&#125;// 转为ES5var Son = (function (_Father) &#123; _inherits(Son, _Father); function Son() &#123; _classCallCheck(this, Son); return _possibleConstructorReturn( this, (Son.__proto__ || Object.getPrototypeOf(Son)).apply(this, arguments) ); &#125; return Son;&#125;)(Father); 可见默认的构造函数中会主动调用父类构造函数，并默认把当前 constructor 传递的参数传给了父类。所以当我们声明了 constructor 后必须主动调用 super(),否则无法调用父构造函数，无法完成继承。本篇就先写到这吧，欢迎留言讨论。 参考资料： JavaScript 高级程序设计（第 3 版）","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"原型与原型链","slug":"原型和原型链","date":"2020-04-20T01:07:29.000Z","updated":"2020-06-25T11:52:26.555Z","comments":true,"path":"2020/04/20/原型和原型链/","link":"","permalink":"https://tomatoesman.github.io/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"1、创建对象","text":"1、创建对象 创建对象有几种方法： 字面量创建 123let obj = &#123; name: \"o1\",&#125;; object 构造函数创建 123let obj = new Object(&#123; name: \"o2\",&#125;); 构造函数创建 1234let Person = function () &#123; this.name = \"o3\";&#125;;let obj = new Person(); object 方法创建 1234let person = &#123; name: \"o4\",&#125;;let obj = Object.create(person); 此方法是 ES6 新出的方法，此方法的好处可以理解为继承一个对象, 添加的属性是在原型下 2、原型、构造函数、实例、原型链 每个函数都有一个 prototype 的属性，每个函数通过 prototype 属性指向的对象，我们就称之为原型对象。可能比较笼统，对原型也可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 我们可以看看对象的 prototype 到底返回的是什么： 12function Person() &#123;&#125;Person.prototype;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2020-04-17T07:23:42.000Z","updated":"2020-06-25T11:52:22.215Z","comments":true,"path":"2020/04/17/深拷贝和浅拷贝/","link":"","permalink":"https://tomatoesman.github.io/2020/04/17/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。为什么引用数据类型会出现这样的问题？第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。","text":"这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。为什么引用数据类型会出现这样的问题？第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。 1、浅拷贝12345let arr = [1, 2, 3];let new_arr = arr;arr.push(4);console.log(arr); //[1, 2, 3, 4]console.log(new_arr); //[1, 2, 3, 4] 开发时我们经常能遇到上面这种情况，当对原数组添加新值时，新数组也会发生改变，这种情况我们就称之为浅拷贝。原因是浅拷贝只拷贝引用地址，而地址都是指向了同一个对象，所以彼此之间的改变会相互影响。大部分情况下的拷贝都是浅拷贝，除了上面=（赋值）外实现浅拷贝的方法也有很多： 12345concat();slice();ES6新增：展开运算符(...)Array.from() 上述方法中 concat 会有些特殊： 12345let arr = [1, 2, 3];let new_arr = [].concat(arr);arr.push(4);console.log(arr); //[1, 2, 3, 4]console.log(new_arr); //[1, 2, 3] 上述结果显示，当改变原数组时，新数组并没有发生改变，会以为 concat 属于深拷贝的方法。但当进行下述运算时： 123456var arr = [&#123; old: \"old\" &#125;, [\"old\"]];var new_arr = arr.concat();arr[0].old = \"new\";arr[1][0] = \"new\";console.log(arr); //[&#123;old: 'new'&#125;, ['new']]console.log(new_arr); //[&#123;old: 'new'&#125;, ['new']] 所以可以得出结论，当数组元素是基本数据类型时，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们来写个函数简单实现一个浅拷贝： 12345678910let shallowCopy = (obj) =&gt; &#123; if (typeof obj !== \"object\") return; let new_obj = obj instanceof Array ? [] : &#123;&#125;; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; new_obj[key] = obj[key]; &#125; &#125; return new_obj;&#125;; 2、深拷贝深拷贝是完全拷贝一个新的对象，相当于开辟了一个新的内存空间，新旧两个对象不相互影响。实现深拷贝的方法主要有两个，一个是 JSON.parse(JSON.stringify())和还有一个是递归 123456let arr = [&#123; old: \"old\" &#125;, [\"old\"]];let new_arr = JSON.parse(JSON.stringify(arr));arr[0].old = \"new\";arr[1][0] = \"new\";console.log(arr); //[&#123;old: 'new'&#125;, ['new']]console.log(new_arr); //[&#123;old: 'old'&#125;, ['old']] 但是 JSON.parse(JSON.stringify())有个最大的问题就是，不能拷贝函数 123let arr = [&#123; old: \"old\" &#125;, function () &#123;&#125;];let new_arr = JSON.parse(JSON.stringify(arr));console.log(new_arr); //[&#123;old: 'old'&#125;, null] 我们通过递归的形式简单实现一个深拷贝： 1234567891011let deepCopy = (obj) =&gt; &#123; if (typeof obj !== Object) return; let new_obj = obj instanceof Array ? [] : &#123;&#125;; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; new_obj[key] = typeof obj[key] === \"object\" ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return new_obj;&#125;;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"类型转换","slug":"类型转换","date":"2020-04-17T03:38:47.000Z","updated":"2020-07-21T14:43:54.567Z","comments":true,"path":"2020/04/17/类型转换/","link":"","permalink":"https://tomatoesman.github.io/2020/04/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"1、显示类型转换显示类型转换顾名思义就是用特有的方法对类型进行转换显示类型转换的方式只有三种：","text":"1、显示类型转换显示类型转换顾名思义就是用特有的方法对类型进行转换显示类型转换的方式只有三种： 1、Number() 原始类型转换 数值：转换后还是数值 字符串：如果可以被解析为数值，则转化为相应的数值会忽略所有前导的 0，否则得到 NaN，空字符串为 0 1Number(\"000001\"); //1 布尔值：true 转成 1，false 转成 0 undefined：转成 NaN null：转成 0 对象类型转换 先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤 如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤 如果 toString 方法返回的是复合类型的值，则报错 parseInt 和 parseFloat parseInt：只解析整数，当传入的值以‘0x’或‘0X’开头时，会解析成十六进制数 parseFloat：既可以解析整数又可以解析浮点数 共同点：都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN 2、String() 原始类型转换 数值：转为相应的字符串 字符串：转换后还是原来的值 布尔值：true 转为‘true’，false 转为‘false’ undefined：转为‘undefined null：转为‘null’ 对象类型转换 先调用 toString 方法，如果 toString 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤 如果 toString 方法返回的是复合类型的值，再调用 valueOf 方法，如果 valueOf 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤 如果 valueOf 方法返回的是复合类型的值，则报错 JSON.stringify()JSON.stringify 底层也是调用了 toString 方法 3、Boolean()undefined、null、-0、+0、NaN、’’（空字符串）返回的都是 false，除了上述的都是返回 true，包括对象类型 2、隐式类型转换隐式类型转换同样有三种： 1、+（加号）1.1 一元+（加号）运算符查看ES5 规范 11.4.6可以看到，当+（加号）作为一元运算符时，底层会调用 ToNumber 方法去处理，相当于 Number()，当+（加号）后是普通数值时，返回的就是 Number(数值) 1+\"1\"; //1 当+（加号）后是对象类型时，对象类型就会像显示类型中所讲： 先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤 如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤 如果 toString 方法返回的是复合类型的值，则报错 12+[]; //0 []先调用valueof方法返回[]，再调用toString方法返回\"\"+&#123;&#125;; //NaN &#123;&#125;相当于new Object() 先调用valueof方法返回&#123;&#125;，再调用toString方法返回\"[object Object]\" 1.2 二元+（加号）运算符查看ES5 规范 11.6.1可以看到当 value1+value2 时： 1. lprim = ToPrimitive(value1) 2. rprim = ToPrimitive(value2) 3. 如果 lprim 和 rprim 都是 String 类型时，则直接返回 ToString(lprim)和 ToString(rprim)拼接结果 4. 返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果ToPrimitive、ToString、ToNumber 三者皆为内部函数: ToPrimitive 执行的步骤： 如果 obj 为基本类型，直接返回 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 ToString 相当于 String() ToNumber 相当于 Number() 按上述规范，对下列几个例子进行讲解： 12345null + 1; //1//1、lprim = ToPrimitive(null) 因为null为基本数据类型，所以返回null//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1//3、lprim和lprim都不是String类型，所以执行第四部//4、ToNumber(null)+ToNumber(1),所以返回为1 12345undefined + 1; //NaNnull//1、lprim = ToPrimitive(undefined) 因为undefined为基本数据类型，所以返回undefined//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1//3、lprim和lprim都不是String类型，所以执行第四部//4、ToNumber(undefined)+ToNumber(1),所以返回为NaN 1234[] + []; //''//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''//2、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''//3、lprim和lprim都是String类型，所以直接返回拼接，结果为'' 1234[] + &#123;&#125;; //'[object Object]'//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''//2、lprim = ToPrimitive(&#123;&#125;) &#123;&#125;的valueof为&#123;&#125;不是基本数据类型，再调用toString方法返回的是'[object Object]'//3、lprim和lprim都是String类型，所以直接返回拼接，结果为'[object Object]' 123&#123;&#125; + []; //0//按照规范来说，这个的结果应该和上一个一样，但是为什么会出现如此的不同，是因为在浏览器中，&#123;&#125;相当于一个独立的代码块，所以浏览器认为&#123;&#125;+[]相当于+[]，所以返回0//如果想返回和上一个一样的结果的话可以在表达式外加括号,(&#123;&#125; + [])这样就返回正常的结果了 1&#123;&#125; + &#123;&#125;; //谷歌返回'[object Object][object Object]' 火狐返回NaN 2、比较运算2.1 ==相等同样我们查看ES5 规范 11.9.3中所讲：比较 x == y，其中 x 和 y 是值，产生 true 或 false。这样的比较执行如下： 1. 如果 x,y 类型相同，则 a. 如果 x 是 Undefined，则返回 true。 b. 如果 x 为 Null，则返回 true。 c. 如果 x 是数字，则 i. 如果 x 为 NaN，则返回 false。 ii. 如果 y 为 NaN，则返回 false。 iii. 如果 x 与 y 相同，则返回 true。 iv. 如果 x 为+0 且 y 为 − 0，则返回 true。 v. 如果 x 为 − 0 且 y 为+0，则返回 true。 vi.返回 false。 d. 如果 x 类型为 String，则如果 x 和 y 是完全相同的字符序列（相同的长度和相同位置的相同字符），则返回 true。否则，返回 false。 e. 如果 x 类型为布尔值，则如果 x 和 y 均为 true 或均为 false，则返回 true。否则，返回 false。 f. 如果 x 和 y 指向同一对象，则 返回 true。否则，返回 false。 2. 如果 x 是 Null 和 y 是 Undefined 的，返回 true。 3. 如果 X 是 Undefined 和 y 为 Null，返回 true。 4. 如果 x 类型是 Number 且 y 类型是 String，则返回比较结果 x == ToNumber（y）。 5. 如果 x 类型为 String 且 y 类型为 Number，则返回比较结果 ToNumber（x）== y。 6. 如果 x 类型为布尔值，则返回比较结果 ToNumber（x）== y。 7. 如果 y 类型为布尔型，则返回比较结果 x == ToNumber（y）。 8. 如果 x 类型是 String 或 Number 且 y 类型是 Object，则返回比较结果 x == ToPrimitive（y）。 9. 如果 x 类型是 Object 并且 y 类型是 String 或 Number，则返回比较结果 ToPrimitive（x）== y。 10. 返回 false。按上述规范，对下列几个例子进行讲解： 123undefined == undefined; //truenull == null; //ture//查看上述的1.a、1.b条 12NaN == NaN; //false//查看上述的1.c.i条 123undefined == null; //truenull == undefined; //ture//查看上述的2、3条 1231 == \"1\"; //true\"1\" == 1; //ture//查看上述的4、5条 123false == 0; //true0 == false; //ture//查看上述的6、7条 123[] == 0; //true0 == []; //ture//查看上述的8、9条 2.2 &lt;判断同样我们查看ES5 规范 11.8.5中所讲：比较 x &lt; y（其中 x 和 y 是值）会产生 true，false 或 undefined（这表明至少一个操作数是 NaN）。除 x 和 y 外，该算法还使用名为 LeftFirst 的布尔标志 作为参数。该标志用于控制对 x 和 y 进行具有潜在可见副作用的操作的顺序 。这是必需的，因为 ECMAScript 指定了从左到右的表达式求值。LeftFirst 的默认值 为 true，表示 x 参数对应于 y 参数对应表达式左侧出现的表达式。如果 LeftFirst 为假，则相反，操作必须在 x 之前对 y 执行。这样的比较执行如下： 1. 如果LeftFirst标志为true，则 a. 设 px为调用ToPrimitive的结果（x，Number）。 b. 令 py为调用ToPrimitive的结果（y，Number）。 2. 否则需要颠倒评估顺序以保留从左到右的评估 a. 令 py为调用ToPrimitive的结果（y，Number）。 b. 设 px为调用ToPrimitive的结果（x，Number）。 3. 如果px和py都不是String类型，则 a. 令 nx为调用ToNumber（px）的结果。因为px和py是原始值，所以评估顺序并不重要。 b. 令 ny为调用ToNumber（py）的结果。 c. 如果 nx是NaN，则返回undefined。 d. 如果 ny是NaN，则返回undefined。 e. 如果 nx和ny是相同的Number值，则返回false。 f. 如果 nx为+0且ny为− 0，则返回false。 g. 如果 nx为− 0 且ny为+0，则返回false。 h. 如果 nx为+ ∞，则返回false。 i. 如果 ny为+ ∞，则返回true。 j. 如果 ny为-∞，则返回false。 k. 如果 nx为-∞，则返回true。 l. 如果nx的数学值小于ny的数学值（请注意，这些数学值都是有限的且不都是零），则返回true。否则，返回 false。 4. 否则，px和py都是字符串 a. 如果 py是px的前缀，则返回false。（如果q 可以是连接p和其他String r的结果，则String值p是String值q的前缀。请注意，任何String都是其自身的前缀，因为r 可能是空String。） b. 如果 px是py的前缀，则返回true。 c. 令 k为最小的非负整数，以使px内的位置k处的字符不同于py内的位置k处的字符。（必须有一个k，因为String都不是另一个的前缀。） d. 设m为整数，表示字符在px内位置k处的代码单位值。 e. 设n为整数，表示字符在py中位置k处的代码单位值。 f. 如果 m &lt; n，则返回true。否则，返回 false。按上述规范，对下列几个例子进行讲解： 12[] &lt; []; //false// 以我理解为首先LeftFirst发现左边为false，而后颠倒发现左边依旧为false，则相当于fasle&lt;fasle 最后结果为fasle 12[] &lt; &#123;&#125;; //ture// 相当于''和'[object Object]'进行比较，则明显空字符串小 参考：冴羽：JavaScript 深入之头疼的类型转换(上)冴羽：JavaScript 深入之头疼的类型转换(下)","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]},{"title":"js基础类型和引用类型","slug":"js基础类型和引用类型","date":"2020-04-08T14:14:00.000Z","updated":"2020-06-25T11:52:41.341Z","comments":true,"path":"2020/04/08/js基础类型和引用类型/","link":"","permalink":"https://tomatoesman.github.io/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型","text":"开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型 1、什么是基础类型（值类型、原始类型）保存在栈中的类型就是基础类型，原因是基础类型存储的空间很小，存放在栈中方便查找，且不易于改变 js 中的基础类型（值类型、原始类型）有哪些12Undefined、Null、Boolean、Number、String、Symbol（ES6中新加类型）// undefined和null是所有类型的子类型 2、什么是引用类型指有多个值构成的对象，引用数据类型是存储在堆中，也就是说存储的变量处的值是一个指针，指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度 js 中的引用类型有哪些1Object; 3、如何判断类型3.1 typeof具体使用： 12345678910111213console.log(typeof a); //'undefined'console.log(typeof true); //'boolean'console.log(typeof \"123\"); //'string'console.log(typeof 123); //'number'console.log(typeof NaN); //'number'console.log(typeof null); //'object'let obj = new String();console.log(typeof obj); //'object'let fn = function () &#123;&#125;;console.log(typeof fn); //'function'console.log(typeof class c &#123;&#125;); //'function'let sym = Symbol();console.log(typeof sym); //'symbol' 实现原理如下： 1不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。 所以 typeof null 的返回值是 object，这是个“历史遗留问题”。因为 typeof 判断引用类型时不太准确，所以我们选用其他方法。 3.2 instanceof通常来说，instanceof 是判断一个实例是否属于某种类型具体使用： 123456console.log(1 instanceof Number); //falseconsole.log(\"1\" instanceof String); //falseconsole.log(true instanceof Boolean); //falseconsole.log(function Foo() &#123;&#125; instanceof Function); //trueconsole.log(&#123;&#125; instanceof Object); //trueconsole.log([] instanceof Array); //true 从以上结果可以看出，instanceof 对引用类型来说判断的非常准确，但是对于基础类型却不能精准的判断。原因是 instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型的实例，1、‘1’、true 并不是实例，所以为 false。如下所示： 123console.log(new Number(1) instanceof Number); //trueconsole.log(new String(\"1\") instanceof String); //trueconsole.log(new Boolean(true) instanceof Boolean); //true 但是对 undefined 和 null，却比较特殊 12console.log(new null() instanceof Null); //Uncaught TypeError: null is not a constructorconsole.log(new undefined() instanceof Undefined); //Uncaught TypeError: undefined is not a constructor 原因是因为 undefined 和 null 并不是构造函数 3.3 constructor具体使用： 123456console.log((1).constructor === Number); //trueconsole.log(\"1\".constructor === String); //trueconsole.log(true.constructor === Boolean); //trueconsole.log([].constructor === Array); //trueconsole.log(&#123;&#125;.constructor === Object); //trueconsole.log(function Foo() &#123;&#125;.constructor === Function); //true 看着貌似很准确的样子，但是还是有缺陷，当创建一个对象改变他的原型的时候，就不再准确了！ 1234function Foo() &#123;&#125;Foo.prototype = new Array();let foo = new Foo();console.log(foo.constructor === Array); //true 这是因为 js 每个函数都有一个 prototype 属性，指向原型对象，对象.prototype.constructor 指向的是该对象的构造函数，当把该对象的原型对象更改时，该函数的构造对象也会更改，所以就会出现如上的问题 3.4 Object.prototype.toString.call()具体使用： 123456789console.log(Object.prototype.toString.call(1)); //[object Number]console.log(Object.prototype.toString.call(\"1\")); //[object String]console.log(Object.prototype.toString.call(true)); //[object Boolean]console.log(Object.prototype.toString.call([])); //[object Array]console.log(Object.prototype.toString.call(&#123;&#125;)); //[object Object]console.log(Object.prototype.toString.call(function Foo() &#123;&#125;)); //[object Function]console.log(Object.prototype.toString.call(undefined)); //[object Undefined]console.log(Object.prototype.toString.call(null)); //[object Null]console.log(Object.prototype.toString.call(Symbol())); //[object Symbol] 这是最准确的类型判定的方法，就算改变原型也不会有问题。具体分析一下这个方法背后的故事：每个 Object 原型上都有一个 toString 的方法，当调用这个方法的时候会执行三个步骤：1、获取对象的类名（对象类型）2、将[object、获取的对象类型]组合为字符串3、返回字符串 为什么要用 call 方法？因为 Array、String 等类型都对其继承下来原型上的 toSring 方法进行了重写，无法返回我们想要的结果，所以我们通过 call 方法，将 Object.prototype.toString 上的 Object 的指向改变，才能对类型进行精准的判断。 Object.toString 和 Object.prototype.toString 的区别？Object.toString 是 Object 构造器的方法，返回的是函数 1Object.toString(&#123;&#125;); //\"function Object() &#123; [native code] &#125;\" Object.prototype.toString 是 Object 原型上的方法，返回的是类型字符串，才是我们想要的结果 1Object.prototype.toString(&#123;&#125;); //\"[object Object]\"","categories":[{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]}],"categories":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/categories/ES6/"},{"name":"JS基础","slug":"JS基础","permalink":"https://tomatoesman.github.io/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://tomatoesman.github.io/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"https://tomatoesman.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://tomatoesman.github.io/tags/javascript/"}]}