<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js基础类型和引用类型</title>
    <url>/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型</p>
<h2 id="1、什么是基础类型（值类型、原始类型）"><a href="#1、什么是基础类型（值类型、原始类型）" class="headerlink" title="1、什么是基础类型（值类型、原始类型）"></a>1、什么是基础类型（值类型、原始类型）</h2><p>保存在栈中的类型就是基础类型，原因是基础类型存储的空间很小，存放在栈中方便查找，且不易于改变</p>
<h3 id="js-中的基础类型（值类型、原始类型）有哪些"><a href="#js-中的基础类型（值类型、原始类型）有哪些" class="headerlink" title="js 中的基础类型（值类型、原始类型）有哪些"></a>js 中的基础类型（值类型、原始类型）有哪些</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Undefined、Null、<span class="built_in">Boolean</span>、<span class="built_in">Number</span>、<span class="built_in">String</span>、<span class="built_in">Symbol</span>（ES6中新加类型）</span><br></pre></td></tr></table></figure>

<h2 id="2、什么是引用类型"><a href="#2、什么是引用类型" class="headerlink" title="2、什么是引用类型"></a>2、什么是引用类型</h2><p>指有多个值构成的对象，引用数据类型是存储在堆中，也就是说存储的变量处的值是一个指针，指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度</p>
<h3 id="js-中的引用类型有哪些"><a href="#js-中的引用类型有哪些" class="headerlink" title="js 中的引用类型有哪些"></a>js 中的引用类型有哪些</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3、如何判断类型"><a href="#3、如何判断类型" class="headerlink" title="3、如何判断类型"></a>3、如何判断类型</h2><h3 id="3-1-typeof"><a href="#3-1-typeof" class="headerlink" title="3.1 typeof"></a>3.1 typeof</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//'boolean'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"123"</span>); <span class="comment">//'string'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">//'number'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">//'number'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn); <span class="comment">//'function'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;); <span class="comment">//'function'</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">//'symbol'</span></span><br></pre></td></tr></table></figure>

<p>实现原理如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。</span><br></pre></td></tr></table></figure>

<p>所以 typeof null 的返回值是 object，这是个“历史遗留问题”。<br>因为 typeof 判断引用类型时不太准确，所以我们选用其他方法。</p>
<h3 id="3-2-instanceof"><a href="#3-2-instanceof" class="headerlink" title="3.2 instanceof"></a>3.2 instanceof</h3><p>通常来说，instanceof 是判断一个实例是否属于某种类型<br>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出，instanceof 对引用类型来说判断的非常准确，但是对于基础类型却不能精准的判断。原因是 instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型的实例，1、‘1’、true 并不是实例，所以为 false。<br>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"1"</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>但是对 undefined 和 null，却比较特殊</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">null</span>() <span class="keyword">instanceof</span> Null); <span class="comment">//Uncaught TypeError: null is not a constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">undefined</span>() <span class="keyword">instanceof</span> Undefined); <span class="comment">//Uncaught TypeError: undefined is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>原因是因为 undefined 和 null 并不是构造函数</p>
<h3 id="3-3-constructor"><a href="#3-3-constructor" class="headerlink" title="3.3 constructor"></a>3.3 constructor</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span>.constructor === <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([].constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;.constructor === <span class="built_in">Function</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>看着貌似很准确的样子，但是还是有缺陷，当创建一个对象改变他的原型的时候，就不再准确了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这是因为 js 每个函数都有一个 prototype 属性，指向原型对象，对象.prototype.constructor 指向的是该对象的构造函数，当把该对象的原型对象更改时，该函数的构造对象也会更改，所以就会出现如上的问题</p>
<h3 id="3-4-Object-prototype-toString-call"><a href="#3-4-Object-prototype-toString-call" class="headerlink" title="3.4 Object.prototype.toString.call()"></a>3.4 Object.prototype.toString.call()</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"1"</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())); <span class="comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure>

<p>这是最准确的类型判定的方法，就算改变原型也不会有问题。<br>具体分析一下这个方法背后的故事：<br>每个 Object 原型上都有一个 toString 的方法，当调用这个方法的时候会执行三个步骤：<br>1、获取对象的类名（对象类型）<br>2、将[object、获取的对象类型]组合为字符串<br>3、返回字符串</p>
<h4 id="为什么要用-call-方法？"><a href="#为什么要用-call-方法？" class="headerlink" title="为什么要用 call 方法？"></a>为什么要用 call 方法？</h4><p>因为 Array、String 等类型都对其继承下来原型上的 toSring 方法进行了重写，无法返回我们想要的结果，所以我们通过 call 方法，将 Object.prototype.toString 上的 Object 的指向改变，才能对类型进行精准的判断。</p>
<h4 id="Object-toString-和-Object-prototype-toString-的区别？"><a href="#Object-toString-和-Object-prototype-toString-的区别？" class="headerlink" title="Object.toString 和 Object.prototype.toString 的区别？"></a>Object.toString 和 Object.prototype.toString 的区别？</h4><p>Object.toString 是 Object 构造器的方法，返回的是函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.toString(&#123;&#125;); <span class="comment">//"function Object() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>

<p>Object.prototype.toString 是 Object 原型上的方法，返回的是类型字符串，才是我们想要的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;); <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2020/04/20/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝和浅拷贝</title>
    <url>/2020/04/17/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。<br>为什么引用数据类型会出现这样的问题？<br>第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。<br>所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。</p>
<h2 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> new_arr = arr;</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>开发时我们经常能遇到上面这种情况，当对原数组添加新值时，新数组也会发生改变，这种情况我们就称之为浅拷贝。<br>原因是浅拷贝只拷贝引用地址，而地址都是指向了同一个对象，所以彼此之间的改变会相互影响。<br>大部分情况下的拷贝都是浅拷贝，除了上面=（赋值）外实现浅拷贝的方法也有很多：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">concat();</span><br><span class="line">slice();</span><br><span class="line">ES6新增：</span><br><span class="line">展开运算符(...)</span><br><span class="line"><span class="built_in">Array</span>.from()</span><br></pre></td></tr></table></figure>

<p>上述方法中 concat 会有些特殊：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> new_arr = [].concat(arr);</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上述结果显示，当改变原数组时，新数组并没有发生改变，会以为 concat 属于深拷贝的方法。但当进行下述运算时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123; <span class="attr">old</span>: <span class="string">"old"</span> &#125;, [<span class="string">"old"</span>]];</span><br><span class="line"><span class="keyword">var</span> new_arr = arr.concat();</span><br><span class="line">arr[<span class="number">0</span>].old = <span class="string">"new"</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"new"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[&#123;old: 'new'&#125;, ['new']]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[&#123;old: 'new'&#125;, ['new']]</span></span><br></pre></td></tr></table></figure>

<p>所以可以得出结论，当数组元素是基本数据类型时，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。</p>
<p>我们来写个函数简单实现一个浅拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shallowCopy = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> new_obj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      new_obj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> new_obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h2><p>深拷贝是完全拷贝一个新的对象，相当于开辟了一个新的内存空间，新旧两个对象不相互影响。<br>实现深拷贝的方法主要有两个，一个是 JSON.parse(JSON.stringify())和还有一个是递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">old</span>: <span class="string">"old"</span> &#125;, [<span class="string">"old"</span>]];</span><br><span class="line"><span class="keyword">let</span> new_arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr[<span class="number">0</span>].old = <span class="string">"new"</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"new"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[&#123;old: 'new'&#125;, ['new']]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[&#123;old: 'old'&#125;, ['old']]</span></span><br></pre></td></tr></table></figure>

<p>但是 JSON.parse(JSON.stringify())有个最大的问题就是，不能拷贝函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">old</span>: <span class="string">"old"</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> new_arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[&#123;old: 'old'&#125;, null]</span></span><br></pre></td></tr></table></figure>

<p>我们通过递归的形式简单实现一个深拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deepCopy = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="built_in">Object</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> new_obj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      new_obj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">"object"</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> new_obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/2020/04/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="1、显示类型转换"><a href="#1、显示类型转换" class="headerlink" title="1、显示类型转换"></a>1、显示类型转换</h2><p>显示类型转换顾名思义就是用特有的方法对类型进行转换<br>显示类型转换的方式只有三种：</p>
<h3 id="1、Number"><a href="#1、Number" class="headerlink" title="1、Number()"></a>1、Number()</h3><ul>
<li><p>原始类型转换</p>
<ul>
<li>数值：转换后还是数值</li>
<li>字符串：如果可以被解析为数值，则转化为相应的数值会忽略所有前导的 0，否则得到 NaN，空字符串为 0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"000001"</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>布尔值：true 转成 1，false 转成 0</li>
<li>undefined：转成 NaN</li>
<li>null：转成 0</li>
</ul>
</li>
<li><p>对象类型转换</p>
<ul>
<li>先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 toString 方法返回的是复合类型的值，则报错</li>
</ul>
</li>
<li><p>parseInt 和 parseFloat</p>
<ul>
<li>parseInt：只解析整数，当传入的值以‘0x’或‘0X’开头时，会解析成十六进制数</li>
<li>parseFloat：既可以解析整数又可以解析浮点数</li>
<li>共同点：都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN</li>
</ul>
</li>
</ul>
<h3 id="2、String"><a href="#2、String" class="headerlink" title="2、String()"></a>2、String()</h3><ul>
<li><p>原始类型转换</p>
<ul>
<li>数值：转为相应的字符串</li>
<li>字符串：转换后还是原来的值</li>
<li>布尔值：true 转为‘true’，false 转为‘false’</li>
<li>undefined：转为‘undefined</li>
<li>null：转为‘null’</li>
</ul>
</li>
<li><p>对象类型转换</p>
<ul>
<li>先调用 toString 方法，如果 toString 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤</li>
<li>如果 toString 方法返回的是复合类型的值，再调用 valueOf 方法，如果 valueOf 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤</li>
<li>如果 valueOf 方法返回的是复合类型的值，则报错</li>
</ul>
</li>
<li><p>JSON.stringify()<br>JSON.stringify 底层也是调用了 toString 方法</p>
</li>
</ul>
<h3 id="3、Boolean"><a href="#3、Boolean" class="headerlink" title="3、Boolean()"></a>3、Boolean()</h3><p>undefined、null、-0、+0、NaN、’’（空字符串）返回的都是 false，除了上述的都是返回 true，包括对象类型</p>
<h2 id="2、隐式类型转换"><a href="#2、隐式类型转换" class="headerlink" title="2、隐式类型转换"></a>2、隐式类型转换</h2><p>隐式类型转换同样有三种：</p>
<h3 id="1、-（加号）"><a href="#1、-（加号）" class="headerlink" title="1、+（加号）"></a>1、+（加号）</h3><h4 id="1-1-一元-（加号）运算符"><a href="#1-1-一元-（加号）运算符" class="headerlink" title="1.1 一元+（加号）运算符"></a>1.1 一元+（加号）运算符</h4><p>查看<a href="http://es5.github.io/#x11.4.6" target="_blank" rel="noopener">ES5 规范 11.4.6</a>可以看到，当+（加号）作为一元运算符时，底层会调用 ToNumber 方法去处理，相当于 Number()，当+（加号）后是普通数值时，返回的就是 Number(数值)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="string">"1"</span>; <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当+（加号）后是对象类型时，对象类型就会像显示类型中所讲：</p>
<ul>
<li>先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 toString 方法返回的是复合类型的值，则报错</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+[]; <span class="comment">//0  []先调用valueof方法返回[]，再调用toString方法返回""</span></span><br><span class="line">+&#123;&#125;; <span class="comment">//NaN &#123;&#125;相当于new Object() 先调用valueof方法返回&#123;&#125;，再调用toString方法返回"[object Object]"</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-二元-（加号）运算符"><a href="#1-2-二元-（加号）运算符" class="headerlink" title="1.2 二元+（加号）运算符"></a>1.2 二元+（加号）运算符</h4><p>查看<a href="http://es5.github.io/#x11.6.1" target="_blank" rel="noopener">ES5 规范 11.6.1</a>可以看到当 value1+value2 时：</p>
<pre><code>1. lprim = ToPrimitive(value1)
2. rprim = ToPrimitive(value2)
3. 如果 lprim 和 rprim 都是 String 类型时，则直接返回 ToString(lprim)和 ToString(rprim)拼接结果
4. 返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果</code></pre><p>ToPrimitive、ToString、ToNumber 三者皆为内部函数:</p>
<ul>
<li><p>ToPrimitive 执行的步骤：</p>
<ol>
<li>如果 obj 为基本类型，直接返回</li>
<li>否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。</li>
<li>否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。</li>
<li>否则，JavaScript 抛出一个类型错误异常。</li>
</ol>
</li>
<li><p>ToString 相当于 String()</p>
</li>
<li><p>ToNumber 相当于 Number()</p>
</li>
</ul>
<p>按上述规范，对下列几个例子进行讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> + <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive(null) 因为null为基本数据类型，所以返回null</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都不是String类型，所以执行第四部</span></span><br><span class="line"><span class="comment">//4、ToNumber(null)+ToNumber(1),所以返回为1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="number">1</span>; <span class="comment">//NaNnull</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive(undefined) 因为undefined为基本数据类型，所以返回undefined</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都不是String类型，所以执行第四部</span></span><br><span class="line"><span class="comment">//4、ToNumber(undefined)+ToNumber(1),所以返回为NaN</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] + []; <span class="comment">//''</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都是String类型，所以直接返回拼接，结果为''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] + &#123;&#125;; <span class="comment">//'[object Object]'</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive(&#123;&#125;) &#123;&#125;的valueof为&#123;&#125;不是基本数据类型，再调用toString方法返回的是'[object Object]'</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都是String类型，所以直接返回拼接，结果为'[object Object]'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + []; <span class="comment">//0</span></span><br><span class="line"><span class="comment">//按照规范来说，这个的结果应该和上一个一样，但是为什么会出现如此的不同，是因为在浏览器中，&#123;&#125;相当于一个独立的代码块，所以浏览器认为&#123;&#125;+[]相当于+[]，所以返回0</span></span><br><span class="line"><span class="comment">//如果想返回和上一个一样的结果的话可以在表达式外加括号,(&#123;&#125; + [])这样就返回正常的结果了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + &#123;&#125;; <span class="comment">//谷歌返回'[object Object][object Object]' 火狐返回NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="2、比较运算"><a href="#2、比较运算" class="headerlink" title="2、比较运算"></a>2、比较运算</h3><h4 id="2-1-相等"><a href="#2-1-相等" class="headerlink" title="2.1 ==相等"></a>2.1 ==相等</h4><p>同样我们查看<a href="http://es5.github.io/#x11.9.3" target="_blank" rel="noopener">ES5 规范 11.9.3</a>中所讲：<br>比较 x == y，其中 x 和 y 是值，产生 true 或 false。这样的比较执行如下：</p>
<pre><code>1. 如果 x,y 类型相同，则
  a. 如果 x 是 Undefined，则返回 true。
  b. 如果 x 为 Null，则返回 true。
  c. 如果 x 是数字，则
      i. 如果 x 为 NaN，则返回 false。
      ii. 如果 y 为 NaN，则返回 false。
      iii. 如果 x 与 y 相同，则返回 true。
      iv. 如果 x 为+0 且 y 为 − 0，则返回 true。
      v. 如果 x 为 − 0 且 y 为+0，则返回 true。
      vi.返回 false。
  d. 如果 x 类型为 String，则如果 x 和 y 是完全相同的字符序列（相同的长度和相同位置的相同字符），则返回 true。否则，返回 false。
  e. 如果 x 类型为布尔值，则如果 x 和 y 均为 true 或均为 false，则返回 true。否则，返回 false。
  f. 如果 x 和 y 指向同一对象，则 返回 true。否则，返回 false。
2. 如果 x 是 Null 和 y 是 Undefined 的，返回 true。
3. 如果 X 是 Undefined 和 y 为 Null，返回 true。
4. 如果 x 类型是 Number 且 y 类型是 String，则返回比较结果 x == ToNumber（y）。
5. 如果 x 类型为 String 且 y 类型为 Number，则返回比较结果 ToNumber（x）== y。
6. 如果 x 类型为布尔值，则返回比较结果 ToNumber（x）== y。
7. 如果 y 类型为布尔型，则返回比较结果 x == ToNumber（y）。
8. 如果 x 类型是 String 或 Number 且 y 类型是 Object，则返回比较结果 x == ToPrimitive（y）。
9. 如果 x 类型是 Object 并且 y 类型是 String 或 Number，则返回比较结果 ToPrimitive（x）== y。
10. 返回 false。</code></pre><p>按上述规范，对下列几个例子进行讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的1.a、1.b条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">//false</span></span><br><span class="line"><span class="comment">//查看上述的1.c.i条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的2、3条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">"1"</span>; <span class="comment">//true</span></span><br><span class="line"><span class="string">"1"</span> == <span class="number">1</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的4、5条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的6、7条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] == <span class="number">0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == []; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的8、9条</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-lt-判断"><a href="#2-2-lt-判断" class="headerlink" title="2.2 &lt;判断"></a>2.2 &lt;判断</h4><p>同样我们查看<a href="http://es5.github.io/#x11.8.5" target="_blank" rel="noopener">ES5 规范 11.8.5</a>中所讲：<br>比较 x &lt; y（其中 x 和 y 是值）会产生 true，false 或 undefined（这表明至少一个操作数是 NaN）。除 x 和 y 外，该算法还使用名为 LeftFirst 的布尔标志 作为参数。该标志用于控制对 x 和 y 进行具有潜在可见副作用的操作的顺序 。这是必需的，因为 ECMAScript 指定了从左到右的表达式求值。LeftFirst 的默认值 为 true，表示 x 参数对应于 y 参数对应表达式左侧出现的表达式。如果 LeftFirst 为假，则相反，操作必须在 x 之前对 y 执行。这样的比较执行如下：</p>
<pre><code>1. 如果LeftFirst标志为true，则
  a. 设 px为调用ToPrimitive的结果（x，Number）。
  b. 令 py为调用ToPrimitive的结果（y，Number）。
2. 否则需要颠倒评估顺序以保留从左到右的评估
  a. 令 py为调用ToPrimitive的结果（y，Number）。
  b. 设 px为调用ToPrimitive的结果（x，Number）。
3. 如果px和py都不是String类型，则
  a. 令 nx为调用ToNumber（px）的结果。因为px和py是原始值，所以评估顺序并不重要。
  b. 令 ny为调用ToNumber（py）的结果。
  c. 如果 nx是NaN，则返回undefined。
  d. 如果 ny是NaN，则返回undefined。
  e. 如果 nx和ny是相同的Number值，则返回false。
  f. 如果 nx为+0且ny为− 0，则返回false。
  g. 如果 nx为− 0 且ny为+0，则返回false。
  h. 如果 nx为+ ∞，则返回false。
  i. 如果 ny为+ ∞，则返回true。
  j. 如果 ny为-∞，则返回false。
  k. 如果 nx为-∞，则返回true。
  l. 如果nx的数学值小于ny的数学值（请注意，这些数学值都是有限的且不都是零），则返回true。否则，返回 false。
4. 否则，px和py都是字符串
  a. 如果 py是px的前缀，则返回false。（如果q 可以是连接p和其他String r的结果，则String值p是String值q的前缀。请注意，任何String都是其自身的前缀，因为r 可能是空String。）
  b. 如果 px是py的前缀，则返回true。
  c. 令 k为最小的非负整数，以使px内的位置k处的字符不同于py内的位置k处的字符。（必须有一个k，因为String都不是另一个的前缀。）
  d. 设m为整数，表示字符在px内位置k处的代码单位值。
  e. 设n为整数，表示字符在py中位置k处的代码单位值。
  f. 如果 m &lt; n，则返回true。否则，返回 false。</code></pre><p>按上述规范，对下列几个例子进行讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] &lt; []; <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 以我理解为首先LeftFirst发现左边为false，而后颠倒发现左边依旧为false，则相当于fasle&lt;fasle 最后结果为fasle</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] &lt; &#123;&#125;; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">// 相当于''和'[object Object]'进行比较，则明显空字符串小</span></span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/159" target="_blank" rel="noopener">冴羽：JavaScript 深入之头疼的类型转换(上)</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/164" target="_blank" rel="noopener">冴羽：JavaScript 深入之头疼的类型转换(下)</a></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
