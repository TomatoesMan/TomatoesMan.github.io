<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js基础类型和引用类型</title>
    <url>/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型</p>
<h2 id="1、什么是基础类型（值类型、原始类型）"><a href="#1、什么是基础类型（值类型、原始类型）" class="headerlink" title="1、什么是基础类型（值类型、原始类型）"></a>1、什么是基础类型（值类型、原始类型）</h2><p>保存在栈中的类型就是基础类型，原因是基础类型存储的空间很小，存放在栈中方便查找，且不易于改变</p>
<h3 id="js-中的基础类型（值类型、原始类型）有哪些"><a href="#js-中的基础类型（值类型、原始类型）有哪些" class="headerlink" title="js 中的基础类型（值类型、原始类型）有哪些"></a>js 中的基础类型（值类型、原始类型）有哪些</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Undefined、Null、<span class="built_in">Boolean</span>、<span class="built_in">Number</span>、<span class="built_in">String</span>、<span class="built_in">Symbol</span>（ES6中新加类型）</span><br></pre></td></tr></table></figure>

<h2 id="2、什么是引用类型"><a href="#2、什么是引用类型" class="headerlink" title="2、什么是引用类型"></a>2、什么是引用类型</h2><p>指有多个值构成的对象，引用数据类型是存储在堆中，也就是说存储的变量处的值是一个指针，指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度</p>
<h3 id="js-中的引用类型有哪些"><a href="#js-中的引用类型有哪些" class="headerlink" title="js 中的引用类型有哪些"></a>js 中的引用类型有哪些</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3、如何判断类型"><a href="#3、如何判断类型" class="headerlink" title="3、如何判断类型"></a>3、如何判断类型</h2><h3 id="3-1-typeof"><a href="#3-1-typeof" class="headerlink" title="3.1 typeof"></a>3.1 typeof</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//'boolean'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"123"</span>); <span class="comment">//'string'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">//'number'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">//'number'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn); <span class="comment">//'function'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;); <span class="comment">//'function'</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">//'symbol'</span></span><br></pre></td></tr></table></figure>

<p>实现原理如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。</span><br></pre></td></tr></table></figure>

<p>所以 typeof null 的返回值是 object，这是个“历史遗留问题”。<br>因为 typeof 判断引用类型时不太准确，所以我们选用其他方法。</p>
<h3 id="3-2-instanceof"><a href="#3-2-instanceof" class="headerlink" title="3.2 instanceof"></a>3.2 instanceof</h3><p>通常来说，instanceof 是判断一个实例是否属于某种类型<br>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出，instanceof 对引用类型来说判断的非常准确，但是对于基础类型却不能精准的判断。原因是 instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型的实例，1、‘1’、true 并不是实例，所以为 false。<br>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"1"</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>但是对 undefined 和 null，却比较特殊</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">null</span>() <span class="keyword">instanceof</span> Null); <span class="comment">//Uncaught TypeError: null is not a constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">undefined</span>() <span class="keyword">instanceof</span> Undefined); <span class="comment">//Uncaught TypeError: undefined is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>原因是因为 undefined 和 null 并不是构造函数</p>
<h3 id="3-3-constructor"><a href="#3-3-constructor" class="headerlink" title="3.3 constructor"></a>3.3 constructor</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span>.constructor === <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([].constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;.constructor === <span class="built_in">Function</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>看着貌似很准确的样子，但是还是有缺陷，当创建一个对象改变他的原型的时候，就不再准确了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这是因为 js 每个函数都有一个 prototype 属性，指向原型对象，对象.prototype.constructor 指向的是该对象的构造函数，当把该对象的原型对象更改时，该函数的构造对象也会更改，所以就会出现如上的问题</p>
<h3 id="3-4-Object-prototype-toString-call"><a href="#3-4-Object-prototype-toString-call" class="headerlink" title="3.4 Object.prototype.toString.call()"></a>3.4 Object.prototype.toString.call()</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"1"</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())); <span class="comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure>

<p>这是最准确的类型判定的方法，就算改变原型也不会有问题。<br>具体分析一下这个方法背后的故事：<br>每个 Object 原型上都有一个 toString 的方法，当调用这个方法的时候会执行三个步骤：<br>1、获取对象的类名（对象类型）<br>2、将[object、获取的对象类型]组合为字符串<br>3、返回字符串</p>
<h4 id="为什么要用-call-方法？"><a href="#为什么要用-call-方法？" class="headerlink" title="为什么要用 call 方法？"></a>为什么要用 call 方法？</h4><p>因为 Array、String 等类型都对其继承下来原型上的 toSring 方法进行了重写，无法返回我们想要的结果，所以我们通过 call 方法，将 Object.prototype.toString 上的 Object 的指向改变，才能对类型进行精准的判断。</p>
<h4 id="Object-toString-和-Object-prototype-toString-的区别？"><a href="#Object-toString-和-Object-prototype-toString-的区别？" class="headerlink" title="Object.toString 和 Object.prototype.toString 的区别？"></a>Object.toString 和 Object.prototype.toString 的区别？</h4><p>Object.toString 是 Object 构造器的方法，返回的是函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.toString(&#123;&#125;); <span class="comment">//"function Object() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>

<p>Object.prototype.toString 是 Object 原型上的方法，返回的是类型字符串，才是我们想要的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;); <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
