<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Async和Await</title>
    <url>/2020/07/06/Async%E5%92%8CAwait/</url>
    <content><![CDATA[<p>async 是 ES7 提出的新特性，说白了就是 Generator 的语法糖。<br>既然是语法糖，那我们首先说一下它的改进之处。</p>
<h2 id="1、async-对-Generator-的改进"><a href="#1、async-对-Generator-的改进" class="headerlink" title="1、async 对 Generator 的改进"></a>1、async 对 Generator 的改进</h2><a id="more"></a>

<h4 id="1-1、写法改进"><a href="#1-1、写法改进" class="headerlink" title="1.1、写法改进"></a>1.1、写法改进</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Generator函数;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Async函数;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比发现，async 函数在写法上，是将 Generator 函数的星号换成了 async 关键词，yield 关键词换成了 await。</p>
<h4 id="1-2、-内置执行器"><a href="#1-2、-内置执行器" class="headerlink" title="1.2、 内置执行器"></a>1.2、 内置执行器</h4><p>Generator 函数的执行必须依靠执行器，而 async 函数自带执行器。所以 async 函数不用像 Generator 函数一样要用 next 方法才会执行，完全可以跟普通函数一样。</p>
<h4 id="1-3、-更好的实用性"><a href="#1-3、-更好的实用性" class="headerlink" title="1.3、 更好的实用性"></a>1.3、 更好的实用性</h4><p>co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<h4 id="1-4、-返回值为-Promise"><a href="#1-4、-返回值为-Promise" class="headerlink" title="1.4、 返回值为 Promise"></a>1.4、 返回值为 Promise</h4><p>async 函数返回的是一个 Promise 对象，可以试用 then 方法，不像 Generator 函数返回的是一个 Iterator 对象。</p>
<h2 id="2、async-基本用法"><a href="#2、async-基本用法" class="headerlink" title="2、async 基本用法"></a>2、async 基本用法</h2><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句，并且 await 必须要在 async 函数中，不然就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="string">"b"</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上述可以看出，async 函数中 return 语句返回的值，会成为 then 回调函数的参数。<br>当 async 函数中抛出错误时，会作为 catch 函数的参数传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// Error: 出错</span></span><br></pre></td></tr></table></figure>

<h2 id="3、await-表达式"><a href="#3、await-表达式" class="headerlink" title="3、await 表达式"></a>3、await 表达式</h2><p>通常来说 await 后边大部分都是 Promise 对象，当时 Promise 对象时，返回的是 Promise 对象 resolved 状态下的结果，如果是基本数据类型时，就是直接返回该结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当 await 后边是一个 thenable 对象是，会被当做是 Promise 对象一样处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">  then: <span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="string">"2"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> thenable;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>await 后面的 Promise 对象出现错误时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">"出错了"</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>当有多个 await 时，只要其中一个 await 后的 Promise 报错，那该表达式之后的所有语句将不再执行。如果想要执行之后的语句的话，可以使用 try…catch…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">"出错了"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 出错了</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)) <span class="comment">// 1</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>除此之外还有一种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">"出错了"</span>).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// 出错了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)) <span class="comment">// 1</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>因为 catch 抓的是它之前的错误。<br>值得注意的是，如果有多个 await 时，这几个 await 并不是同时触发，而是继发，即上一条 await 后的 Promise 成功后再触发下一条 await，如果想同时触发的话，可选用 Promise.all 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [a, b] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="number">2</span>)),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">return</span> [a, b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Generator</title>
    <url>/2020/07/02/Generator/</url>
    <content><![CDATA[<p>Generator 是 ES6 提出的一种异步编程的解决办法，它与传统的函数完全不同，本章从基础概念和基本用法进行讲解和解析。在此之前也是对 Generator 函数云里雾里，所以通过此次学习，希望能对 Generator 有更深的理解和认识。</p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>Generator 中文的意思是’生成器’，<a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">阮一峰：ECMAScript 6 入门</a>中对 Generator 解释是：<br>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<a id="more"></a>

<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>Generator 有两个特点：<br>第一个是在定义时，要在 function 关键字和函数名中加一个星号，第二个就是在函数体中运用 yeild 表达式表示不同的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br></pre></td></tr></table></figure>

<p>和普通函数不同的是，当运行这个函数时，返回不是这个函数的结果，而是一个遍历器对象，或者可以说是一个含有内部状态指针的对象。<br>如果想输出值得话，要用 next 方法来进行输出。next 方法就是向下移动指针，即每次调用 next 方法，就是从函数头部或者从上一次 yield 表达式移动到下一次 yield 表达式（或者 return 为止）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line">f.next(); <span class="comment">// &#123;value: "a", done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: "b", done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述可以看出，调用 next 时输出的是一个对象，即 value 值代表 yield 后面的结果，done 代表遍历还没有结束，当遍历结束时，value 值都为 undefined，done 都为 true。</p>
<h2 id="2-yield-表达式"><a href="#2-yield-表达式" class="headerlink" title="2.yield 表达式"></a>2.yield 表达式</h2><p>yield 有个懒惰的特性，即 yield 后面的表达式，如果不调用 next 方法，是不会执行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo().next(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>只有当 next 指针移动到该 yield 的时候，才会执行后面的表达式。<br>yield 和 return 是有不同之处的，在 Generator 函数中，可以定义多个 yield 表达式，但是 return 只能定义一个，并且在 yield 中遍历还没有完成，但在遇到 return 时，遍历就终止了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line">f.next(); <span class="comment">// &#123;value: "a", done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: "b", done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: "c", done: true&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>当遇到 return 时，遍历结束 done 为 true，value 值为 return 后的结果，在此之后的 next 的结果都为{value: undefined, done: true}。<br>如果在 Generator 函数中没有 yield 表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line">f.next();</span><br></pre></td></tr></table></figure>

<p>foo()返回的依旧是一个含有内部状态指针的对象，只有当 next 方法执行时该函数才会执行。<br>当 yield 和其他表达式融合时，如果 yield 表达式在左边，要将 yield 表达式用圆括号包裹，否则就会报语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>+ <span class="keyword">yield</span> <span class="string">'b'</span>); <span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>+ (<span class="keyword">yield</span> <span class="string">'b'</span>)); <span class="comment">// &#123;value: "b", done: false&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line">f.next();</span><br></pre></td></tr></table></figure>

<p>当用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">"a"</span>, <span class="keyword">yield</span> <span class="string">"b"</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-next-方法"><a href="#3-next-方法" class="headerlink" title="3.next 方法"></a>3.next 方法</h2><p>yield 是没有返回值的，它的返回值是 undefined，我们可以通过 next 方法将参数传递给 yield，此参数将会为 yield 的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line">g.next(); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 表达式，变量 reset 的值总是 undefined。当 next 方法带一个参数 true 时，变量 reset 就被重置为这个参数（即 true），因此 i 会等于-1，下一轮循环就会从-1 开始递增。<br>不用 next 方法是否可以输出值呢？答案是可以的，可以用 for…of…方法遍历 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，for…of…在 done 为 ture 的时候就会终止执行，所以 return 后的 6 没有输出。</p>
<h2 id="4-yield-表达式"><a href="#4-yield-表达式" class="headerlink" title="4.yield* 表达式"></a>4.yield* 表达式</h2><p>yield* 表达式是为了解决在一个 Generator 函数中调用另一个 Generator 函数所提供的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo1();</span><br><span class="line">&#125;</span><br><span class="line">等同于;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo1()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 yield*后边的 Generator 函数中没有 return 时，作用就是 for…of…遍历 Generator 函数，如果 Generator 函数中有 return 时，则获取的是 return 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="keyword">yield</span>* foo1();</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// 5 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>其实 yield*后面只要是带有 Iterator 接口的都会被遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo();</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>

<p>再举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"b"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"END"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* func();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">[...bar(foo)];</span><br><span class="line"><span class="comment">// END</span></span><br><span class="line"><span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure>

<p>上述中 foo 是拥有 return 表达式的函数，所以 return 后的结果会‘赋值’给 yield*表达式的返回值，所以 result 是’END’，并且拓展运算符默认调用 Iterator 接口，所以会先打印出 result，然后再执行 yield。</p>
<p>参考：<br><a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">阮一峰：ECMAScript 6 入门</a></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Set和Map</title>
    <url>/2020/07/09/Set%E5%92%8CMap/</url>
    <content><![CDATA[<p>ES6 新增了两个数据结构，一个是 set，另外一个是 map。</p>
<h2 id="1、set"><a href="#1、set" class="headerlink" title="1、set"></a>1、set</h2><p>在《你不知道的 JavaScript(下卷)》中是这么定义的：set 是一个值的集合，其中的值唯一（重复会被忽略）。<br>它类似于数组，但是每个成员的值是唯一的。</p>
<a id="more"></a>

<p>set 是一个构造函数，可以通过 new 来创建一个 set 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 1, 4]);</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上述可以看出，new Set 会自动过滤掉重复值，并返回一个集合，我们可以利用这个特性，来写出简单的数组去重。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 1, 4]);</span><br><span class="line">let arr = [...<span class="keyword">set</span>];</span><br><span class="line">console.log(arr); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>set 通过 add()来增加成员，将新值放在集合尾部，如果新值跟原集合中的成员重复的话，会被自动过滤掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 1, 4]);</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 1, 4]);</span><br><span class="line"><span class="keyword">set</span>.add(0);</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 的构造函数可以接受一个具有 Iterable 接口的其他数据结构作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set("string");</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;<span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"r"</span>, <span class="string">"i"</span>, <span class="string">"n"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">set</span> = new Set(arguments);</span><br><span class="line">  console.log(<span class="keyword">set</span>); // &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2、set-的-API"><a href="#2、set-的-API" class="headerlink" title="2、set 的 API"></a>2、set 的 API</h2><p>set 的实例属性有两个：</p>
<ol>
<li>Set.prototype.constructor：构造函数，默认就是 Set 函数。</li>
<li>Set.prototype.size： 返回 Set 对象中的值的个数。</li>
</ol>
<p>实例方法分为两类，一个是操作类，一个是遍历类。<br>操作类：</p>
<ol>
<li>Set.prototype.add(value)：在 Set 对象尾部添加一个元素。返回该 Set 对象。</li>
<li>Set.prototype.clear()：移除 Set 对象内的所有元素。</li>
<li>Set.prototype.delete(value)：移除 Set 的中与这个值相等的元素，返回 Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回 true，否则返回 false）。Set.prototype.has(value)在此后会返回 false。</li>
<li>Set.prototype.has(value)：返回一个布尔值，表示该值在 Set 中存在与否。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;&#125;</span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">let result = <span class="keyword">set</span>.delete(1);</span><br><span class="line">console.log(result); // true</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">let result = <span class="keyword">set</span>.has(1);</span><br><span class="line">console.log(result); // true</span><br></pre></td></tr></table></figure>

<p>遍历类：</p>
<ol>
<li>Set.prototype.values()：返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.keys()：与 values()方法相同，返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。</li>
<li>Set.prototype.forEach(callbackFn[, thisArg])：按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。如果提供了 thisArg 参数，回调中的 this 会是这个参数。</li>
<li>Set.prototype.entries()：返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和 Map 对象保持相似，每个值的键和值相等。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">let keys = <span class="keyword">set</span>.keys();</span><br><span class="line">console.log(keys); // &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">let values = <span class="keyword">set</span>.values();</span><br><span class="line">console.log(values); // &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个例子，因为 Sset 没有键名，只有值，所以 keys 和 values 的结果是一样的。<br>Set 同样拥有 forEach 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span>.forEach((key, value) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1:1</span></span><br><span class="line"><span class="comment">// 2:2</span></span><br><span class="line"><span class="comment">// 3:3</span></span><br></pre></td></tr></table></figure>

<p>跟数组的 forEach 方法不同的是，它的回调函数的参数是其 key 值和 value 值，但是 Set 没有 key 值，所以其 key 和 value 相等。forEach 的第二个参数是 this 值，其绑定的是回调函数中的 this 值。<br>最后一个实例方法是 entries：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">let entries = <span class="keyword">set</span>.entries();</span><br><span class="line">console.log(entries);</span><br><span class="line">// &#123;</span><br><span class="line"><span class="comment">//   [1, 1],</span></span><br><span class="line"><span class="comment">//   [2, 2],</span></span><br><span class="line"><span class="comment">//   [3, 3]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>enteries()返回一个遍历器，返回一个键值对，但其键值对均相等。</p>
<h2 id="3、WeakSet"><a href="#3、WeakSet" class="headerlink" title="3、WeakSet"></a>3、WeakSet</h2><p>WeakSet 也是一个构造函数，与 Set 一直，WeakSet 和 Set 两者相似但不同，不同点主要有两个：</p>
<ol>
<li>WeakSet 的成员值必须是对象（可迭代的对象），而并不像 set 一样可以是原生类型值。</li>
<li>WeakSet 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 WeakSet 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// Uncaught TypeError: Invalid value used in weak set</span></span><br><span class="line"><span class="keyword">let</span> weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">]); <span class="comment">// &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure>

<p>WeakSet 有三个实例方法：</p>
<ol>
<li>WeakSet.prototype.add(value)：返回构造函数即 WeakSet 本身。</li>
<li>WeakSet.prototype.delete(value)：从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false。</li>
<li>WeakSet.prototype.has(value)：返回一个布尔值, 表示给定的值 value 是否存在于这个 WeakSet 中。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(foo);</span><br><span class="line">ws.add(bar);</span><br><span class="line"></span><br><span class="line">ws.has(foo); <span class="comment">// true</span></span><br><span class="line">ws.has(bar); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">ws.delete(foo); <span class="comment">// 从set中删除 foo 对象</span></span><br><span class="line">ws.has(foo); <span class="comment">// false, foo 对象已经被删除了</span></span><br><span class="line">ws.has(bar); <span class="comment">// true, bar 依然存在</span></span><br></pre></td></tr></table></figure>

<h2 id="4、Map"><a href="#4、Map" class="headerlink" title="4、Map"></a>4、Map</h2><p>在 JS 中对象是创建无序键 / 值对数据结构 [ 也称为 映射（map）] 的主要机制。但是，对象作为映射的主要缺点是不能使用非字符串值作为键。所以在 ES6 提出一个新的数据结构，Map。<br>Map 和对象很类似，都是键值对的形式，但是 Map 的键可以是任意类型(对象或者原始值)，NaN 也可以作为键，不再只局限于字符串。<br>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作 Map 构造函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="number">3</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;&#123;a:1&#125;: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 MDN 中清晰的列出了 Map 和 Object 间的不同：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">Map</th>
<th align="center">Object</th>
</tr>
</thead>
<tbody><tr>
<td align="left">意外的键</td>
<td align="center">Map 默认情况不包含任何键。只包含显式插入的键。</td>
<td align="center">一个 Object 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。注意: 虽然 ES5 开始可以用 Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</td>
</tr>
<tr>
<td align="left">键的类型</td>
<td align="center">一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。</td>
<td align="center">一个 Object 的键必须是一个 String 或是 Symbol。</td>
</tr>
<tr>
<td align="left">键的顺序</td>
<td align="center">Map 中的 key 是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。</td>
<td align="center">一个 Object 的键是无序的。注意：自 ECMAScript 2015 规范以来，对象确实保留了字符串和 Symbol 键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。</td>
</tr>
<tr>
<td align="left">Size</td>
<td align="center">Map 的键值对个数可以轻易地通过 size 属性获取</td>
<td align="center">Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td align="left">迭代</td>
<td align="center">Map 是 iterable 的，所以可以直接被迭代。</td>
<td align="center">迭代一个 Object 需要以某种方式获取它的键然后才能迭代。</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="center">在频繁增删键值对的场景下表现更好。</td>
<td align="center">在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
</tbody></table>
<h2 id="5、Map-的-API"><a href="#5、Map-的-API" class="headerlink" title="5、Map 的 API"></a>5、Map 的 API</h2><p>Map 的实例属性有两个：</p>
<ol>
<li>Map.prototype.constructor：返回一个函数，它创建了实例的原型。默认是 Map 函数。</li>
<li>Map.prototype.size： 返回 Map 对象的键/值对的数量。</li>
</ol>
<p>实例方法分为两类，一个是操作类，一个是遍历类。<br>操作类：</p>
<ol>
<li>Map.prototype.set(key, value)：设置 Map 对象中键的值。返回该 Map 对象。</li>
<li>Map.prototype.get(key)：返回键对应的值，如果不存在，则返回 undefined。</li>
<li>Map.prototype.has(key)：返回一个布尔值，表示 Map 实例是否包含键对应的值。</li>
<li>Map.prototype.delete(key)：如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 Map.prototype.has(key) 将返回 false 。</li>
<li>Map.prototype.clear()：移除 Map 对象的所有键/值对。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123; <span class="attr">name</span>: <span class="string">"Jack"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">"啥"</span>;</span><br><span class="line">map.set(key, value); <span class="comment">// &#123;&#123;name: 'Jack'&#125;: '啥'&#125;</span></span><br><span class="line">map.get(key); <span class="comment">// '啥'</span></span><br><span class="line">map.get(a); <span class="comment">// undefined</span></span><br><span class="line">map.has(key); <span class="comment">// true</span></span><br><span class="line">map.delete(key); <span class="comment">// true</span></span><br><span class="line">map.clear(); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>遍历类：</p>
<ol>
<li>Map.prototype.entries()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。</li>
<li>Map.prototype.forEach(callbackFn[, thisArg])：按插入顺序，为 Map 对象里的每一键值对调用一次 callbackFn 函数。如果为 forEach 提供了 thisArg，它将在每次回调中作为 this 值。</li>
<li>Map.prototype.keys()：返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键 。</li>
<li>Map.prototype.values()：返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值 。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">"name"</span>, <span class="string">"Jack"</span>],</span><br><span class="line">  [&#123; <span class="attr">age</span>: <span class="number">25</span> &#125;, <span class="string">"啥"</span>],</span><br><span class="line">]);</span><br><span class="line">map.entries(); <span class="comment">// MapIterator &#123;"name" =&gt; "Jack", &#123;age: 25&#125; =&gt; "啥"&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// ["name", "Jack"] [&#123;age: 25&#125;, "啥"]</span></span><br><span class="line">&#125;</span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, key, map); <span class="comment">// Jack name Map(2) &#123;"name" =&gt; "Jack", &#123;age: 25&#125; =&gt; "啥"&#125;</span></span><br><span class="line">  <span class="comment">//"啥"&#123;age: 25&#125; Map(2) &#123;"name" =&gt; "Jack", &#123;age: 25&#125; =&gt; "啥"&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">map.keys(); <span class="comment">// MapIterator &#123;"name", &#123;age: 25&#125;&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// "name" &#123;age: 25&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">map.values(); <span class="comment">// MapIterator &#123;"Jack", "啥"&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// "Jack" "啥"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、Map-和其他数据结构的转换"><a href="#6、Map-和其他数据结构的转换" class="headerlink" title="6、Map 和其他数据结构的转换"></a>6、Map 和其他数据结构的转换</h2><h4 id="6-1、Map-转数组"><a href="#6-1、Map-转数组" class="headerlink" title="6.1、Map 转数组"></a>6.1、Map 转数组</h4><p>ES6 给出一个最简单的方式，扩展运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">"name"</span>, <span class="string">"Jack"</span>],</span><br><span class="line">  [&#123; <span class="attr">age</span>: <span class="number">25</span> &#125;, <span class="string">"啥"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log([...map]); <span class="comment">// [['name', 'Jack'], [&#123;age: 25&#125;, '啥']]</span></span><br></pre></td></tr></table></figure>

<p>除此之外还可以用 Array.from()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">"name"</span>, <span class="string">"Jack"</span>],</span><br><span class="line">  [&#123; <span class="attr">age</span>: <span class="number">25</span> &#125;, <span class="string">"啥"</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(map)); <span class="comment">// [['name', 'Jack'], [&#123;age: 25&#125;, '啥']]</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2、Map-转对象"><a href="#6-2、Map-转对象" class="headerlink" title="6.2、Map 转对象"></a>6.2、Map 转对象</h4><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"yes"</span>, <span class="literal">true</span>).set(<span class="string">"no"</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap);</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-Map-转-JSON"><a href="#6-3-Map-转-JSON" class="headerlink" title="6.3 Map 转 JSON"></a>6.3 Map 转 JSON</h4><p>Map 转 JSON 有两个形式，第一种是键名都是字符串的类型的，第二种是键名中包含非字符串类型。<br>第一种的话直接将 map 转为对象，然后再用 JSON.Stringfy()进行转换。<br>第二种的话可以转成数组 JSON。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">"abc"</span>]);</span><br><span class="line">mapToArrayJson(myMap);</span><br><span class="line"><span class="comment">// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></span><br></pre></td></tr></table></figure>

<h2 id="7、WeakMap"><a href="#7、WeakMap" class="headerlink" title="7、WeakMap"></a>7、WeakMap</h2><p>WeakMap 和 WeakSet 有些类似，都是弱引用，并且成员值的键必须是对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[<span class="number">1</span>, <span class="number">3</span>]]); <span class="comment">// Uncaught TypeError: Invalid value used as weak map key</span></span><br><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[&#123; <span class="attr">name</span>: <span class="string">"Jack"</span> &#125;, <span class="number">3</span>]]); <span class="comment">// &#123;&#123;name: 'Jack'&#125;: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>WeakMap 有四个实例方法：</p>
<ol>
<li>WeakMap.prototype.delete(key)：移除 key 的关联对象。执行后 WeakMap.prototype.has(key)返回 false。</li>
<li>WeakMap.prototype.get(key)：返回 key 关联对象, 或者 undefined(没有 key 关联对象时)。</li>
<li>WeakMap.prototype.has(key)：根据是否有 key 关联对象返回一个 Boolean 值。</li>
<li>WeakMap.prototype.set(key, value)：在 WeakMap 中设置一组 key 关联对象，返回这个 WeakMap 对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">"Jack"</span> &#125;;</span><br><span class="line">weakMap.set(obj, <span class="number">3</span>); <span class="comment">// &#123;&#123;name: 'Jack': 3&#125;&#125;</span></span><br><span class="line">weakMap.get(obj); <span class="comment">// 3</span></span><br><span class="line">weakMap.has(obj); <span class="comment">// true</span></span><br><span class="line">weakMap.delete(obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">Set 和 Map 数据结构</a></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/06/28/Promise/</url>
    <content><![CDATA[<p>Promise 让人又恨又爱的存在，恨是因为面试的时候会围绕它出很多题，又绕又头疼，爱是真香，谁都逃不过真香定律。</p>
<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>Promise 是异步编程的一个新的解决方案，<a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰：ECMAScript 6 入门</a>中给出对 promise 的含义是：所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br>Promise 是一个构造函数，它有两个特点：</p>
<a id="more"></a>

<ol>
<li>Promise 有三个状态：pending（进行中）、resolved（已成功）和 rejected（已失败）。并且状态不受外部的影响。</li>
<li>状态一旦改变就无法修改。只能有两个过程：一个是从 pending 到 resolved 还有一个就是从 pending 到 rejected，不可能从 resolved 到 rejected，一旦成功就不可能再失败了。</li>
<li>Promise 一旦创建就会立即执行，不能中途取消。</li>
</ol>
<h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><p>通常我们来说，Promise 主要是解决异步回调地狱。什么是回调地狱？<br>从网上找了几张图，大家可以感受一下被回调地狱所支配的恐惧：<br>回调地狱最大的缺点就是代码可读性差，编写费劲。<br>接下来我们来看一下 Promise 的基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(success) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之前说过，Promise 是一个构造函数，它接收一个函数参数，这个函数中接收两个参数，一个是 resolve 还有一个是 rejected，这两个参数均为函数，并且这两个参数不用自己部署，JS 引擎会自动部署。<br>resolve 函数的作用是当异步函数成功时，将成功后的值传递出去，同时也是将状态从 pending 变为 resolved，reject 函数的作用是当异步函数失败后，将失败的错误信息传递出去，同时也是将状态从 pending 变为 rejected。</p>
<h3 id="2-1、then"><a href="#2-1、then" class="headerlink" title="2.1、then()"></a>2.1、then()</h3><p>当 Promise 实例创建成功后，可以执行其原型上的 then 方法，then 方法同样接收两个函数参数，第一个是接收的 resolve 回调的结果，第二个是 reject 回调的结果，第二个参数是非必填的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"出现错误"</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (error) =&gt; <span class="built_in">console</span>.log(error) <span class="comment">// 出现错误</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>因为 Promise 的对象时立即创建的，所以在 resolve 和 reject 函数之前的操作都会立即执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(value) <span class="comment">// 2 1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Promise 执行 then 方法后会返回回来一个新的 Promise 对象，所以可以采用链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> value + <span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>第一个 then 函数的返回值，可以作为参数传给第二个 then 函数。如果第一个 then 函数返回的依旧是一个 Promise 对象呢？即是一个 Promise 封装的异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (value) =&gt;</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">3</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>此时第二个 then 函数传入的参数，即为第一个 then 函数返回的 Promise 对象的 resolved 状态下传递的值。也可以说只有第一个 then 返回的 Promise 执行状态成功时，第二个 then 函数才会执行。</p>
<h3 id="2-2、catch"><a href="#2-2、catch" class="headerlink" title="2.2、catch()"></a>2.2、catch()</h3><p>除了 then 函数外，在 Promise 原型上还有一个 catch 函数，此函数时当 Promise 内部异步出现错误的时候即为 rejected 状态时，才执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)) <span class="comment">// Error: test</span></span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</span><br><span class="line">&#125;).then(<span class="literal">null</span>, err=&gt;<span class="built_in">console</span>.log(err)) <span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>

<p>当 then 第二个参数和 catch 函数同时存在时，将不会执行 catch 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(err)) <span class="comment">// Error: test</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>那此时的 catch 捕获的是哪个 Promise 的错误呢？捕获的是前一个 Promise 的错误，即 then 函数返回回来的 Promise 错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test1"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// Error: test1</span></span><br></pre></td></tr></table></figure>

<p>Promise 的错误有一种类似冒泡机制，当 catch 之前没有没有任何函数截获错误，那终究会被 catch 截获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then()</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>

<p>只要 catch 前任何一个 Promise 报错，那终究会被 catch 截获。<br>通常情况下，不建议使用 then 函数的第二个参数来进行错误的捕获，如上所说的 catch 写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用 catch()方法，而不使用 then()方法的第二个参数。<br>then()返回一个新的 Promise 对象，catch()同样返回一个 Promise 对象，同样可以使用链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then()</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// Error: test</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当 catch 捕获完错误后，会接着执行下面的 then 方法，当没有错误抛出时，则会跳过 catch，直接执行后面的 then 方法。但是之后的 Promise 出现错误时，之前的 catch 就捕获不到了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then()</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test1"</span>);</span><br><span class="line">  &#125;) <span class="comment">// Error: test</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>catch 后面可以链式调用 then 方法，同样也可以调用 catch 方法，后面的 catch 方法是接收前一个 catch 方法所抛出的错误。</p>
<h3 id="2-3、finally"><a href="#2-3、finally" class="headerlink" title="2.3、finally"></a>2.3、finally</h3><p>在 ES8 中新加入了一个方法，即 finally，此方法不同于 then 和 catch，它不跟踪与 Promise 对象状态的改变，即不管 Promise 的最终状态如何，都会执行这个方法，同时 finally 不同于 then 和 catch 地方就是，它不接受任何参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)) <span class="comment">// 1</span></span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// Error test</span></span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>finally 同样返回一个新的 Promise 对象，用法和之前的 then 和 catch 一样，这块就不做过多的讲解了。</p>
<h2 id="3、其他-API"><a href="#3、其他-API" class="headerlink" title="3、其他 API"></a>3、其他 API</h2><p>除了上述 Promise 原型上的方法外，Promise 还有很多其他的 API。</p>
<h3 id="3-1、-Promise-all"><a href="#3-1、-Promise-all" class="headerlink" title="3.1、 Promise.all"></a>3.1、 Promise.all</h3><p>通过字面意思就能看出来，这个方法是‘全部’意思，由此可见可以接受多个 Promise 对象。<br>该方法接受具有 Iterator 接口并且每个成员都是 Promise 实例的参数，并返回一个新的 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>并且，只有当接受的参数中所有成员的状态都为 resolved 的时候，p 的状态才会为 resolved，如果有一个成员的状态为 rejected，那 p 的状态就为 rejected。<br>当所有成员的状态均为 resolved 的时候，会将每个成员 resolved 状态下的值拼成数组传递给 p 的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>当有一个成员的状态为 rejected 的时候，则会将第一个 rejected 状态的值返给 p 的 catch 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejecct</span>) =&gt;</span> &#123;</span><br><span class="line">    rejecct(<span class="number">2</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>如果有一个成员为 rejected 状态，并且自身调用了 catch 方法，那将不会走 p 对象的 catch 方法，这一点要注意。</p>
<h3 id="3-2、-Promise-race"><a href="#3-2、-Promise-race" class="headerlink" title="3.2、 Promise.race"></a>3.2、 Promise.race</h3><p>race 翻译成中文是竞赛的意思，他表示多个 Promise 对象，哪个成员率先改变状态，那 Promise.race 返回的 Promise 对象的状态变为什么，并将值转递给 p 的回调函数，它和 Promise.all 接收的参数一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">100</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">2</span>), <span class="number">50</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">3</span>), <span class="number">200</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">100</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="number">2</span>), <span class="number">50</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">3</span>), <span class="number">200</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3、Promise-allSettled"><a href="#3-3、Promise-allSettled" class="headerlink" title="3.3、Promise.allSettled"></a>3.3、Promise.allSettled</h3><p>该方法是 ES2020 新加入的，和 all 一样，返回一个新的 Promise 对象，接收一组 Promise 对象，但是和 all 区别的是，当不管每个成员的 Promise 是什么状态，只要执行结束，则返回的 Promise 对象就会执行结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.allSettled([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejecct</span>) =&gt;</span> &#123;</span><br><span class="line">    rejecct(<span class="number">2</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(value))); <span class="comment">// [&#123;status:"fulfilled",value:1&#125;,&#123;status:"rejected",reason:2&#125;,&#123;status:"fulfilled",value:3&#125;]</span></span><br></pre></td></tr></table></figure>

<p>有时候异步请求并不在意是否能够成功，这个时候这个方法就很符合场景了，并且返回一个数组，数组中每个对象有两个状态，一个是 fulfilled，另一个是 rejected，返回之后可以进行筛选，查看错误信息。</p>
<h3 id="3-4、Promise-resolve"><a href="#3-4、Promise-resolve" class="headerlink" title="3.4、Promise.resolve"></a>3.4、Promise.resolve</h3><p>将一个对象转化为一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">"foo"</span>);</span><br><span class="line">等价于;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="string">"foo"</span>));</span><br></pre></td></tr></table></figure>

<p>当 Promise.resolve 的参数是一个 Promise 实例时，原封不动的返回这个实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Promsie(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(p);</span><br><span class="line">p === p1; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当参数是一个 thenable 对象时，即含有 then 方法的对象时，会返回一个 Promise 对象，并立即执行 then 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当参数是不是一个 thenable 对象时，由于参数不是一个异步的，所以当 Promise.resolve 后，直接的状态就是 resolved 的状态，所以 then 后就会输出原值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 参数是个普通对象</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(obj);</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span><span class="built_in">console</span>.log(value)) <span class="comment">// &#123;name: '1'&#125;</span></span><br><span class="line"><span class="number">2.</span> 参数是个基本数据类型</span><br><span class="line"><span class="keyword">let</span> num = <span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(num);</span><br><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span><span class="built_in">console</span>.log(value)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当不传参数的时候，返回的就是一个带有 resolved 状态的 Promise 对象。</p>
<h3 id="3-5、Promise-reject"><a href="#3-5、Promise-reject" class="headerlink" title="3.5、Promise.reject"></a>3.5、Promise.reject</h3><p>返回一个状态为 rejected 的 Promise 对象，传入的参数作为错误信息作为后续方法传递的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(num);</span><br><span class="line">p.then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(err)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当参数是 thenable 对象时，返回的不是 error 信息而是 thenable 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(thenable);</span><br><span class="line">p.then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(err === thenable)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply和bind</title>
    <url>/2020/06/18/call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<p>call、apply 和 bind 都是对 this 值得改变，那三者有什么不同呢？本篇通过模拟三者代码的形式来讲解。</p>
<a id="more"></a>

<h2 id="1、call"><a href="#1、call" class="headerlink" title="1、call"></a>1、call</h2><p><a href="https://www.w3school.com.cn/js/js_function_call.asp" target="_blank" rel="noopener">W3school</a>中对 call()方法的定义是：它可以用来调用所有者对象作为参数的方法。通过 call()，能够使用属于另一个对象的方法。<br>我们举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo);</span><br></pre></td></tr></table></figure>

<p>由上可以看出 call()函数主要做了两件事，第一个是改变 this 的指向，将 bar 中的 this 指向了 foo，第二个是执行了 bar 方法。</p>
<p>接下来我们来模拟 call 方法：</p>
<h4 id="第一步：实现简单的-call-方法："><a href="#第一步：实现简单的-call-方法：" class="headerlink" title="第一步：实现简单的 call 方法："></a>第一步：实现简单的 call 方法：</h4><p>上面的例子可以改造为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar();</span><br></pre></td></tr></table></figure>

<p>输出的结果和上述的一模一样，唯一的不同就是 foo 中多了一个 bar 的属性，那我们执行完后删除这个属性就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  Context.fn();</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo);</span><br></pre></td></tr></table></figure>

<p>结果和 call 一致。</p>
<h4 id="第二步：因为-call-可以带参数，所以我们接下来实现这个"><a href="#第二步：因为-call-可以带参数，所以我们接下来实现这个" class="headerlink" title="第二步：因为 call 可以带参数，所以我们接下来实现这个"></a>第二步：因为 call 可以带参数，所以我们接下来实现这个</h4><p>看一下原版的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(goods); <span class="comment">// 自行车</span></span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="number">10</span>, <span class="string">"自行车"</span>);</span><br></pre></td></tr></table></figure>

<p>因为参数是不固定的，所以可以想到 arguments。怎么将 arguments 传入对象中，这就是个难题，高兴的是 ES6 给了我们方法：解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  Context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(goods); <span class="comment">// 自行车</span></span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo, <span class="number">10</span>, <span class="string">"自行车"</span>);</span><br></pre></td></tr></table></figure>

<p>是不是感觉特别简单，但是 call 是 ES3 的方法，解构赋值是 ES6 的方法，感觉有点欺负它，那我们就需要重新想一个。这个方法也是查看了资料后才找到的，自己能力还是有限啊！<br>可以运用 eval()，eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++&gt;) &#123;</span><br><span class="line">    args.push(<span class="string">'arguments[+'</span> i <span class="string">'+]'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'Context.fn(+'</span> args <span class="string">'+)'</span>);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(goods); <span class="comment">// 自行车</span></span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo, <span class="number">10</span>, <span class="string">'自行车'</span>);</span><br></pre></td></tr></table></figure>

<p>感觉很完美了，但是依旧有两小点需要注意：</p>
<ol>
<li>当 this 为 null 时</li>
<li>当函数有返回值时<br>我们先来看第一点：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Jack"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// Jack</span></span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>当 this 为 null 时，默认走向 window<br>第二点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    goods: <span class="string">"自行车"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo); <span class="comment">// &#123;age: 1, goods: "自行车"&#125;</span></span><br></pre></td></tr></table></figure>

<p>当函数有返回值时，结果就是这个返回值。</p>
<h4 id="第三步：我们对自己模拟的方法进行最后的优化："><a href="#第三步：我们对自己模拟的方法进行最后的优化：" class="headerlink" title="第三步：我们对自己模拟的方法进行最后的优化："></a>第三步：我们对自己模拟的方法进行最后的优化：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Context = Context ? Context : <span class="built_in">window</span>;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"Context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、apply"><a href="#2、apply" class="headerlink" title="2、apply"></a>2、apply</h2><p>call() 和 apply() 之间的区别，不同之处是：</p>
<ol>
<li>call() 方法分别接受参数。</li>
<li>apply() 方法接受数组形式的参数。</li>
</ol>
<p>所以 call 和 apply 只是接受参数的不同，思路还是和 call 一样，这次就不重复了直接贴代码：<br>运用解构赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Context = Context ? Context : <span class="built_in">window</span>;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>] ? <span class="built_in">arguments</span>[<span class="number">1</span>] : [];</span><br><span class="line">  <span class="keyword">var</span> result = Context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运用 eval：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Context = Context ? Context : <span class="built_in">window</span>;</span><br><span class="line">  Context.fn = <span class="keyword">this</span>; <span class="comment">// 此时的this指向的是Function，即调用者</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="built_in">arguments</span>[<span class="number">1</span>] ? <span class="built_in">arguments</span>[<span class="number">1</span>] : [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"Context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">delete</span> Context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">bar.myApply(foo);</span><br></pre></td></tr></table></figure>

<h2 id="3、bind"><a href="#3、bind" class="headerlink" title="3、bind"></a>3、bind</h2><p>bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind()的第一个参数, 它的参数是 bind()的其他参数和其原本的参数。<br>所以 bind 执行两个步骤：</p>
<ol>
<li>返回一个新函数</li>
<li>可以传入参数</li>
</ol>
<p>我们按照分析 call()函数一样的思路来分析 bind()，首先看一下原先的 bind：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo);</span><br><span class="line">bindFoo(); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>所以可以看出 bar.bind(foo);返回一个新的函数，当这个函数执行时，才返回其中的结果，那我们先模拟一下这个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(Context);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.myBind(foo);</span><br><span class="line">bindFoo(); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<p>结果一样，说明这一步模拟的没有问题。那我们进行下一步的模拟，因为 bind 也是可以携带参数的，携带参数的方式和 call 相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(goods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="number">1</span>, <span class="string">"1"</span>);</span><br><span class="line">bindFoo(); <span class="comment">// Jack 1 1</span></span><br></pre></td></tr></table></figure>

<p>模拟板升级：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(Context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很完美，但是 bind 有个特点被忽视了，因为 bind 返回一个新的函数，那我们将返回的函数里面传参，会有什么效果，我们看一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(goods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="number">1</span>);</span><br><span class="line">bindFoo(<span class="string">"1"</span>); <span class="comment">// Jack 1 1</span></span><br></pre></td></tr></table></figure>

<p>可以看出 bind 可以只传入 age，然后再从返回的新函数中传入 goods，那我们需要把上述模拟进行升级：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(Context, args.concat(bindArgs));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路其实很简单，就是将两个 arguments 进行合并。<br>本以为这样就结束了，但是 MDN 提到了 bind 的另外一个特点：绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。什么意思呢？用代码演示一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">age, goods</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(goods);</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.friends = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">var</span> BindFoo = bar.bind(foo, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> bindFoo = <span class="keyword">new</span> BindFoo(<span class="string">"1"</span>); <span class="comment">// undefined 1 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bindFoo.friends); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>this.name 竟然输出 undefined，那是因为 new 后，BindFoo 中 this 的指向改变了，指向了 bindFoo，而 BindFoo 实际是 bar 函数，并且 bindFoo 没有 value 属性，所以就输出了 undefined，通过 instanceof 就可以看出来，bindFoo 是 BindFoo 的实例，也是 bar 的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> cacheFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> bindFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> cacheFn ? <span class="keyword">this</span> : Context,</span><br><span class="line">      args.concat(bindArgs)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  cacheFn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFun.prototype = <span class="keyword">new</span> cacheFn();</span><br><span class="line">  <span class="keyword">return</span> bindFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们进行分步讲解：<br>1、为什么要判断 this instanceof bindFun？<br>之前也说到，当将 bind 返回后函数当做构造函数时，bindFoo 即是 BindFoo 的实例也是 bar 的实例，BindFoo 即为返回来的函数，在我们模拟的代码中就是 bindFun 这个函数，并且当 new 之后 this 指向的是实例，所以用 this instanceof bindFun 判断的实际就是函数前有没有 new 这个关键词。<br>2、为什么要继承 this 的原型？<br>这是为了继承 bar 原型上的属性。<br>最后一步，健壮模拟的 bind，判断传过来的 this 是否为函数，也是最终版：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">Context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> cacheFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> bindFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> cacheFn ? <span class="keyword">this</span> : Context,</span><br><span class="line">      args.concat(bindArgs)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  cacheFn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  bindFun.prototype = <span class="keyword">new</span> cacheFn();</span><br><span class="line">  <span class="keyword">return</span> bindFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>new关键词</title>
    <url>/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    <content><![CDATA[<p>大部分面试的时候，面试官先已原型链铺路，随后就会问你 new 关键词都做了些什么？也是为了下一个继承问题再次铺路！<br>那这篇文章我们就来讲讲这个 new！<br>我们通常在什么地方能看到它，在创建实例的时候，new 后面加上一个构造函数，就是创建这个构造函数的实例。</p>
<a id="more"></a>

<p>首先我们创建一个构造函数，看看 new 都做了哪些事情：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Jack"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="string">"29"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"烤鸭"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 29</span></span><br><span class="line">person.eat(); <span class="comment">// 烤鸭</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/2020_06_08_22_41.16.png" alt="person.prototype"><br><img src="/2020/04/21/new%E5%85%B3%E9%94%AE%E8%AF%8D/2020_06_08_22_51.33.bmp" alt="person.consturctor"><br>我们从上述可以看出，new 关键词主要做了以下几个事情：</p>
<ol>
<li>创建了一个新的对象，</li>
<li>将新对象的__proto__函数指向构造函数的 prototype，这个新对象就可以访问构造函数原型上的属性</li>
<li>将 this 指向改变，指向新的对象，这样就可以访问构造函数内部的属性</li>
<li>返回新的对象</li>
</ol>
<p>接下来来模拟一下 new 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来验证一下写的这个方法是否正确：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Jack"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="string">"29"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"烤鸭"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = MyNew(Person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 29</span></span><br><span class="line">person.eat(); <span class="comment">// 烤鸭</span></span><br></pre></td></tr></table></figure>

<p>输出结果一样，那忽然有个想法，构造函数毕竟是个函数，如果构造函数有返回值，那 new 后结果是怎样呢：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回基本数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Jack"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="string">"29"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"烤鸭"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 29</span></span><br><span class="line">person.eat(); <span class="comment">// 烤鸭</span></span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Jack"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="string">"29"</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sex: <span class="string">"nan"</span>,</span><br><span class="line">    like: <span class="string">"nv"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"烤鸭"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sex); <span class="comment">//Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person.like); <span class="comment">// 29</span></span><br><span class="line">person.eat(); <span class="comment">// Uncaught TypeError: person.eat is not a function</span></span><br></pre></td></tr></table></figure>

<p>当构造函数返回的是一个基本数据类型时，跟没有返回值是一样的结果，但是当返回值是一个对象时，就会真的返回这个对象，return 之前定义的属性都会失效，并且定义在原型上的属性也会失效。根据这个特性，对之前写的 MyNew 函数进行升级。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  <span class="keyword">let</span> res = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础类型和引用类型</title>
    <url>/2020/04/08/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>开始第一篇，那我们从 js 最基础的讲起，基础类型和引用类型</p>
<a id="more"></a>

<h2 id="1、什么是基础类型（值类型、原始类型）"><a href="#1、什么是基础类型（值类型、原始类型）" class="headerlink" title="1、什么是基础类型（值类型、原始类型）"></a>1、什么是基础类型（值类型、原始类型）</h2><p>保存在栈中的类型就是基础类型，原因是基础类型存储的空间很小，存放在栈中方便查找，且不易于改变</p>
<h3 id="js-中的基础类型（值类型、原始类型）有哪些"><a href="#js-中的基础类型（值类型、原始类型）有哪些" class="headerlink" title="js 中的基础类型（值类型、原始类型）有哪些"></a>js 中的基础类型（值类型、原始类型）有哪些</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Undefined、Null、<span class="built_in">Boolean</span>、<span class="built_in">Number</span>、<span class="built_in">String</span>、<span class="built_in">Symbol</span>（ES6中新加类型）</span><br><span class="line"><span class="comment">// undefined和null是所有类型的子类型</span></span><br></pre></td></tr></table></figure>

<h2 id="2、什么是引用类型"><a href="#2、什么是引用类型" class="headerlink" title="2、什么是引用类型"></a>2、什么是引用类型</h2><p>指有多个值构成的对象，引用数据类型是存储在堆中，也就是说存储的变量处的值是一个指针，指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度</p>
<h3 id="js-中的引用类型有哪些"><a href="#js-中的引用类型有哪些" class="headerlink" title="js 中的引用类型有哪些"></a>js 中的引用类型有哪些</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3、如何判断类型"><a href="#3、如何判断类型" class="headerlink" title="3、如何判断类型"></a>3、如何判断类型</h2><h3 id="3-1-typeof"><a href="#3-1-typeof" class="headerlink" title="3.1 typeof"></a>3.1 typeof</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//'undefined'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//'boolean'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"123"</span>); <span class="comment">//'string'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">//'number'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">//'number'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">//'object'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn); <span class="comment">//'function'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;); <span class="comment">//'function'</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">//'symbol'</span></span><br></pre></td></tr></table></figure>

<p>实现原理如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。</span><br></pre></td></tr></table></figure>

<p>所以 typeof null 的返回值是 object，这是个“历史遗留问题”。<br>因为 typeof 判断引用类型时不太准确，所以我们选用其他方法。</p>
<h3 id="3-2-instanceof"><a href="#3-2-instanceof" class="headerlink" title="3.2 instanceof"></a>3.2 instanceof</h3><p>通常来说，instanceof 是判断一个实例是否属于某种类型<br>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出，instanceof 对引用类型来说判断的非常准确，但是对于基础类型却不能精准的判断。原因是 instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型的实例，1、‘1’、true 并不是实例，所以为 false。<br>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"1"</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>但是对 undefined 和 null，却比较特殊</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">null</span>() <span class="keyword">instanceof</span> Null); <span class="comment">//Uncaught TypeError: null is not a constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">undefined</span>() <span class="keyword">instanceof</span> Undefined); <span class="comment">//Uncaught TypeError: undefined is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>原因是因为 undefined 和 null 并不是构造函数</p>
<h3 id="3-3-constructor"><a href="#3-3-constructor" class="headerlink" title="3.3 constructor"></a>3.3 constructor</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span>.constructor === <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log([].constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;.constructor === <span class="built_in">Function</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>看着貌似很准确的样子，但是还是有缺陷，当创建一个对象改变他的原型的时候，就不再准确了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这是因为 js 每个函数都有一个 prototype 属性，指向原型对象，对象.prototype.constructor 指向的是该对象的构造函数，当把该对象的原型对象更改时，该函数的构造对象也会更改，所以就会出现如上的问题</p>
<h3 id="3-4-Object-prototype-toString-call"><a href="#3-4-Object-prototype-toString-call" class="headerlink" title="3.4 Object.prototype.toString.call()"></a>3.4 Object.prototype.toString.call()</h3><p>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"1"</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())); <span class="comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure>

<p>这是最准确的类型判定的方法，就算改变原型也不会有问题。<br>具体分析一下这个方法背后的故事：<br>每个 Object 原型上都有一个 toString 的方法，当调用这个方法的时候会执行三个步骤：<br>1、获取对象的类名（对象类型）<br>2、将[object、获取的对象类型]组合为字符串<br>3、返回字符串</p>
<h4 id="为什么要用-call-方法？"><a href="#为什么要用-call-方法？" class="headerlink" title="为什么要用 call 方法？"></a>为什么要用 call 方法？</h4><p>因为 Array、String 等类型都对其继承下来原型上的 toSring 方法进行了重写，无法返回我们想要的结果，所以我们通过 call 方法，将 Object.prototype.toString 上的 Object 的指向改变，才能对类型进行精准的判断。</p>
<h4 id="Object-toString-和-Object-prototype-toString-的区别？"><a href="#Object-toString-和-Object-prototype-toString-的区别？" class="headerlink" title="Object.toString 和 Object.prototype.toString 的区别？"></a>Object.toString 和 Object.prototype.toString 的区别？</h4><p>Object.toString 是 Object 构造器的方法，返回的是函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.toString(&#123;&#125;); <span class="comment">//"function Object() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>

<p>Object.prototype.toString 是 Object 原型上的方法，返回的是类型字符串，才是我们想要的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;); <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let和const</title>
    <url>/2020/06/22/var%E3%80%81let%E5%92%8Cconst/</url>
    <content><![CDATA[<h2 id="1、var"><a href="#1、var" class="headerlink" title="1、var"></a>1、var</h2><p>在没出现 let 和 const 之前，我们定义变量只能用 var。但是用 var 定义变量通常有很多的问题，就是我们常说的变量提升，例如：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>如果初学者第一次看这段代码的时候，肯定会觉得段代码会报错，因为 if 中的条件是 false，并没有执行 var a = 1，所以最后应该报 a 没有定义的错误，但是实际最后却输出了 undefined，这就是变量提升。<br>什么是变量提升：<br>MDN 是这么说的：变量提升（Hoisting）被认为是， Javascript 中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。在 ECMAScript® 2015 Language Specification 之前的 JavaScript 文档中找不到变量提升（Hoisting）这个词。不过，需要注意的是，开始时，这个概念可能比较难理解，甚至恼人。<br>这就没了？对这就没了！当看到的时候同样有这个疑问，所以我在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="noopener">var 描述</a>中找到了这么一句话：变量声明，无论发生在何处，都在执行任何代码之前进行处理。<br>所以以上代码可以被翻译成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h2 id="2、let"><a href="#2、let" class="headerlink" title="2、let"></a>2、let</h2><p>我们先看一下 let 的几大特性：</p>
<h3 id="1、没有声明提升"><a href="#1、没有声明提升" class="headerlink" title="1、没有声明提升"></a>1、没有声明提升</h3><p>我们通过代码来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/22/var%E3%80%81let%E5%92%8Cconst/2020_06_22_22_36.53.bmp" alt="执行结果"><br>欣喜若狂终于得到了我们想要的结果，报错，a 没有被定义。</p>
<h3 id="2、重复声明报错"><a href="#2、重复声明报错" class="headerlink" title="2、重复声明报错"></a>2、重复声明报错</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/22/var%E3%80%81let%E5%92%8Cconst/2020_06_22_22_38.58.bmp" alt="执行结果"><br>哇塞，报错了，显示 a 已经被定义过了，这简直是太友好了，终于不会一不小心就改变了全局变量，也终于避免了重复命名的危险。</p>
<h3 id="3、不绑定全局作用域"><a href="#3、不绑定全局作用域" class="headerlink" title="3、不绑定全局作用域"></a>3、不绑定全局作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>根本没有定义到全局上，主要还是因为 let 是块级作用域不是全局作用域。</p>
<h2 id="3、const"><a href="#3、const" class="headerlink" title="3、const"></a>3、const</h2><p>在开发中 const 我们一般是来定义常量，即不可更改的量，它的基本特性和 let 是差不多的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>执行上述代码时，会报错，因为 const 定义的是常量，无法进行修改。但是当 const 定义的是引用数据类型时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">a.value = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123;value: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>感觉有些打脸，但确实如此，这是因为 const 定义的实际是引用地址，它判断是的引用地址是否发生变化，虽然改变了引用数据中的数据，但是它的引用地址并没有发生变化，所以就可以更改，但是这种方式还是不提倡的。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2020/05/29/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>何为作用域，查找度娘百科中是这么定义的：</p>
<p>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</p>
<a id="more"></a>

<h2 id="1、静态作用域（词法作用域）"><a href="#1、静态作用域（词法作用域）" class="headerlink" title="1、静态作用域（词法作用域）"></a>1、静态作用域（词法作用域）</h2><p>通常来说 JS 是静态作用域，函数的作用域在函数定义的时候就已经确定了。<br>可以举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>最后输出为 1，因为 JS 是静态作用域，所以 foo 函数的作用域在其定义的时候就被确定了，当在 bar 函数中执行 foo()时，没有去查找 bar 中的 scope 变量，而是去查找 foo 函数中的 scope，当 foo 函数中没有找到这个变量的时候他会在全局中查找，所以最后输出 1。</p>
<h2 id="2、动态作用域"><a href="#2、动态作用域" class="headerlink" title="2、动态作用域"></a>2、动态作用域</h2><p>函数的作用域在函数调用的时候才决定。<br>其实大部分的语言都是基于静态作用域的，如果 JS 是动态作用域的话，那上述例子最后的结果应该是 2 而不是 1，因为当 foo()无法找到 scope 的变量引用时，会顺着调用栈在调用 foo()的地方查找 scope，而不是在嵌套的词法作用域链中向上查找。由于 foo()是在 bar()中调用的，引擎会检查 bar()的作用域，并在其中找到值为 2 的变量 scope。<br>看到这里有没有感觉到这个动态作用域的工作原理像极了 JS 中的 this，关于 this 的机制我们将在后续中进行讲解。</p>
<h2 id="3、JS-的全局作用域、块级作用域、函数作用域"><a href="#3、JS-的全局作用域、块级作用域、函数作用域" class="headerlink" title="3、JS 的全局作用域、块级作用域、函数作用域"></a>3、JS 的全局作用域、块级作用域、函数作用域</h2><h3 id="3-1-全局作用域"><a href="#3-1-全局作用域" class="headerlink" title="3.1 全局作用域"></a>3.1 全局作用域</h3><p>在 ES6 之前，JS 只有全局作用域和函数作用域，但是当全局作用域用的过多时就会发现一个大问题，就是全局污染，为了这个解决这个问题推出了好多方法：模块化、闭包、命名空间等等等等。<br>什么是全局作用域？<br>全局作用域即贯穿整个 JS 文档，在任何地方都能够访问到，JS 中有个全局对象 window，如声明一个全局变量，就相当于在 window 上添加一个属性。</p>
<h3 id="3-2-块级作用域"><a href="#3-2-块级作用域" class="headerlink" title="3.2 块级作用域"></a>3.2 块级作用域</h3><p>块级作用域是 ES6 中才出现的新特性，通常使用的 let、const 都是显式声明块级作用域的方法。<br>在《你不知道的 JavaScript》中对块级作用域的总结是这样的：块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。<br>其实我认为通俗的理解就是，在代码块中定义的变量或者函数，在其代码块外无法访问。</p>
<h3 id="3-3-函数作用域"><a href="#3-3-函数作用域" class="headerlink" title="3.3 函数作用域"></a>3.3 函数作用域</h3><p>函数作用域即定义在函数代码块中的变量和函数，外部无法访问。<br>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>运行上述结果可以的出结论，foo 函数运行完后在 foo 函数中输出的为 2，在全局上输出的为 1。但是这样并不是很理想，因为 foo 函数是挂载在全局中的，也会容易造成一个全局污染的问题，其次必须显式调用(foo())才能运行函数代码，还好 JS 给我们提供了一个解决这种问题的方法，即自执行函数。<br>可以通过自执行函数将上面的例子进行改造：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>执行结果与之前相同，当查看 foo 函数时会报 foo 没有被定义的错误。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝和浅拷贝</title>
    <url>/2020/04/17/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>这属于面试的高频问题了，深浅拷贝的问题只针对于引用数据类型，对于基本数据类型并没有这样的问题。<br>为什么引用数据类型会出现这样的问题？<br>第一篇 js 数据类型中有提到，引用数据类型存放在堆中，栈中存放的是该引用类型的地址，以便能通过地址快速找到该引用数据。<br>所以在拷贝时就会出现只拷贝引用类型的地址和再在堆中开辟一个新的内存空间的两种拷贝方式。</p>
<a id="more"></a>

<h2 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> new_arr = arr;</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>开发时我们经常能遇到上面这种情况，当对原数组添加新值时，新数组也会发生改变，这种情况我们就称之为浅拷贝。<br>原因是浅拷贝只拷贝引用地址，而地址都是指向了同一个对象，所以彼此之间的改变会相互影响。<br>大部分情况下的拷贝都是浅拷贝，除了上面=（赋值）外实现浅拷贝的方法也有很多：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">concat();</span><br><span class="line">slice();</span><br><span class="line">ES6新增：</span><br><span class="line">展开运算符(...)</span><br><span class="line"><span class="built_in">Array</span>.from()</span><br></pre></td></tr></table></figure>

<p>上述方法中 concat 会有些特殊：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> new_arr = [].concat(arr);</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上述结果显示，当改变原数组时，新数组并没有发生改变，会以为 concat 属于深拷贝的方法。但当进行下述运算时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123; <span class="attr">old</span>: <span class="string">"old"</span> &#125;, [<span class="string">"old"</span>]];</span><br><span class="line"><span class="keyword">var</span> new_arr = arr.concat();</span><br><span class="line">arr[<span class="number">0</span>].old = <span class="string">"new"</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"new"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[&#123;old: 'new'&#125;, ['new']]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[&#123;old: 'new'&#125;, ['new']]</span></span><br></pre></td></tr></table></figure>

<p>所以可以得出结论，当数组元素是基本数据类型时，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。</p>
<p>我们来写个函数简单实现一个浅拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shallowCopy = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> new_obj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      new_obj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> new_obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h2><p>深拷贝是完全拷贝一个新的对象，相当于开辟了一个新的内存空间，新旧两个对象不相互影响。<br>实现深拷贝的方法主要有两个，一个是 JSON.parse(JSON.stringify())和还有一个是递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">old</span>: <span class="string">"old"</span> &#125;, [<span class="string">"old"</span>]];</span><br><span class="line"><span class="keyword">let</span> new_arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr[<span class="number">0</span>].old = <span class="string">"new"</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"new"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[&#123;old: 'new'&#125;, ['new']]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[&#123;old: 'old'&#125;, ['old']]</span></span><br></pre></td></tr></table></figure>

<p>但是 JSON.parse(JSON.stringify())有个最大的问题就是，不能拷贝函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">old</span>: <span class="string">"old"</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> new_arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">//[&#123;old: 'old'&#125;, null]</span></span><br></pre></td></tr></table></figure>

<p>我们通过递归的形式简单实现一个深拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deepCopy = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="built_in">Object</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> new_obj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      new_obj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">"object"</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> new_obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>执行上下文</title>
    <url>/2020/05/29/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>上篇介绍完 JS 的作用域，那接下来的几篇就要讲讲跟作用域相关的内容了。</p>
<a id="more"></a>

<h2 id="1、执行上下文"><a href="#1、执行上下文" class="headerlink" title="1、执行上下文"></a>1、执行上下文</h2><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<h4 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h4><p>阅文前端团队翻译的《理解 Javascript 执行上下文和执行栈》中所说：</p>
<ol>
<li>全局执行上下文：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>
<li>函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li>
<li>eval 函数执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文。</li>
</ol>
<h2 id="2、执行上下文栈"><a href="#2、执行上下文栈" class="headerlink" title="2、执行上下文栈"></a>2、执行上下文栈</h2><p>执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文，这与堆栈中栈的原理类似。</p>
<p>当 JS 引擎开始编译 JS 代码时，会创建一个全局执行上下文压入到执行上下文栈的最顶层，当调用一个函数时，就会创建一个函数执行上下文压入执行上下文栈的最顶层。</p>
<p>当最新的函数执行完毕后，其执行上下文将会从执行上下文栈弹出，然后将执行下一个函数。</p>
<p>我们可以将执行上下文栈模拟为一个空数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stack = [];</span><br></pre></td></tr></table></figure>

<p>通过下个例子来理解一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo3();</span><br></pre></td></tr></table></figure>

<p>当执行上述例子时，先将全局执行上下文推入执行上下文栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stack = [globalContext];</span><br></pre></td></tr></table></figure>

<p>当函数调用的时候开始执行函数上下文：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="xml"><span class="tag">&lt;<span class="name">foo3</span>&gt;</span>, functionContext);</span></span><br><span class="line"><span class="xml">// foo3函数中调用了foo2</span></span><br><span class="line">stack.push(&lt;foo2&gt;, functionContext);</span><br><span class="line">// foo2函数中调用了foo1</span><br><span class="line">stack.push(&lt;foo1&gt;, functionContext);</span><br><span class="line">// foo1执行完毕</span><br><span class="line">stack.pop();</span><br><span class="line">// foo2执行完毕</span><br><span class="line">stack.pop();</span><br><span class="line">// foo1执行完毕</span><br><span class="line">stack.pop();</span><br><span class="line">// 之后再执行新的代码，但底层永远留有一个globalContext</span><br></pre></td></tr></table></figure>

<h2 id="3、执行上下文的创建"><a href="#3、执行上下文的创建" class="headerlink" title="3、执行上下文的创建"></a>3、执行上下文的创建</h2><p>在执行上下文创建的时候，分为两个阶段：1、创建阶段 2、执行阶段</p>
<h3 id="3-1、创建阶段"><a href="#3-1、创建阶段" class="headerlink" title="3.1、创建阶段"></a>3.1、创建阶段</h3><p>创建阶段有三个重要的属性：</p>
<ol>
<li>this</li>
<li>词法环境（作用域链）</li>
<li>变量环境</li>
</ol>
<h4 id="3-1-1、this"><a href="#3-1-1、this" class="headerlink" title="3.1.1、this"></a>3.1.1、this</h4><p>在全局上下文中，this 指向的是全局对象，在浏览器中，指向的是 window<br>在函数上下文中，this 指向的是函数的调用方，如果是对象调用该函数，则指向的是这个对象，否则 this 指向的是全局对象或者 undefined（严格模式）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Jack"</span>,</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.eat(); <span class="comment">// 此时的this指向person，因为是person调用的该函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 此时的this指向window</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2、词法环境（作用域链）"><a href="#3-1-2、词法环境（作用域链）" class="headerlink" title="3.1.2、词法环境（作用域链）"></a>3.1.2、词法环境（作用域链）</h4><p>词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）</p>
<p>词法环境包括两个部分：</p>
<ol>
<li>环境记录：存储变量和函数声明的实际位置</li>
<li>对外部环境的引用：意味着可以访问其外部的词法变量</li>
</ol>
<p>在全局上下文中，对外环境的引用为 null，它拥有一个全局的对象（windowd 对象）以及其关联的属性和方法和用户自定义的全局变量。</p>
<p>在函数上下文中，用户自定义的变量存储在环境记录中，对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。另外在函数上下文创建时，在其环境记录中还会生成一个 arguments 对象，该对象包含了索引和传递给函数的参数之间的映射以及传递给函数的参数的长度（数量）。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line">Arguments: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们以一个例子，并用伪代码来看一下在词法环境中 JS 内部都做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>我们用 ER 代表环境记录，用 outer 代表对外部环境的引用，伪代码写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全局上下文：</span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  ER: &#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    foo</span><br><span class="line">  &#125;,</span><br><span class="line">  outer: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">当运行函数时，会产生函数上下文：</span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ER: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      <span class="number">0</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="number">1</span>: <span class="number">3</span>,</span><br><span class="line">      length: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  outer: <span class="xml"><span class="tag">&lt;<span class="name">GlobalExectionContext</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 ES8 中规定环境记录同样拥有两个类型：</p>
<ol>
<li>声明性环境记录：存储变量、函数和参数。一个函数环境包含声明性环境记录。</li>
<li>对象环境记录：用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。</li>
</ol>
<h4 id="3-1-3、变量环境"><a href="#3-1-3、变量环境" class="headerlink" title="3.1.3、变量环境"></a>3.1.3、变量环境</h4><p>变量环境也是一个词法环境，所以他包含了词法环境的所有特性，在 ES6 中变量环境包括两个一个是 LexicalEnvironment 组件另一个是 VariableEnvironment 组件，他俩的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。</p>
<p>这样我们再举例来看一下 JS 内部究竟干了什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">c = add(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>我们同样用伪代码来模拟一下吗，用 LE 代表 LexicalEnvironment，用 VE 代表 VariableEnvironment：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全局上下文：</span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  LE: &#123;</span></span><br><span class="line"><span class="xml">    ER: &#123;</span></span><br><span class="line">      a: &lt;uninitialized&gt;,</span><br><span class="line">      b: &lt;uninitialized&gt;,</span><br><span class="line">      add: &lt;func&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null,</span><br><span class="line">  &#125;,</span><br><span class="line">  VE: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">      c: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">当调用add时，生成函数上下文：</span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  this: &lt;Global Object&gt;,</span><br><span class="line">  LE: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">     arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: 3,</span><br><span class="line">        length: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalExectionContext&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  VE: &#123;</span><br><span class="line">    ER: null,</span><br><span class="line">    outer: &lt;GlobalExectionContext&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时你一定会对 let、const、var 的值有一个疑惑，那是因为在创建阶段的时候，代码会被扫描和解析成变量和函数声明，函数声明存储在环境中，而 var 会被定义为 undefined，let 和 const 会被定位为 uninitialized，这就是为什么你可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因，这个错误就是暂时性死区或者叫做临时死亡（TDZ），原因就是在访问一个已经声明但没有初始化的变量。</p>
<h3 id="3-2、执行阶段"><a href="#3-2、执行阶段" class="headerlink" title="3.2、执行阶段"></a>3.2、执行阶段</h3><p>在此阶段，完成对所有变量的分配，最后执行代码。<br>注：在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p>
<p>这篇查阅了很多相关资料，但是觉得很多还是理解的不是很透彻，今后有时间会继续补充，也希望大家能多给些评价。</p>
<p>参考：<br><a href="https://juejin.im/post/5bdfd3e151882516c6432c32" target="_blank" rel="noopener">【译】理解 Javascript 执行上下文和执行栈</a></p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="1、创建对象"><a href="#1、创建对象" class="headerlink" title="1、创建对象"></a>1、创建对象</h2><a id="more"></a>

<p>创建对象有几种方法：</p>
<ol>
<li>字面量创建</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"o1"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>object 构造函数创建</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  name: <span class="string">"o2"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造函数创建</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"o3"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>object 方法创建</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">"o4"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(person);</span><br></pre></td></tr></table></figure>

<p>此方法是 ES6 新出的方法，此方法的好处可以理解为继承一个对象, 添加的属性是在原型下</p>
<h2 id="2、原型、构造函数、实例、原型链"><a href="#2、原型、构造函数、实例、原型链" class="headerlink" title="2、原型、构造函数、实例、原型链"></a>2、原型、构造函数、实例、原型链</h2><p><img src="/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="logo"></p>
<p>每个函数都有一个 prototype 的属性，每个函数通过 prototype 属性指向的对象，我们就称之为原型对象。<br>可能比较笼统，对原型也可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>我们可以看看对象的 prototype 到底返回的是什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype.bmp" alt="logo"></p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2020/04/20/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>JS 是一门面向对象的语言，面向对象的三个特性：封装、继承、多态。虽然 JS 没有多态，但是继承还是有的，但是 JS 的继承只支持实现继承，实现的方式就是通过原型链。原型链我们上篇已经讲过了，所以本篇主要 JS 中几种继承的方式。</p>
<a id="more"></a>

<h2 id="1、借用构造函数实现继承"><a href="#1、借用构造函数实现继承" class="headerlink" title="1、借用构造函数实现继承"></a>1、借用构造函数实现继承</h2><p>这种继承方法最原始的继承，实现的非常简单就是在子类型构造函数的内部实现超类型的构造函数。可以通过 call 和 apply 来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.money = <span class="string">"$1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(son1.money); <span class="comment">// $1</span></span><br><span class="line"><span class="keyword">var</span> son2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(son2.money); <span class="comment">// $1</span></span><br></pre></td></tr></table></figure>

<p>上述可见，这完全实现了继承，儿子继承了老子的钱，虽然只有 1 美元，但也是爱啊！</p>
<p>但是这样有一个问题，我们来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.money = <span class="string">"$1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(son1.money); <span class="comment">// $1</span></span><br><span class="line">son1.makeMoney(); <span class="comment">//Uncaught TypeError: son1.makeMoney is not a function</span></span><br></pre></td></tr></table></figure>

<p>发现了吧，这是一个大问题啊，虽然儿子继承了老子的钱，但是没有继承老子的赚钱的能力，虽然 1 美元是一笔大款，但是没有赚钱的能力，早晚也会花光的啊！这是因为方法都在构造函数中定义，因此函数复用就无从谈起了，而且在父类的原型上定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因为这个问题，借助构造函数的技术通常都不是单独使用的。那如何实现继承父类原型上的方法呢？这就要讲到另外一个实现继承的方式了，用原型链继承。</p>
<h2 id="2、原型链实现继承"><a href="#2、原型链实现继承" class="headerlink" title="2、原型链实现继承"></a>2、原型链实现继承</h2><p>原型链在 JS 中是一种特殊的存在，那如何实现在原型链上的继承呢？是否想到了 new 这个关键词？new 干了哪些事情呢？这是一个经典面试题，简单的说是：</p>
<ol>
<li>创建一个新对象</li>
<li>将新对象的__proto__指向构造函数的 prototype 对象</li>
<li>将构造函数的作用域赋值给新对象 （也就是 this 指向新对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新的对象</li>
</ol>
<p>第二条就能满足咱们的要求。<br>所以继承父类原型链上的方法我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.money = <span class="string">"$1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(); <span class="comment">// $1</span></span><br><span class="line"><span class="built_in">console</span>.log(son1.money);</span><br><span class="line">son1.makeMoney(); <span class="comment">// 努力工作</span></span><br></pre></td></tr></table></figure>

<p>简直完美啊，儿子即继承了 1 美元又继承了努力赚钱的方法。但是好像忽略了一点，这个父亲好像有两个儿子，现在这个父亲不止只有钱还有很多东西，那我们将它们写成一个数组，此时小儿子偷摸的想要老父亲的自行车，老父亲允许了，让他自己拿于是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.goods = [<span class="string">"$1"</span>, <span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> son2 = <span class="keyword">new</span> Son();</span><br><span class="line">son2.goods.push(<span class="string">"自行车"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son1.goods); <span class="comment">// ["$1", "手电筒", "冰箱", "自行车"]</span></span><br><span class="line">son1.makeMoney(); <span class="comment">// 努力工作</span></span><br><span class="line"><span class="built_in">console</span>.log(son2.goods); <span class="comment">// ["$1", "手电筒", "冰箱", "自行车"]</span></span><br><span class="line">son2.makeMoney(); <span class="comment">// 努力工作</span></span><br></pre></td></tr></table></figure>

<p>貌似有些尴尬，因为小儿子继承自行车这个事情一下子就被大儿子发现了。这是因为包含引用类型值的原型属性会被所有实例共享。这也是为什么要使用构造函数来定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个原型的实例，于是原先的实例属性也就变成了现在的原型属性。</p>
<p>以这个例子来说，父类的 goods 是个数组（引用数据类型），每个父类的实例都会有一个 goods 的属性，在子类通过原型链继承了父类的原型时，子类的原型就是父类的实例，那么每个子类也同样拥有了 goods 这个原型属性，就相当于在 son.prototype.goods 一样，但是由于包含引用类型的原型属性会被所有实例共享，所以当 son1 对 goods 进行修改时，son2 也会被修改。</p>
<h2 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h2><p>组合继承就是把构造函数继承和原型链继承组合在一起，结合两者的长处。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.goods = [<span class="string">"$1"</span>, <span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> son2 = <span class="keyword">new</span> Son();</span><br><span class="line">son2.goods.push(<span class="string">"自行车"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son1.goods); <span class="comment">// ['$1', '手电筒', '冰箱']</span></span><br><span class="line">son1.makeMoney(); <span class="comment">// 努力工作</span></span><br><span class="line"><span class="built_in">console</span>.log(son2.goods); <span class="comment">// ['$1', '手电筒', '冰箱', '自行车']</span></span><br><span class="line">son2.makeMoney(); <span class="comment">// 努力工作</span></span><br></pre></td></tr></table></figure>

<p>终于满足了小儿子独自继承自行车的梦想。</p>
<h2 id="4、组合继承的优化"><a href="#4、组合继承的优化" class="headerlink" title="4、组合继承的优化"></a>4、组合继承的优化</h2><p>组合继承是 JS 中最经典的继承方式，但是上述中还有些许的缺点，会发现在创建一个子类型的实例时，会创建两次父类的实例，接下来就对这一点进行优化。<br>上述借用原型链继承中，应用 new 关键词的目的，就是希望把父类的原型赋值给子类，那可以直接将父类的原型赋值过去，优化 1 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.goods = [<span class="string">"$1"</span>, <span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = Father.prototype;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> son2 = <span class="keyword">new</span> Son();</span><br><span class="line">son2.goods.push(<span class="string">"自行车"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son1.goods); <span class="comment">// ['$1', '手电筒', '冰箱']</span></span><br><span class="line">son1.makeMoney(); <span class="comment">// 努力工作</span></span><br><span class="line"><span class="built_in">console</span>.log(son2.goods); <span class="comment">// ['$1', '手电筒', '冰箱', '自行车']</span></span><br><span class="line">son2.makeMoney(); <span class="comment">// 努力工作</span></span><br></pre></td></tr></table></figure>

<p>结果没有任何问题，也解决了调用两次父类实例的问题，但是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">son1.constructor</span><br><span class="line">ƒ Father() &#123;</span><br><span class="line">  <span class="keyword">this</span>.goods = [<span class="string">"$1"</span>, <span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类虽然是继承父类的，但是它的实例也是一个个体啊，儿子 1 和儿子 2 都是儿子啊，怎么一下子成为老子了，这肯定不行。<br>所以我们再次优化，优化 2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.goods = [<span class="string">"$1"</span>, <span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Father.prototype);</span><br><span class="line">Son.prototype.constuctor = Son;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> son2 = <span class="keyword">new</span> Son();</span><br><span class="line">son2.goods.push(<span class="string">"自行车"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son1.goods); <span class="comment">// ['$1', '手电筒', '冰箱']</span></span><br><span class="line">son1.makeMoney(); <span class="comment">// 努力工作</span></span><br><span class="line"><span class="built_in">console</span>.log(son2.goods); <span class="comment">// ['$1', '手电筒', '冰箱', '自行车']</span></span><br><span class="line">son2.makeMoney(); <span class="comment">// 努力工作</span></span><br></pre></td></tr></table></figure>

<p>这样才算是真正优化完成。</p>
<h2 id="5、原型式继承"><a href="#5、原型式继承" class="headerlink" title="5、原型式继承"></a>5、原型式继承</h2><p>本来觉得写到上一条的时候就结束了，但是看到了《高程》里对继承的讲述，还有 ES6 继承特性的底层实现原理，觉得还是有必要好好的了解这一块的知识。</p>
<p>如高程所讲，提出这种继承方式的人叫道格拉斯·克罗克福德，他在 2006 年写了一篇名为《Prototypal Inheritance in Javascript》（Javascript 中原型式继承），在此书中他实现了一种新型的继承方式，这个继承方式没有使用严格意义上的构造函数，而是建造一个基准的对象，通过原型将已有的基准对象再创建一个新的对象，同时还不必因此创建自定义类型，为了实现这个目的，他创建了如下函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他在里面创建了一个临时的构造函数，然后将传入的对象赋值给这个临时构造函数的原型，最后返回这个临时构造函数的新实例。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">  money: <span class="string">"$1"</span>,</span><br><span class="line">  goods: [<span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> son1 = object(father);</span><br><span class="line"><span class="keyword">var</span> son2 = object(father);</span><br><span class="line">son2.goods.push(<span class="string">"自行车"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(father.goods); <span class="comment">// ['手电筒', '冰箱', 'John', '自行车']</span></span><br></pre></td></tr></table></figure>

<p>毕竟是通过原型继承，所以终究还是会有原型继承应有的问题，引用类型的属性会被共享，但是有没有感觉这个方法和 Object.create()很像，没错 object.create()就是基于这个方法建立的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">  money: <span class="string">"$1"</span>,</span><br><span class="line">  goods: [<span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="built_in">Object</span>.create(father);</span><br><span class="line"><span class="keyword">var</span> son2 = <span class="built_in">Object</span>.create(father);</span><br><span class="line">son2.goods.push(<span class="string">"自行车"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(father.friends); <span class="comment">// ['手电筒', '冰箱', 'John', '自行车']</span></span><br></pre></td></tr></table></figure>

<p>但 Object.create()不同的是，它还有第二个参数，第二个参数是可选值，设置第二个参数时，可以指定任何属性都会覆盖原型上的同名属性。</p>
<h2 id="6、寄生式继承"><a href="#6、寄生式继承" class="headerlink" title="6、寄生式继承"></a>6、寄生式继承</h2><p>这种继承方式同样是道格拉斯·克罗克福德提出的，有些类似于借用构造函数继承，但是同样的他利用了一个临时构造函数的思想，即所说的寄生思想，将一个对象作为基准，然后寄生在这个对象上，这样就可以拥有这个对象的所有属性和方法，封装成一个函数，在函数内部给这个对象的副本添加新的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(o);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种呢，无法做到函数的复用大大降低效率。</p>
<h2 id="7、寄生组合式继承"><a href="#7、寄生组合式继承" class="headerlink" title="7、寄生组合式继承"></a>7、寄生组合式继承</h2><p>前面提到的组合继承时最经典的继承方式，但是有个很重要的问题，会执行两次父类的构造函数。没事我们可以用寄生组合式继承来解决这个问题。</p>
<p>我们引用《高程》对寄生组合式继承解释：即通过借用构造函数来继承属性，通过原型链的混用形式来继承方法。其背后的思路是：不必为了子类型的原型而调用超类型的构造函数，我们所需要的的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">father, son</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(father.prototype);</span><br><span class="line">  prototype.constructor = son;</span><br><span class="line">  son.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例实现了最简单的寄生组合式继承。它接受了两个参数，分别是父类的构造函数和子类的构造函数。在函数内部第一步是创建一个父类型原型副本，第二步是将新的副本添加 constructor，弥补因重构原型而失去的默认 constuctor 属性，第三步是将新的副本赋值给子类型的原型上。</p>
<p>这样我们就可以保证只执行一次父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.money = <span class="string">"$1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Father, Son);</span><br></pre></td></tr></table></figure>

<h2 id="8、ES6-的继承-class…extends…"><a href="#8、ES6-的继承-class…extends…" class="headerlink" title="8、ES6 的继承 class…extends…"></a>8、ES6 的继承 class…extends…</h2><p>以前说到继承的时候只是觉得是个语法糖，用起来很是方便，但是通过写这篇文章查阅资料时看到了其底层实现的原理。这也是写了原型式继承、寄生继承、寄生组合式继承的原因。</p>
<p>我们先来看一下 ES6 继承：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.money = <span class="string">"$1"</span>;</span><br><span class="line">    <span class="keyword">this</span>.goods = [<span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Bable 转成 ES5 后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(</span><br><span class="line">      <span class="string">"this hasn't been initialised - super() hasn't been called"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)</span><br><span class="line">    ? call</span><br><span class="line">    : self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">"Super expression must either be null or a function, not "</span> +</span><br><span class="line">        <span class="keyword">typeof</span> superClass</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">      value: subClass,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (superClass)</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">      ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass)</span><br><span class="line">      : (subClass.__proto__ = superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Father = <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Father);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.makeMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"努力工作"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.money = <span class="string">"$1"</span>;</span><br><span class="line">  <span class="keyword">this</span>.goods = [<span class="string">"手电筒"</span>, <span class="string">"冰箱"</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Son = (<span class="function"><span class="keyword">function</span> (<span class="params">_Father</span>) </span>&#123;</span><br><span class="line">  _inherits(Son, _Father);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Son);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      (Son.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(Son)).call(<span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Son;</span><br><span class="line">&#125;)(Father);</span><br></pre></td></tr></table></figure>

<p>我们可以看到当创建类的时候，ES6 转换为 ES5 时，跟以前创建类会多一个_classCallCheck 函数，其实看名称就知道是一个检测，它接受两个参数，第一个是 this，第二个是构造函数，判断 this 是否是这个这个构造函数的实例，即 instanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，说白了就是判断调用前是否有 new 关键字，不是则抛出 Cannot call a class as a function 异常，所以能进一步可知 class 就是一个语法糖。</p>
<p>ES6 的继承转换为 ES5 后发现子类是一个自执行的函数，将父类作为参数传递过去。首先是_inherits 函数，同样接受两个参数，一个是子类构造函数，一个是父类构造函数。看其内部结构：</p>
<ol>
<li>首先判断父类的类型</li>
<li>基于父类的原型创建一个新的对象。并通过 Object.create 的第二个参数，将新对象的构造函数指向子类，再将其赋值给子类的原型。</li>
<li>将子类的__proto__指向父类的构造函数</li>
</ol>
<p>第二步是不是很熟悉，没错就是寄生组合式继承的简单版。<br>之后是个闭包，保存父类的引用，闭包内部的实现步骤：</p>
<ol>
<li>判断调用前是否有 new 关键字</li>
<li>因为_inherits 函数执行后，Son.__proto__ || Object.getPrototypeOf(Son)实际上指的就是父类的构造函数，通过 call 方法将其调用改为当前的 this</li>
<li>_possibleConstructorReturn 函数中，首先校验 this 是否被初始化，super 是否调用，并返回父类已经赋值完的 this。</li>
<li>然后进行子类构造函数中的逻辑</li>
</ol>
<p>当我们没有写子类构造函数时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 转为ES5</span></span><br><span class="line"><span class="keyword">var</span> Son = (<span class="function"><span class="keyword">function</span> (<span class="params">_Father</span>) </span>&#123;</span><br><span class="line">  _inherits(Son, _Father);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Son);</span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      (Son.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(Son)).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Son;</span><br><span class="line">&#125;)(Father);</span><br></pre></td></tr></table></figure>

<p>可见默认的构造函数中会主动调用父类构造函数，并默认把当前 constructor 传递的参数传给了父类。<br>所以当我们声明了 constructor 后必须主动调用 super(),否则无法调用父构造函数，无法完成继承。<br>本篇就先写到这吧，欢迎留言讨论。</p>
<p>参考资料：</p>
<p>JavaScript 高级程序设计（第 3 版）</p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2020/06/12/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>根据《高程》中所讲：闭包是指有权访问另一个函数作用域中的变量的函数。<br>《Javascript 权威指南》中指出，从技术角度讲，所有的 javascript 函数都是闭包。<br>闭包，之前感觉很神秘，今天我们来揭开它的面纱，看看究竟干了什么！</p>
<a id="more"></a>

<p>我们举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = scope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>根据前面所写的《执行上下文》中我们可以找到当解析代码时，会执行上下文栈，那我们按照执行上下文来看一下函数内部都做了哪些事情。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = [];</span><br><span class="line">scope.push(globalContext = &#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  LE: &#123;</span></span><br><span class="line"><span class="xml">    ER: &#123;</span></span><br><span class="line">      scope: &lt;func&gt;,</span><br><span class="line">      foo: &lt;uninitialized&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;&#125;,</span><br><span class="line">    outer: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">scope.push(&lt;scope&gt;, scopefunctionContext = &#123;</span><br><span class="line">  this: &lt;Global Object&gt;,</span><br><span class="line">  LE: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">      arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;globalContext&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;&#125;,</span><br><span class="line">    outer: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">scope.pop();</span><br><span class="line">scope.push(&lt;foo&gt;, foofunctionContext = &#123;</span><br><span class="line">  this: &lt;Global Object&gt;,</span><br><span class="line">  LE: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">      arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;scopefunctionContext&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;&#125;,</span><br><span class="line">    outer: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">scope.pop();</span><br></pre></td></tr></table></figure>

<p>其实会很好奇，scope 函数执行完后明明已经在执行栈中移除了，为什么 foo 函数依旧能访问到其内部的变量。是因为 foo 函数的对外部引用是 scope 的词法环境，这个环境还没有消失。正因为 JS 有这个特点，所以才会生成闭包这个概念。</p>
<p>下面举几个常用的面试题，来自《高程》：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">createFunctions().forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行上述之后，发现最后输出 10 个 10，为什么不是 0-9 呢？我们来分析一下，已 result[0]为例，在 result[0]运行之前，全局上下文是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = [];</span><br><span class="line">scope.push(globalContext = &#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  LE: &#123;</span></span><br><span class="line"><span class="xml">    ER: &#123;</span></span><br><span class="line">      createFunctions: &lt;func&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">      result: [....],</span><br><span class="line">      i: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当 result[0]运行时，它的函数上下文发生变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">functionContext = &#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">   LE: &#123;</span></span><br><span class="line"><span class="xml">    ER: &#123;&#125;,</span></span><br><span class="line">    outer: &lt;createFunctionsContext&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;&#125;,</span><br><span class="line">    outer: &lt;createFunctionsContext&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 result[0]中没有定义 i，所以就会向外部的词法环境中查找，最后找到 i，输出 10。</p>
<p>如果想输出预期结果 0-9，高程中也给出了解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">createFunctions().forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  item();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当再次执行 result[0]时，这个匿名函数的上下文：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">functionContext = &#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">   LE: &#123;</span></span><br><span class="line"><span class="xml">    ER: &#123;</span></span><br><span class="line">      匿名function: &lt;func&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;createFunctionsContext&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">      arguments: &#123;</span><br><span class="line">        0: 0,</span><br><span class="line">        length: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;createFunctionsContext&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当匿名函数执行时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">匿名functionContext = &#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">   LE: &#123;</span></span><br><span class="line"><span class="xml">    ER: &#123;&#125;,</span></span><br><span class="line">    outer: &lt;functionContext&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VR: &#123;</span><br><span class="line">    ER: &#123;</span><br><span class="line">      arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;functionContext&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样其内部没有 num 变量，那它就会去外部的此法环境中查找，找到了 functionContext，functionContext 内部的 num 为 0，则输出 0。这样就完美解决了这个问题，也体现了闭包的作用，但现在有 let 了这种就用的很少了。闭包虽然能解决一些问题，但是尽量还是要少用闭包，因为其外部的词法环境已经销毁了，但其内部还在引用，这样的话闭包过多会造成内存泄漏，最简单直接的办法就是，执行完后设置为 null，这样就销毁了。</p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/2020/04/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="1、显示类型转换"><a href="#1、显示类型转换" class="headerlink" title="1、显示类型转换"></a>1、显示类型转换</h2><p>显示类型转换顾名思义就是用特有的方法对类型进行转换<br>显示类型转换的方式只有三种：</p>
<a id="more"></a>

<h3 id="1、Number"><a href="#1、Number" class="headerlink" title="1、Number()"></a>1、Number()</h3><ul>
<li><p>原始类型转换</p>
<ul>
<li>数值：转换后还是数值</li>
<li>字符串：如果可以被解析为数值，则转化为相应的数值会忽略所有前导的 0，否则得到 NaN，空字符串为 0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"000001"</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>布尔值：true 转成 1，false 转成 0</li>
<li>undefined：转成 NaN</li>
<li>null：转成 0</li>
</ul>
</li>
<li><p>对象类型转换</p>
<ul>
<li>先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 toString 方法返回的是复合类型的值，则报错</li>
</ul>
</li>
<li><p>parseInt 和 parseFloat</p>
<ul>
<li>parseInt：只解析整数，当传入的值以‘0x’或‘0X’开头时，会解析成十六进制数</li>
<li>parseFloat：既可以解析整数又可以解析浮点数</li>
<li>共同点：都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN</li>
</ul>
</li>
</ul>
<h3 id="2、String"><a href="#2、String" class="headerlink" title="2、String()"></a>2、String()</h3><ul>
<li><p>原始类型转换</p>
<ul>
<li>数值：转为相应的字符串</li>
<li>字符串：转换后还是原来的值</li>
<li>布尔值：true 转为‘true’，false 转为‘false’</li>
<li>undefined：转为‘undefined</li>
<li>null：转为‘null’</li>
</ul>
</li>
<li><p>对象类型转换</p>
<ul>
<li>先调用 toString 方法，如果 toString 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤</li>
<li>如果 toString 方法返回的是复合类型的值，再调用 valueOf 方法，如果 valueOf 方法返回的是原始类型的值，则对该值使用 String 方法，不再进行以下步骤</li>
<li>如果 valueOf 方法返回的是复合类型的值，则报错</li>
</ul>
</li>
<li><p>JSON.stringify()<br>JSON.stringify 底层也是调用了 toString 方法</p>
</li>
</ul>
<h3 id="3、Boolean"><a href="#3、Boolean" class="headerlink" title="3、Boolean()"></a>3、Boolean()</h3><p>undefined、null、-0、+0、NaN、’’（空字符串）返回的都是 false，除了上述的都是返回 true，包括对象类型</p>
<h2 id="2、隐式类型转换"><a href="#2、隐式类型转换" class="headerlink" title="2、隐式类型转换"></a>2、隐式类型转换</h2><p>隐式类型转换同样有三种：</p>
<h3 id="1、-（加号）"><a href="#1、-（加号）" class="headerlink" title="1、+（加号）"></a>1、+（加号）</h3><h4 id="1-1-一元-（加号）运算符"><a href="#1-1-一元-（加号）运算符" class="headerlink" title="1.1 一元+（加号）运算符"></a>1.1 一元+（加号）运算符</h4><p>查看<a href="http://es5.github.io/#x11.4.6" target="_blank" rel="noopener">ES5 规范 11.4.6</a>可以看到，当+（加号）作为一元运算符时，底层会调用 ToNumber 方法去处理，相当于 Number()，当+（加号）后是普通数值时，返回的就是 Number(数值)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="string">"1"</span>; <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当+（加号）后是对象类型时，对象类型就会像显示类型中所讲：</p>
<ul>
<li>先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再进行后续步骤</li>
<li>如果 toString 方法返回的是复合类型的值，则报错</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+[]; <span class="comment">//0  []先调用valueof方法返回[]，再调用toString方法返回""</span></span><br><span class="line">+&#123;&#125;; <span class="comment">//NaN &#123;&#125;相当于new Object() 先调用valueof方法返回&#123;&#125;，再调用toString方法返回"[object Object]"</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-二元-（加号）运算符"><a href="#1-2-二元-（加号）运算符" class="headerlink" title="1.2 二元+（加号）运算符"></a>1.2 二元+（加号）运算符</h4><p>查看<a href="http://es5.github.io/#x11.6.1" target="_blank" rel="noopener">ES5 规范 11.6.1</a>可以看到当 value1+value2 时：</p>
<pre><code>1. lprim = ToPrimitive(value1)
2. rprim = ToPrimitive(value2)
3. 如果 lprim 和 rprim 都是 String 类型时，则直接返回 ToString(lprim)和 ToString(rprim)拼接结果
4. 返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果</code></pre><p>ToPrimitive、ToString、ToNumber 三者皆为内部函数:</p>
<ul>
<li><p>ToPrimitive 执行的步骤：</p>
<ol>
<li>如果 obj 为基本类型，直接返回</li>
<li>否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。</li>
<li>否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。</li>
<li>否则，JavaScript 抛出一个类型错误异常。</li>
</ol>
</li>
<li><p>ToString 相当于 String()</p>
</li>
<li><p>ToNumber 相当于 Number()</p>
</li>
</ul>
<p>按上述规范，对下列几个例子进行讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> + <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive(null) 因为null为基本数据类型，所以返回null</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都不是String类型，所以执行第四部</span></span><br><span class="line"><span class="comment">//4、ToNumber(null)+ToNumber(1),所以返回为1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="number">1</span>; <span class="comment">//NaNnull</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive(undefined) 因为undefined为基本数据类型，所以返回undefined</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive(1) 因为1为基本数据类型，所以返回1</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都不是String类型，所以执行第四部</span></span><br><span class="line"><span class="comment">//4、ToNumber(undefined)+ToNumber(1),所以返回为NaN</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] + []; <span class="comment">//''</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都是String类型，所以直接返回拼接，结果为''</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] + &#123;&#125;; <span class="comment">//'[object Object]'</span></span><br><span class="line"><span class="comment">//1、lprim = ToPrimitive([]) []的valueof为[]不是基本数据类型，再调用toString方法返回的是''</span></span><br><span class="line"><span class="comment">//2、lprim = ToPrimitive(&#123;&#125;) &#123;&#125;的valueof为&#123;&#125;不是基本数据类型，再调用toString方法返回的是'[object Object]'</span></span><br><span class="line"><span class="comment">//3、lprim和lprim都是String类型，所以直接返回拼接，结果为'[object Object]'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + []; <span class="comment">//0</span></span><br><span class="line"><span class="comment">//按照规范来说，这个的结果应该和上一个一样，但是为什么会出现如此的不同，是因为在浏览器中，&#123;&#125;相当于一个独立的代码块，所以浏览器认为&#123;&#125;+[]相当于+[]，所以返回0</span></span><br><span class="line"><span class="comment">//如果想返回和上一个一样的结果的话可以在表达式外加括号,(&#123;&#125; + [])这样就返回正常的结果了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + &#123;&#125;; <span class="comment">//谷歌返回'[object Object][object Object]' 火狐返回NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="2、比较运算"><a href="#2、比较运算" class="headerlink" title="2、比较运算"></a>2、比较运算</h3><h4 id="2-1-相等"><a href="#2-1-相等" class="headerlink" title="2.1 ==相等"></a>2.1 ==相等</h4><p>同样我们查看<a href="http://es5.github.io/#x11.9.3" target="_blank" rel="noopener">ES5 规范 11.9.3</a>中所讲：<br>比较 x == y，其中 x 和 y 是值，产生 true 或 false。这样的比较执行如下：</p>
<pre><code>1. 如果 x,y 类型相同，则
  a. 如果 x 是 Undefined，则返回 true。
  b. 如果 x 为 Null，则返回 true。
  c. 如果 x 是数字，则
      i. 如果 x 为 NaN，则返回 false。
      ii. 如果 y 为 NaN，则返回 false。
      iii. 如果 x 与 y 相同，则返回 true。
      iv. 如果 x 为+0 且 y 为 − 0，则返回 true。
      v. 如果 x 为 − 0 且 y 为+0，则返回 true。
      vi.返回 false。
  d. 如果 x 类型为 String，则如果 x 和 y 是完全相同的字符序列（相同的长度和相同位置的相同字符），则返回 true。否则，返回 false。
  e. 如果 x 类型为布尔值，则如果 x 和 y 均为 true 或均为 false，则返回 true。否则，返回 false。
  f. 如果 x 和 y 指向同一对象，则 返回 true。否则，返回 false。
2. 如果 x 是 Null 和 y 是 Undefined 的，返回 true。
3. 如果 X 是 Undefined 和 y 为 Null，返回 true。
4. 如果 x 类型是 Number 且 y 类型是 String，则返回比较结果 x == ToNumber（y）。
5. 如果 x 类型为 String 且 y 类型为 Number，则返回比较结果 ToNumber（x）== y。
6. 如果 x 类型为布尔值，则返回比较结果 ToNumber（x）== y。
7. 如果 y 类型为布尔型，则返回比较结果 x == ToNumber（y）。
8. 如果 x 类型是 String 或 Number 且 y 类型是 Object，则返回比较结果 x == ToPrimitive（y）。
9. 如果 x 类型是 Object 并且 y 类型是 String 或 Number，则返回比较结果 ToPrimitive（x）== y。
10. 返回 false。</code></pre><p>按上述规范，对下列几个例子进行讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的1.a、1.b条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">//false</span></span><br><span class="line"><span class="comment">//查看上述的1.c.i条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的2、3条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">"1"</span>; <span class="comment">//true</span></span><br><span class="line"><span class="string">"1"</span> == <span class="number">1</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的4、5条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的6、7条</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] == <span class="number">0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == []; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">//查看上述的8、9条</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-lt-判断"><a href="#2-2-lt-判断" class="headerlink" title="2.2 &lt;判断"></a>2.2 &lt;判断</h4><p>同样我们查看<a href="http://es5.github.io/#x11.8.5" target="_blank" rel="noopener">ES5 规范 11.8.5</a>中所讲：<br>比较 x &lt; y（其中 x 和 y 是值）会产生 true，false 或 undefined（这表明至少一个操作数是 NaN）。除 x 和 y 外，该算法还使用名为 LeftFirst 的布尔标志 作为参数。该标志用于控制对 x 和 y 进行具有潜在可见副作用的操作的顺序 。这是必需的，因为 ECMAScript 指定了从左到右的表达式求值。LeftFirst 的默认值 为 true，表示 x 参数对应于 y 参数对应表达式左侧出现的表达式。如果 LeftFirst 为假，则相反，操作必须在 x 之前对 y 执行。这样的比较执行如下：</p>
<pre><code>1. 如果LeftFirst标志为true，则
  a. 设 px为调用ToPrimitive的结果（x，Number）。
  b. 令 py为调用ToPrimitive的结果（y，Number）。
2. 否则需要颠倒评估顺序以保留从左到右的评估
  a. 令 py为调用ToPrimitive的结果（y，Number）。
  b. 设 px为调用ToPrimitive的结果（x，Number）。
3. 如果px和py都不是String类型，则
  a. 令 nx为调用ToNumber（px）的结果。因为px和py是原始值，所以评估顺序并不重要。
  b. 令 ny为调用ToNumber（py）的结果。
  c. 如果 nx是NaN，则返回undefined。
  d. 如果 ny是NaN，则返回undefined。
  e. 如果 nx和ny是相同的Number值，则返回false。
  f. 如果 nx为+0且ny为− 0，则返回false。
  g. 如果 nx为− 0 且ny为+0，则返回false。
  h. 如果 nx为+ ∞，则返回false。
  i. 如果 ny为+ ∞，则返回true。
  j. 如果 ny为-∞，则返回false。
  k. 如果 nx为-∞，则返回true。
  l. 如果nx的数学值小于ny的数学值（请注意，这些数学值都是有限的且不都是零），则返回true。否则，返回 false。
4. 否则，px和py都是字符串
  a. 如果 py是px的前缀，则返回false。（如果q 可以是连接p和其他String r的结果，则String值p是String值q的前缀。请注意，任何String都是其自身的前缀，因为r 可能是空String。）
  b. 如果 px是py的前缀，则返回true。
  c. 令 k为最小的非负整数，以使px内的位置k处的字符不同于py内的位置k处的字符。（必须有一个k，因为String都不是另一个的前缀。）
  d. 设m为整数，表示字符在px内位置k处的代码单位值。
  e. 设n为整数，表示字符在py中位置k处的代码单位值。
  f. 如果 m &lt; n，则返回true。否则，返回 false。</code></pre><p>按上述规范，对下列几个例子进行讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] &lt; []; <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 以我理解为首先LeftFirst发现左边为false，而后颠倒发现左边依旧为false，则相当于fasle&lt;fasle 最后结果为fasle</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] &lt; &#123;&#125;; <span class="comment">//ture</span></span><br><span class="line"><span class="comment">// 相当于''和'[object Object]'进行比较，则明显空字符串小</span></span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/159" target="_blank" rel="noopener">冴羽：JavaScript 深入之头疼的类型转换(上)</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/164" target="_blank" rel="noopener">冴羽：JavaScript 深入之头疼的类型转换(下)</a></p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
